<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn Haskell by building a blog generator</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Lets code already!</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-book"><a class="header" href="#about-this-book">About this book</a></h1>
<blockquote>
<p>Note: This book is still fairly new. If you find errors, <a href="https://github.com/soupi/learn-haskell-blog-generator/issues">please let me know</a>.</p>
</blockquote>
<!--
<div style="text-align: center">
  <img src="book-logo.png" alt="book logo" style="max-width: 40%">
</div>
-->
<p>In this book we will implement a simple static blog generator in Haskell,
converting documents written in our own custom markup language to HTML.</p>
<p>We will:</p>
<ol>
<li>Implement a tiny HTML printer library</li>
<li>Define and parse our own custom markup language</li>
<li>Read files and glue things together</li>
<li>Add command line arguments parsing</li>
<li>Write tests and documentation</li>
</ol>
<p>In each chapter of the book we will focus on a particular task we wish to achieve,
and through the chapter we'll learn just enough Haskell to complete the task.</p>
<h2 id="why-should-you-read-this-book"><a class="header" href="#why-should-you-read-this-book">Why should you read this book?</a></h2>
<p>There are many Haskell tutorials, guides and books out there. Why read this one?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>There are probably more, but here are a few possible pros:</p>
<ul>
<li>It's <strong>relatively short</strong> - most Haskell books out there are hundreds of pages long.
This book (when exported to PDF) is roughly 150 pages long.</li>
<li>It's <strong>project oriented</strong>. Many Haskell books teach Haskell by teaching the underlying
concepts and features in a neat progression. In this book we try to build a program,
and learn Haskell on the way. This will be a pro to some, and a con to others.
There are other tutorials like this. The most notable ones are
<a href="https://www.apress.com/gp/book/9781430262510#otherversion=9781430262503">Beginning Haskell</a>
and <a href="https://haskell-via-sokoban.nomeata.de/">Haskell via Sokoban</a>.</li>
<li>It touches on <strong>important topics</strong> such as design patterns, testing and documentation.</li>
<li>It's <strong>online</strong>, which means corrections are easy to make.</li>
<li>It's <strong>free</strong>.</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>There are probably more, but here are a few possible cons:</p>
<ul>
<li>It may <strong>lack depth</strong> - many, much longer Haskell tutorials are long because they go
deeper into the nuts and bolts of each feature.</li>
<li>It may <strong>not cover as many features or techniques</strong> as other tutorials -
we try to cover features as they pop up in our implementation, but we will
probably miss features that aren't as important for our tasks,
while other resources may try to cover many different use cases.</li>
<li>It is <strong>very new</strong> and not &quot;battle-tested&quot;. Who knows if this is a good approach to
learning Haskell? Maybe you could help with that!</li>
<li>It <strong>doesn't have a technical editor</strong>, making the book not as good as it could've been.</li>
</ul>
<h3 id="other-learning-resources"><a class="header" href="#other-learning-resources">Other learning resources</a></h3>
<p>The <a href="https://www.haskell.org/documentation/">haskell.org/documentation</a> page lists
many tutorials, books, guides and courses. You can find a few alternatives that I can
recommend <a href="https://github.com/soupi/haskell-study-plan#about-this-guide">in this list</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>In this chapter we will create a simple HTML &quot;hello world&quot; program and use the Haskell toolchain
to compile and run it.</p>
<blockquote>
<p>If you haven't installed a Haskell toolchain yet, visit
<a href="https://haskell.org/downloads">haskell.org/downloads</a> for instructions on how to download
and install a Haskell toolchain.</p>
</blockquote>
<h2 id="a-haskell-source-file"><a class="header" href="#a-haskell-source-file">A Haskell source file</a></h2>
<p>A Haskell source file is composed of definitions.</p>
<p>The most common type of definitions have the following form:</p>
<pre><code class="language-hs">&lt;name&gt; = &lt;expression&gt;
</code></pre>
<p>Note that:</p>
<ol>
<li>We cannot write expressions without binding them to a name</li>
<li>Names must start with a lowercase letter</li>
<li>We cannot use the same name more than once in a file</li>
</ol>
<p>A source file containing a definition of the name <code>main</code> can be treated as an executable,
and the expression <code>main</code> is bound to is the entry point to the program.</p>
<p>Let's create a new Haskell source file called <code>hello.hs</code>, and write the following line there:</p>
<pre><code class="language-hs">main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>We've defined a new name, <code>main</code>, and bound it to the expression <code>putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.</p>
<p>the body of <code>main</code> means calling the function <code>putStrLn</code> with the string <code>&quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>
as input. <code>putStrLn</code> takes a single string as input and prints that string to the standard output.</p>
<p><strong>Note</strong>: we don't need parenthesis to pass arguments to functions in Haskell.</p>
<p>Running this program will result in the following text printed on the screen:</p>
<pre><code>&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<h2 id="compiling-programs"><a class="header" href="#compiling-programs">Compiling programs</a></h2>
<p>To run this little program, we can compile it using the command line program <code>ghc</code>:</p>
<pre><code class="language-sh">&gt; ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
</code></pre>
<p>Invoking <code>ghc</code> with <code>hello.hs</code> will create the following artifact files:</p>
<ol>
<li><code>hello.o</code> - Object file</li>
<li><code>hello.hi</code> - Haskell interface file</li>
<li><code>hello</code> - A native executable file</li>
</ol>
<p>And after the compilation, we can run the <code>hello</code> executable:</p>
<pre><code class="language-sh">&gt; ./hello
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<h2 id="interpreting-programs"><a class="header" href="#interpreting-programs">Interpreting programs</a></h2>
<p>Alternatively, we can skip the compilation and creation of artifact files phase, and run the source file directly
using the command line program <code>runghc</code>:</p>
<pre><code class="language-sh">&gt; runghc hello.hs
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>We can also redirect the output of the program to a file and then open it in Firefox.</p>
<pre><code class="language-sh">&gt; runghc hello.hs &gt; hello.html
&gt; firefox hello.html
</code></pre>
<p>This command should open Firefox and display a web page with <code>Hello, world!</code> written in it.</p>
<p>I recommend using <code>runghc</code> with this tutorial. While compiling produces significantly faster programs,
intepreting programs provides us with faster feedback while we are developing and making frequent changes.</p>
<blockquote>
<p>If you want to learn more about the core Haskell tools, you can read
<a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools">this article</a>,
but what's described above is enough for our usage at the moment.</p>
</blockquote>
<h2 id="more-bindings"><a class="header" href="#more-bindings">More bindings</a></h2>
<p>We can define the HTML string passed to <code>putStrLn</code> in a new name instead of passing
it directly to <code>putStrLn</code>. Change the content of file <code>hello.hs</code> we defined above to:</p>
<pre><code class="language-hs">main = putStrLn myhtml

myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p><strong>Note</strong>: the order in which we declare the bindings does not matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-html-printer-library"><a class="header" href="#building-an-html-printer-library">Building an HTML printer library</a></h1>
<p>In this part we'll explore a few basic building blocks in Haskell,
including functions, types and modules, while building a small HTML printer library
with which we will later construct HTML pages from our markup blog posts.</p>
<p>If you're not familiar with HTML and would like a quick tutorial before diving in, MDN's
<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started">Getting started with HTML</a>
is a good overview on the subject.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexible-html-content-functions"><a class="header" href="#flexible-html-content-functions">Flexible HTML content (functions)</a></h1>
<p>We'd like to be able to write different HTML pages without having to write the whole
structure of HTML and body tags over and over again. We can do that with functions.</p>
<p>To define a function, we create a definition like we saw previously and add the argument
names after the name and before the equals sign (<code>=</code>).
So a function definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; = &lt;expression&gt;
</code></pre>
<p>The argument names will be available in scope on the right side of the equals sign
(in the <code>&lt;expression&gt;</code>), and the function name will be <code>&lt;name&gt;</code>.</p>
<p>We'll define a function that takes a string, which is the content of the page, and wraps it in
the relevant <code>html</code> and <code>body</code> tags by concatenating them before and after the content.
We use the operator <code>&lt;&gt;</code> to concatenate two strings.</p>
<pre><code class="language-hs">wrapHtml content = &quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>This function, <code>wrapHtml</code>, takes one argument named <code>content</code> and returns a string
that prefixes <code>&lt;html&gt;&lt;body&gt;</code> before the content and appends <code>&lt;/body&gt;&lt;/html&gt;</code> after it.
Note that it is common to use camelCase in Haskell for names.</p>
<p>Now we can adjust our <code>myhtml</code> definition from the previous chapter:</p>
<pre><code class="language-hs">myhtml = wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>Again, notice that we don't need parenthesis when calling functions. Function calls have the form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;
</code></pre>
<p>However, if we wanted to substitute <code>myhtml</code> with the expression <code>myhtml</code> is bound
to in <code>main = putStrLn myhtml</code>, we would have to wrap the expression in parenthesis:</p>
<pre><code class="language-hs">main = putStrLn (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p>If we accidentally write this instead:</p>
<pre><code class="language-hs">main = putStrLn wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>we'll get an error from GHC stating that <code>putStrLn</code> is applied to two arguments,
but it only takes one. This is because the above is of the form <code>&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt;</code>
in which, as we defined earlier, <code>&lt;arg1&gt;</code> and <code>&lt;arg2&gt;</code> are arguments to <code>&lt;name&gt;</code>.</p>
<p>By using parenthesis we can group together the expressions in the right order.</p>
<blockquote>
<h4 id="an-aside-about-operator-precedence-and-fixity"><a class="header" href="#an-aside-about-operator-precedence-and-fixity">An aside about operator precedence and fixity</a></h4>
<p>operators (like <code>&lt;&gt;</code>) are infix functions which take two arguments - one from each side.</p>
<p>When there are multiple operators in the same expression without parenthesis, the operator
<em>fixity</em> (left or right) and <em>precedence</em> (a number between 0 and 10) determines which
operator binds more tightly.</p>
<p>In our case <code>&lt;&gt;</code> has <em>right</em> fixity, so Haskell adds invisible parenthesis on the right side
of <code>&lt;&gt;</code>. So for example:</p>
<pre><code class="language-hs">&quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>is viewed by Haskell as:</p>
<pre><code class="language-hs">&quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; (content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;)
</code></pre>
<p>For an example of precedence, in the expression <code>1 + 2 * 3</code>,
the operator <code>+</code> has precedence 6, and the operator <code>*</code> has precedence 7,
so we give precedence to <code>*</code> over <code>+</code>. Haskell will view this expression as:</p>
<pre><code class="language-hs">1 + (2 * 3)
</code></pre>
<p>You might run into errors when mixing different operators with the <em>same precedence</em>
but <em>different fixity</em>, because Haskell won't understand how to group these expressions.
In that case we can solve the problem by adding parenthesis explicitly.</p>
</blockquote>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Separate the functionality of <code>wrapHtml</code> to two functions:</p>
<ol>
<li>One that wraps content in <code>html</code> tag</li>
<li>one that wraps content in a <code>body</code> tag</li>
</ol>
<p>Name the new functions <code>html_</code> and <code>body_</code>.</p>
</li>
<li>
<p>Change <code>myhtml</code> to use these two functions.</p>
</li>
<li>
<p>Add another two similar functions for the tags <code>&lt;head&gt;</code> and <code>&lt;title&gt;</code>
and name them <code>head_</code> and <code>title_</code>.</p>
</li>
<li>
<p>Create a new function, <code>makeHtml</code>, which takes two strings as input:</p>
<ol>
<li>One string for the title</li>
<li>One string for the body content</li>
</ol>
<p>And construct an HTML string using the functions implemented in the previous exercises.</p>
<p>The output for:</p>
<pre><code class="language-hs">makeHtml &quot;My page title&quot; &quot;My page content&quot;
</code></pre>
<p>Should be:</p>
<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;My page title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My page content&lt;/body&gt;&lt;/html&gt;
</code></pre>
</li>
<li>
<p>Use <code>makeHtml</code> in <code>myhtml</code> instead of using <code>html_</code> and <code>body_</code> directly</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">myhtml = html_ (body_ &quot;Hello, world!&quot;)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #5</summary>
<pre><code class="language-hs">myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;
</code></pre>
</details>
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main = putStrLn myhtml

myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
<p>We can now run our <code>hello.hs</code> program, pipeline the output into a file,
and open it in our browser:</p>
<pre><code class="language-sh">runghc hello.hs &gt; hello.html
firefox hello.html
</code></pre>
<p>It should display <code>Hello, world!</code> on the page and <code>Hello title</code> on the page's title.</p>
</details>
<hr />
<h2 id="indentation"><a class="header" href="#indentation">Indentation</a></h2>
<p>You might ask how does Haskell know a definition is complete?
The answer is: Haskell uses indentation to know when things should be grouped together.</p>
<p>Indentation in Haskell can be a bit tricky, but in general: code which is supposed to be
part of another expression should be indented further than the beginning of that expression.</p>
<p>We know two definitions are separate because the second one is not indented further than the first one.</p>
<h3 id="indentation-tips"><a class="header" href="#indentation-tips">Indentation tips</a></h3>
<ol>
<li>Choose a specific amount of spaces for indentation (2 spaces, 4 spaces, etc) and stick to it.
Always use spaces over tabs.</li>
<li>Do not indent more than once in any given time.</li>
<li>When in doubt, drop line as needed and indent once.</li>
</ol>
<p>Here are a few examples:</p>
<pre><code class="language-hs">main =
    putStrLn &quot;Hello, world!&quot;
</code></pre>
<p>or:</p>
<pre><code class="language-hs">main =
    putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p><strong>Avoid the following styles</strong>, which use more than one indentation steps, or completely disregard
indentation steps:</p>
<pre><code class="language-hs">main = putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<pre><code class="language-hs">main = putStrLn
                (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-type-signatures"><a class="header" href="#adding-type-signatures">Adding type signatures</a></h1>
<p>Haskell is a <strong>statically typed</strong> programming language. That means that every
expression has a type, and we check that the types are valid with
regards to each other before running the program. If we discover that
they are not valid, an error message will be printed and the program
will not run.</p>
<p>An example of a type error would be if we'd pass 3 arguments to a function
that takes only 2, or pass a number instead of a string.</p>
<p>Haskell is also <strong>type inferred</strong>, so we don't <em>need</em> to specify the type
of expressions - Haskell can <em>infer</em> from the context of the expression
what its type should be, and that's what we did up until now. However, <strong>specifying
types is useful</strong> - it adds a layer of documentation for you or others
that will look at the code later, and it helps verify to some degree
that what was intended (with the type signature) is what was
written (with the expression). It is generally recommended to annotate all <em>top-level</em>
definitions with type signatures.</p>
<p>We use double-colon (<code>::</code>) to specify the type of names. We usually
write it right above the definition of the name itself.</p>
<p>Here are a few examples of types we can write:</p>
<ul>
<li><code>Int</code> - The type of integer numbers</li>
<li><code>String</code> - The type of strings</li>
<li><code>Bool</code> - The type of booleans</li>
<li><code>()</code> - The type of the expression <code>()</code>, also called unit</li>
<li><code>a -&gt; b</code> - The type of a function from an expression of type <code>a</code> to an expression of type <code>b</code></li>
<li><code>IO ()</code> - The type of an expression that represents an IO subroutine that returns <code>()</code></li>
</ul>
<p>Let's specify the type of <code>title_</code>:</p>
<pre><code class="language-hs">title_ :: String -&gt; String
</code></pre>
<p>We can see in the code that the type of <code>title_</code> is a function that takes
a <code>String</code> and returns a <code>String</code>.</p>
<p>Let's also specify the type of <code>makeHtml</code>:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Previously, we thought about <code>makeHtml</code> as a function that takes
two strings and returns a string.</p>
<p>But actually, all functions in Haskell take <strong>exactly one argument</strong> as input
and return <strong>exactly one value</strong> as output. It's just convenient to refer
to functions like <code>makeHtml</code> as functions with multiple inputs.</p>
<p>In our case, <code>makeHtml</code> is a function that takes <strong>one</strong> string argument,
and returns a <strong>function</strong>. <em>The function it returns</em> takes a string argument
as well and finally returns a string.</p>
<p>The magic here is that <code>-&gt;</code> is right associative. Which means that when we write:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Haskell parses it as:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; (String -&gt; String)
</code></pre>
<p>Consequently, the expression <code>makeHtml &quot;My title&quot;</code> is also a function!
One that will take a string (the content, the second argument of <code>makeHtml</code>)
and will return the expected HTML string with &quot;My title&quot; in the title.</p>
<p>This is called <strong>partial application</strong>.</p>
<p>To illustrate, let's define <code>html_</code> and <code>body_</code> in a different way by
defining a new function, <code>el</code>.</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>el is a function that takes a tag and content, and wraps the content
with the tag.</p>
<p>We can now implement <code>html_</code> and <code>body_</code> by partially applying <code>el</code> and
only provide the tag.</p>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;
</code></pre>
<p>Note that we didn't need to add the argument on the left side of
equals sign because Haskell functions are &quot;<strong>first class</strong>&quot; - they behave
exactly like normal expressions. You can define names to them like
regular values, put them in data structures, pass them to functions,
everything you can do with regular values like <code>Int</code> or <code>String</code>.</p>
<p>The way Haskell treats names is very similar to copy paste. anywhere
you see <code>html_</code> in the code, you can replace it with <code>el &quot;html&quot;</code>. They are
the same (this is what the equals signs say, right? That the two sides
are the same). This property, of being able to <em>substitute</em> the two sides of the
equals sign with one another, is called <strong>referential transparency</strong>. And
it is pretty unique to Haskell (and a few languages that are very
similar to it like PureScript and Elm)! We'll talk more about this in a later chapter.</p>
<h3 id="anonymouslambda-functions"><a class="header" href="#anonymouslambda-functions">Anonymous/lambda functions</a></h3>
<p>To further drive the point that Haskell functions are first class and
all functions take exactly one argument,
I'll mention that the syntax we've been using up until
now to define function is just syntactic sugar! We can also define
<strong>anonymous functions</strong> - functions without a name, anywhere we'd like.
Anonymous functions are also known as <strong>lambda functions</strong>.
This is a tribute to the original, most primitive
functional programming language - the lambda calculus.</p>
<p>We can create an anonymous function anywhere we'd expect an expression
such as <code>&quot;hello&quot;</code> with the following syntax:</p>
<pre><code class="language-hs">\&lt;argument&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>This little <code>\</code> (which bears some resemblance to the lowercase Greek letter lambda 'Î»')
marks the head of the lambda function,
and the arrow (<code>-&gt;</code>) marks the beginning of the body of the function.
We can even chain lambda functions, making them &quot;multiple argument functions&quot; by
defining another lambda in the body of another, like this:</p>
<pre><code class="language-hs">three = (\num1 -&gt; \num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>Just as before, we evaluate functions by substituting the function argument with
the applied value. In the example above we substitute <code>num1</code> with <code>1</code>, and get
<code>(\num2 -&gt; 1 + num2) 2</code>. Then substitute <code>num2</code> with <code>2</code> and get <code>1 + 2</code>.
We'll talk more about substitution later.</p>
<p>So, when we write:</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Haskell actually translates this under the hood to:</p>
<pre><code class="language-hs">el :: String -&gt; (String -&gt; String)
el = \tag -&gt; \content -&gt;
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Hopefully this form makes it a bit clearer why Haskell functions
always take one argument, even when we have syntactic sugar that
might suggest otherwise.</p>
<p>I'll mention one more syntactic sugar for anonymous functions:
We don't actually have to write multiple argument anonymous functions
this way, we can just write: </p>
<pre><code class="language-hs">\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>to save us some trouble. For example:</p>
<pre><code class="language-hs">three = (\num1 num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>But it's worth remembering what they are under the hood.</p>
<p>We won't be needing anonymous/lambda functions at this point,
but we'll talk more about them later and see where they can be useful.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Add types for all of the functions we created until now</p>
</li>
<li>
<p>Change the implementation of the HTML functions we built to use <code>el</code> instead</p>
</li>
<li>
<p>Add a couple more functions for defining paragraphs and headings:</p>
<ol>
<li><code>p_</code> which uses the tag <code>&lt;p&gt;</code> for paragraphs</li>
<li><code>h1_</code> which uses the tag <code>&lt;h1&gt;</code> for headings</li>
</ol>
</li>
<li>
<p>Replace our <code>Hello, world!</code> string with richer content, use <code>h1_</code> and <code>p_</code>.
We can append HTML strings created by <code>h1_</code> and <code>p_</code> using the append operator <code>&lt;&gt;</code>.</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">myhtml :: String
myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ :: String -&gt; String
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ :: String -&gt; String
head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ :: String -&gt; String
title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)
</code></pre>
</details>
<hr />
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn myhtml

myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)


makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ = el &quot;html&quot;
   
body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;

p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-domain-specific-languages"><a class="header" href="#embedded-domain-specific-languages">Embedded Domain Specific Languages</a></h1>
<p>Right off the bat we run into a common pattern in Haskell: creating
Embedded Domain Specific Languages (EDSLs for short).</p>
<p>Domain specific languages (DSLs) are specialized programming languages that are
tailored to specific domains. In contrast of general purpose languages,
which try to work well in many domains.</p>
<p>A few examples of DSLs are:</p>
<ul>
<li>make - for defining build systems</li>
<li>DOT - for defining graphs</li>
<li>Sed - for defining text transformations</li>
<li>CSS - for defining styling</li>
<li>HTML - for defining web pages</li>
</ul>
<p>An <em>embedded</em> domain specific language is a little language which is
embedded inside another programming language, making a program written in
the EDSL a valid program in the language it was written in.</p>
<p>The little HTML library we've been writing can be considered an EDSL.
It is used specifically for building web pages (by returning HTML strings),
and is valid Haskell code!</p>
<p>In Haskell we frequently create and use EDSLs to express domain specific
logic. We have EDSLs for concurrency, command-line options parsing, JSON and HTML,
creating build systems, writing tests, and many more.</p>
<p>Specialized languages are useful because they can solve specific problems in
a concise (and often safe) way, and by embedding we get to use the full power of
the host language for our domain logic, including syntax highlighting and
various tools available for the language.</p>
<p>The drawback of embedding domain specific languages is that we have to adhere
the rules of the programming language we embed in, such as syntactic and semantic rules.</p>
<p>Some languages alleviate this drawback by providing meta-programming capabilities
in the form of macros or other features to extend the language.
And while Haskell does provide such capabilities as well, it is also expressive and concise
enough that many EDSLs do not need them.</p>
<p>Instead, many Haskell EDSLs use a pattern called <em>the combinator pattern</em>:
They define <em>primitives</em> and <em>combinators</em> -
primitives are basic building blocks of the language,
and combinators are functions that combine primitives to more complex structures.</p>
<p>In our HTML EDSL, our primitives are functions such as <code>html_</code> and <code>title_</code>
that can be used to create a single HTML node, and we pass other
constructed nodes as input to these functions, and combine them to a more complex
structure with the append function <code>&lt;&gt;</code>.</p>
<p>There are still a few tricks we can use to make our HTML EDSL better:</p>
<ol>
<li>
<p>We can use Haskell's type system to make sure we only construct <em>valid</em>
HTML, so for example we don't create a <code>&lt;title&gt;</code> node
without a <code>&lt;head&gt;</code> node or have user content that 
can include unescaped special characters,
and throw a type error when the user tries to do something invalid.</p>
</li>
<li>
<p>Our HTML EDSL can move to its own module so it can be reused in multiple modules</p>
</li>
</ol>
<p>In the next few sections we'll take a look at how to define our own types and
how to work with modules to make it harder to make errors, and a little bit
about linked lists in Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safer-html-construction-with-types"><a class="header" href="#safer-html-construction-with-types">Safer HTML construction with types</a></h1>
<p>In this section we'll learn how to create our own distinguished types
for HTML, and how they can help us avoid invalid construction of HTML strings.</p>
<p>There are a few ways of defining new types in Haskell, in this section
we are going to meet two ways: <code>newtype</code> and <code>type</code>.</p>
<h2 id="newtype"><a class="header" href="#newtype"><code>newtype</code></a></h2>
<p><code>newtype</code> lets us give a new name to an already existing type in a
way that the two cannot mix together.</p>
<p>A <code>newtype</code> declaration looks like this:</p>
<pre><code>newtype &lt;type-name&gt; = &lt;constructor&gt; &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can define a distinct type for <code>Html</code> like this:</p>
<pre><code class="language-hs">newtype Html = Html String
</code></pre>
<p>The first <code>Html</code>, to the left of the equals sign, lives in the <em>types</em>
name space, meaning that you will only see that name to the right of a
double-colon sign (<code>::</code>).</p>
<p>The second <code>Html</code> lives in the <em>expressions</em> (or terms/values) name space,
meaning that you will see it where you expect expressions (we'll touch where
exactly that can be in a moment).</p>
<p>The two names, <code>&lt;type-name&gt;</code> and <code>&lt;constructor&gt;</code>, do not have to be the
same, but they often are. And note that both have to start with a
capital letter.</p>
<p>The right-hand side of the newtype declaration describes the shape of a
value of that type. In our case, we expect a value of
type <code>Html</code> to have the constructor <code>Html</code> and then an expression of
type string, for example: <code>Html &quot;hello&quot;</code> or <code>Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)</code>.</p>
<p>You can think of the constructor as a function that takes the argument
and returns something of our new type:</p>
<pre><code class="language-hs">Html :: String -&gt; Html
</code></pre>
<p><strong>Note</strong>: We cannot use an expression of type <code>Html</code> the same way we'd
use a <code>String</code>. so <code>&quot;hello &quot; &lt;&gt; Html &quot;world&quot;</code> would fail at type
checking.</p>
<p>This is useful when we want <em>encapsulation</em>. We can define and use
existing representation and functions for our underlying type, but not
mix them with other, unrelated (to our domain) types. Similar as
meters and feet can both be numbers, but we don't want to accidentally
add feet to meters without any conversion.</p>
<hr />
<p>For now, let's create a couple of types for our use case.
We want two separate types to represent:</p>
<ol>
<li>A complete Html document</li>
<li>A type for html structures such as headings and paragraphs that can go inside the <body> tag</li>
</ol>
<p>We want them to be distinct because we don't want to mix them together.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">newtype Html = Html String

newtype Structure = Structure String
</code></pre>
</details>
<hr />
<h2 id="using-newtypes"><a class="header" href="#using-newtypes">Using <code>newtype</code>s</a></h2>
<p>In order to use the underlying type that the newtype wraps, we first
need to extract it out of the type. We do this using pattern matching.</p>
<p>Pattern matching can be used in two ways, in case expressions and in
function definitions.</p>
<ol>
<li>
<p>case expressions are kind of beefed up switch expressions and look like this:</p>
<pre><code>case &lt;expression&gt; of
  &lt;pattern&gt; -&gt; &lt;expression&gt;
  ...
  &lt;pattern&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>The <code>&lt;expression&gt;</code> is the thing we want to unpack, and the <code>pattern</code>
is its concrete shape. For example, if we wanted to extract the <code>String</code>
out of the type <code>Structure</code> we defined in the exercise above, we do:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString struct =
  case struct of
    Structure str -&gt; str
</code></pre>
<p>This way we can extract the <code>String</code> out of <code>Structure</code> and return
it.</p>
<blockquote>
<p>In later chapters we'll introduce <code>data</code> declarations (which are kind of
a struct + enum chimera), where we can define multiple constructors to
a type. Then the multiple patterns of a case expression will make more
sense.</p>
</blockquote>
</li>
<li>
<p>Alternatively, when declaring a function, we can also use pattern matching on the
arguments:</p>
<pre><code>func &lt;pattern&gt; = &lt;expression&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString (Structure str) = str
</code></pre>
<p>Using the types we created, we can change the HTML functions we've defined before,
namely <code>html_</code>, <code>body_</code>, <code>p_</code>, etc, to operate on these types instead of <code>String</code>s.</p>
<p>But first let's meet another operator that will make our code more concise.</p>
</li>
</ol>
<p>One very cool thing about <code>newtype</code> is that wrapping and extracting expressions doesn't actually
have a performance cost! The compiler knows to remove any wrapping and extraction
of the <code>newtype</code> constructor and use the underlying type.</p>
<p>The new type and the constructor we defined are only there to help us <em>distinguish</em> between
the type we created and the underlying type when <em>we write our code</em>, they are not
needed <em>when the code is running</em>.</p>
<p><code>newtype</code>s provide us with type safety with no performance penalty!</p>
<h2 id="chaining-functions"><a class="header" href="#chaining-functions">Chaining functions</a></h2>
<p>Another interesting and extremely common operator
(which is a regular library function in Haskell) is <code>.</code> (pronounced compose).
This operator was made to look like the composition operator
you may know from math (<code>â</code>).</p>
<p>Let's look at its type and implementation:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) f g x = f (g x)
</code></pre>
<p>Compose takes 3 arguments: two functions (named <code>f</code> and <code>g</code> here) and
a third argument named <code>x</code>. It then passes the argument <code>x</code> to the second
function <code>g</code>, and calls the first function <code>f</code> with the result of <code>g x</code>.</p>
<p>Note that <code>g</code> takes as input something of the type
<code>a</code> and returns something of the type <code>b</code>, and <code>f</code> takes
something of the type <code>b</code>, and returns something of the type <code>c</code>.</p>
<p>Another important thing to note is that types which start with
a <em>lowercase letter</em> are <strong>type variables</strong>.
Think of them as similar to regular variables. Just like
<code>content</code> could be any string, like <code>&quot;hello&quot;</code> or <code>&quot;world&quot;</code>, a type variable
can be any type: <code>Bool</code>, <code>String</code>, <code>String -&gt; String</code>, etc.
This abilitiy is called <em>parametric polymorphism</em> (other languages often call this generics).</p>
<p>The catch is that type variables must match in a signature, so if for
example we write a function with the type signature <code>a -&gt; a</code>, the
input type and the return type <strong>must</strong> match, but it could be
any type - we cannot know what it is. So the only way to implement a
function with that signature is:</p>
<pre><code class="language-hs">id :: a -&gt; a
id x = x
</code></pre>
<p><code>id</code>, short for the identity function, returns the exact value it received.
If we tried any other way, for example returning some made up value
like <code>&quot;hello&quot;</code>, or try to use <code>x</code> like a value of a type we know like
writing <code>x + x</code>, the type checker will complain.</p>
<p>Also, remember that <code>-&gt;</code> is right associative? This signature is equivalent to:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Doesn't it look like a function that takes two functions and returns a
third function that is the composition of the two?</p>
<p>We can now use this operator to change our HTML functions. Let's start
with one example: <code>p_</code>.</p>
<p>Before, we had:</p>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;
</code></pre>
<p>And now, we can write:</p>
<pre><code class="language-hs">p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;
</code></pre>
<p>The function <code>p_</code> will take an arbitrary <code>String</code> which is the content
of the paragraph we wish to create, will wrap it in <code>&lt;p&gt;</code> and <code>&lt;/p&gt;</code> tags,
and then wrap it in the <code>Structure</code> constructor to produce the
output type <code>Structure</code> (remember: newtype constructors can be used as functions!).</p>
<p>Let's take a deeper look at the types:</p>
<ul>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
<li><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></li>
<li><code>Structure . el &quot;p&quot; :: String -&gt; Structure</code></li>
</ul>
<p>Let's see why the expression <code>Structure . el &quot;p&quot;</code> type checks,
and why its type is <code>String -&gt; Structure</code>.</p>
<h3 id="type-checking-with-pen-and-paper"><a class="header" href="#type-checking-with-pen-and-paper">Type checking with pen and paper</a></h3>
<p>If we want to figure out if and how exactly an expression type-checks,
we can do that rather systematically. Let's look at an example
where we try and type-check this expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>First, we write down the type of the outer-most function. In
our case this is the operator <code>.</code> which has the type:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>After that, we can try to <strong>match</strong> the type of the arguments we
apply to this function with the type of the arguments from the type signature.</p>
<p>In this case, we try to apply two arguments to <code>.</code>:</p>
<ol>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
</ol>
<p>And luckily <code>.</code> expects two arguments with the types:</p>
<ol>
<li><code>b -&gt; c</code></li>
<li><code>a -&gt; b</code></li>
</ol>
<blockquote>
<p>Note: Applying a function with more arguments than it expects is a type error.</p>
</blockquote>
<p>Since the <code>.</code> operator takes at least the number of arguments we supply, we continue
to the next phase of type-checking: matching the types of the inputs with the types
of the expected inputs (from the type signature of the operator).</p>
<p>When we match two types, we are checking for <em>equivalence</em> between them. There are a few
possible scenarios here:</p>
<ol>
<li>When the two types are <strong>concrete</strong> (as opposed to type variables)
and <strong>simple</strong>, like <code>Int</code> and <code>Bool</code>,
we check if they are the same. If they are, they type check and we continue.
If they aren't, they don't type check and we throw an error.</li>
<li>When the two types we match are more <strong>complex</strong> (for example both are functions),
we try to match their inputs and outputs (in case of functions). If the inputs and outputs
match, then the two types match.</li>
<li>There is a special case when one of the types is a <strong>type variable</strong> -
in this case we treat the matching process like an equation and we write it down somewhere.
The next time we see this type variable, we <em>replace it with its match in the equation</em>.
Think about this like <em>assigning</em> a type <em>variable</em> with a <em>value</em>.</li>
</ol>
<p>In our case, we want to match (or check the equivalence of) these types:</p>
<ol>
<li><code>String -&gt; Structure</code> with <code>b -&gt; c</code></li>
<li><code>String -&gt; String</code> with <code>a -&gt; b</code></li>
</ol>
<p>Let's do this one by one, starting with (1) - matching <code>String -&gt; Structure</code> and <code>b -&gt; c</code>:</p>
<ol>
<li>Because the two types are complex, we check that they are both functions, and match their
inputs and outputs: <code>String</code> with <code>b</code>, and <code>Structure</code> with <code>c</code>.</li>
<li>Because <code>b</code> is a <em>type variable</em>, we mark down somewhere that <code>b</code> should
be equivalent to <code>String</code>.
We write <code>b ~ String</code> (we use <code>~</code> to denote equivalence).</li>
<li>We match <code>Structure</code> and <code>c</code>, same as before, we write down that <code>c ~ Structure</code>.</li>
</ol>
<p>No problem so far, let's try matching <code>String -&gt; String</code> with <code>a -&gt; b</code>:</p>
<ol>
<li>The two types are complex, we see that both are functions so we match
their inputs and outputs.</li>
<li>Matching <code>String</code> with <code>a</code> - we write down that <code>a ~ String</code>.</li>
<li>Matching <code>String</code> with <code>b</code> - we remember that we have already written
about <code>b</code> - looking back we see that we already noted that <code>b ~ String</code>.
We need to replace <code>b</code> with the type that we wrote down before and
check it against this type, so we match <code>String</code> with <code>String</code> 
which, fortunately, type-check because they are the same.</li>
</ol>
<p>So far so good. We've type-checked the expression and discovered the following things
about the type variables in it:</p>
<ol>
<li><code>a ~ String</code></li>
<li><code>b ~ String</code></li>
<li><code>c ~ Structure</code></li>
</ol>
<p>Now, when asking what is the type of the expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>We say that it is the type of <code>.</code> after <em>replacing</em> the type variables using the equations we found
and <em>removing</em> the inputs we applied to it, so we started with:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Then we replaced the type variables:</p>
<pre><code class="language-hs">(.) :: (String -&gt; Structure) -&gt; (String -&gt; String) -&gt; (String -&gt; Structure)
</code></pre>
<p>And removed the two arguments when we apply the function:</p>
<pre><code class="language-hs">Structure . el &quot;p&quot; :: String -&gt; Structure
</code></pre>
<p>And we got the type of the expression!</p>
<p>Fortunately, Haskell is able to do this process for us. But when Haskell complains
that our types fail to type-check and we don't understand exactly why, going through this process
can help us understand where the types do not match, and then we can figure out how to solve it.</p>
<blockquote>
<p><strong>Note</strong>: If we use a <em>parametrically polymorphic</em> function more than once,
or use different functions that have similar type variable names,
the type variables don't have to match in all instances simply because they share a name.
Each instance has its own unique set of type variables. For example:</p>
<pre><code class="language-hs">id :: a -&gt; a
ord :: Char -&gt; Int
chr :: Int -&gt; Char

incrementChar :: Char -&gt; Char
incrementChar c = chr (ord (id c) + id 1)
</code></pre>
<p>In the snippet above, we use <code>id</code> twice (for no good reason other than for demonstration purposes).
The first <code>id</code> takes a <code>Char</code> as an argument, and its <code>a</code> is equivalent to <code>Char</code>.
The second <code>id</code> takes an <code>Int</code> as an argument, and its <em>distinct</em> <code>a</code> is equivalent to <code>Int</code>.</p>
<p>This unfortunately only applies to functions defined at the top-level. If we'd define a local function
to be passed as an argument to <code>incrementChar</code> with the same type signature as <code>id</code>,
the types must match in all uses. So this code:</p>
<pre><code class="language-hs">incrementChar :: (a -&gt; a) -&gt; Char -&gt; Char
incrementChar func c = chr (ord (func c) + func 1)
</code></pre>
<p>Will not type check. Try it!</p>
</blockquote>
<h2 id="appending-structure"><a class="header" href="#appending-structure">Appending Structure</a></h2>
<p>Before when we wanted to create richer HTML content and appended
nodes to one another, we used the append (<code>&lt;&gt;</code>) operator.
Since we are now not using <code>String</code> anymore, we need another way
to do it.</p>
<p>While it is possible to overload <code>&lt;&gt;</code> using a feature in
Haskell called type classes, we will instead create a new function
and call it <code>append_</code>, and cover type classes later.</p>
<p><code>append_</code> should take two <code>Structure</code>s, and return a third <code>Structure</code>,
appending the inner <code>String</code> in the first <code>Structure</code> to the second and wrapping the result back in <code>Structure</code>.</p>
<hr />
<p>Try implementing <code>append_</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ (Structure a) (Structure b) =
  Structure (a &lt;&gt; b)
</code></pre>
</details>
<hr />
<h2 id="converting-back-an-html-to-string"><a class="header" href="#converting-back-an-html-to-string">Converting back an <code>Html</code> to <code>String</code></a></h2>
<p>After constructing a valid <code>Html</code> value, we want to be able to
print it to the output so we can display it in our browser.
For that, we need to write a function that takes an <code>Html</code> and converts it to a <code>String</code>, which we can then pass to <code>putStrLn</code>.</p>
<hr />
<p>Implement the <code>render</code> function.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p>Let's look at one more way to give new names to types.</p>
<p>A <code>type</code> definition looks really similar to a <code>newtype</code> definition - the only
difference is that we reference the type name directly without a constructor:</p>
<pre><code>type &lt;type-name&gt; = &lt;existing-type&gt;
</code></pre>
<p>For example in our case we can write:</p>
<pre><code class="language-hs">type Title = String
</code></pre>
<p><code>type</code>, in contrast with <code>newtype</code>, is just a type name alias.
When we declare that <code>Title</code> is a <em>type alias</em> of <code>String</code>
We mean that <code>Title</code> and <code>String</code> are interchangeable,
and we can use one or the other whenever we want:</p>
<pre><code class="language-hs">&quot;hello&quot; :: Title

&quot;hello&quot; :: String
</code></pre>
<p>Both are valid in this case.</p>
<p>We can sometimes use <code>type</code>s to give a bit more clarity to our code,
but they are much less useful than <code>newtype</code>s which allow us to
<em>distinguish</em> between two types that have the same type representation.</p>
<h2 id="the-rest-of-the-owl"><a class="header" href="#the-rest-of-the-owl">The rest of the owl</a></h2>
<hr />
<p>Try changing the code we wrote in previous chapters to use the new types we created.</p>
<blockquote>
<p><strong>Tips</strong></p>
<p>We can combine <code>makeHtml</code> and <code>html_</code>, and remove <code>body_</code> <code>head_</code> and <code>title_</code>
by calling <code>el</code> directly in <code>html_</code>, which can now have the type
<code>Title -&gt; Structure -&gt; Html</code>.
This will make our HTML EDSL less flexible but more compact.</p>
<p>Alternatively, we could create <code>newtype</code>s for <code>HtmlHead</code> and <code>HtmlBody</code> and
pass those to <code>html_</code>, and we might do that at later chapters, but I've chose
to keep the API a bit simple for now, we can always refactor later!</p>
</blockquote>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="are-we-safe-yet"><a class="header" href="#are-we-safe-yet">Are we safe yet?</a></h2>
<p>We have made some progress - now we can't write <code>&quot;Hello&quot;</code>
where we'd expect either a paragraph or a heading, but we can still
write <code>Structure &quot;hello&quot;</code> and get something that isn't a
paragraph or a heading. So while we made it harder for the user
to make mistakes by accident, we haven't really been able to <strong>enforce
the invariants</strong> we wanted to enforce in our library.</p>
<p>Next we'll see how we can make expressions such as <code>Structure &quot;hello&quot;</code> illegal
as well using <em>modules</em> and <em>smart constructors</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preventing-incorrect-use-with-modules"><a class="header" href="#preventing-incorrect-use-with-modules">Preventing incorrect use with modules</a></h1>
<p>In this section we will move the HTML generation library to its own module.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Each Haskell source file is a module. The module name should have the
same name as the source file and should start with a capital
letter. Sub-directories should also be part of the name and we use <code>.</code>
to denote a sub-directory. We'll see that in the next section.</p>
<p>The only exception to the rule are entry points to the program -
modules with the name 'Main' that define <code>main</code> in them. Their source
file names could have any name they want.</p>
<p>A module declaration looks like this:</p>
<pre><code class="language-hs">module &lt;module-name&gt;
  ( &lt;export-list&gt;
  )
  where
</code></pre>
<p>The export list can be omitted if you want to export everything
defined in the module, but we don't. We will list exactly the
functions and type we want to export. This will give us control
on how people can use our tiny library.</p>
<p>We will create a new source file named <code>Html.hs</code> and add the following
module declaration code at the top of the file:</p>
<pre><code class="language-hs">module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where
</code></pre>
<p>Note that we do not export:</p>
<ol>
<li>
<p>The constructors for our new types, only the types themselves.
If we wanted to export the constructors as well we would've written
<code>Html(Html)</code> or <code>Html(..)</code>. This way the user cannot create their own
<code>Structure</code> simply by writing <code>Structure &quot;Hello&quot;</code>.</p>
</li>
<li>
<p>Internal functions used by the library, such as <code>el</code> and <code>getStructureString</code>.</p>
</li>
</ol>
<p>And we will also move the HTML related functions from our <code>hello.hs</code> file
to this new <code>Html.hs</code> file:</p>
<pre><code class="language-hs">newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<p>Now, anyone importing our module (using the <code>import</code> statement which
can be used below module declarations but above any other
declaration), will only be able to import what we export.</p>
<p>Add the following code at the top of the <code>hello.hs</code> file:</p>
<pre><code class="language-hs">import Html
</code></pre>
<p>The <code>hello.hs</code> file should now look like this:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<p>And the <code>Html.hs</code> file should look like this:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escaping-characters"><a class="header" href="#escaping-characters">Escaping characters</a></h1>
<p>Now that <code>Html</code> has its own source file and module, and creating
HTML code can be done only via the functions we exported,
we can also handle user input that may contain characters
that may conflict with our meta language, HTML,
such as <code>&lt;</code> and <code>&gt;</code> which are used for creating HTML tags.</p>
<p>We can convert these characters into different strings that HTML can handle.</p>
<p>See <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html">Stack overflow question</a>
for a list of characters we need to escape.</p>
<p>Let's create a new function called <code>escape</code>:</p>
<pre><code class="language-hs">escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<p>In <code>escape</code> we see a few new things:</p>
<ol>
<li>
<p>Let expressions: we can define local names using this syntax:</p>
<pre><code class="language-hs">let
  &lt;name&gt; = &lt;expression&gt;
in
  &lt;expression&gt;
</code></pre>
<p>This will make <code>&lt;name&gt;</code> available as a variable <code>in</code> the second <code>&lt;expression&gt;</code>.</p>
</li>
<li>
<p>Pattern matching with multiple patterns: we match on different
characters and convert them to a string. Note that <code>_</code> is a &quot;catch
all&quot; pattern that will always succeed.</p>
</li>
<li>
<p>Two new functions: <code>map</code> and <code>concat</code>, we'll talk about these more in depth</p>
</li>
<li>
<p>That the syntax highlighting broke a bit for this snippet for some reason. Don't worry about it.</p>
</li>
</ol>
<h2 id="linked-lists-briefly"><a class="header" href="#linked-lists-briefly">Linked lists briefly</a></h2>
<p>Linked lists are a very common data structure in Haskell, so common that
they have their own special syntax:</p>
<ol>
<li>The type for lists are denoted with brackets and inside them is the type of the element. For example:
<ul>
<li><code>[Int]</code> - a list of integers</li>
<li><code>[Char]</code> - a list of characters</li>
<li><code>[String]</code> - a list of strings</li>
<li><code>[[String]]</code> - a list of a list of strings</li>
<li><code>[a]</code> - a list of any single type (all elements must be of the same type)</li>
</ul>
</li>
<li>A value representing a empty list is written like this: <code>[]</code></li>
<li>Prepending an element to a list is done with the operator <code>:</code> (pronounced cons) which is right-associative (like <code>-&gt;</code>).
For example: <code>1 : []</code>, or <code>1 : 2 : 3 : []</code>.</li>
<li>The above lists can also be written like this: <code>[1]</code> and <code>[1, 2, 3]</code>.</li>
</ol>
<p>Also, Strings are linked lists of characters - String is defined as:
<code>type String = [Char]</code>, so we can use them the same way we use lists.</p>
<blockquote>
<p>Do note, however, that linked lists, despite their convenience, are often
not the right tool for the job. They are not particularity space efficient
and are slow for appending, random access and more. That also makes <code>String</code>
a lot less efficient than it could be. And I generally recommend using a
different string type, <code>Text</code>, instead, which is available in an external package.
We will talk about lists, <code>Text</code>, and other data structures in the future!</p>
</blockquote>
<p>We can implement our own operations on lists by using pattern matching and recursion.
And we'll touch on this subject later when talking about ADTs.</p>
<p>For now, we will use the various functions found in the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html">Data.List</a> module.
Specifically, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:map">map</a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List.html#v:concat">concat</a>.</p>
<h3 id="map"><a class="header" href="#map"><code>map</code></a></h3>
<p>Using <code>map</code> we can apply a function to each of the elements in a list. Its type signature is:</p>
<pre><code class="language-hs">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">map not [False, True, False] == [True, False, True]
</code></pre>
<p>Or as can be seen in our <code>escape</code> function, this can help us escape each character:</p>
<pre><code class="language-hs">map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]
</code></pre>
<p>However, note that the <code>escapeChar</code> has the type <code>Char -&gt; String</code>,
so the result type of <code>map escapeChar ['&lt;','h','1','&gt;']</code> is <code>[String]</code>,
and what we really want is a <code>String</code> and not <code>[String]</code>.</p>
<p>This is where <code>concat</code> enters the picture to help us flatten the list.</p>
<h3 id="concat"><a class="header" href="#concat"><code>concat</code></a></h3>
<p><code>concat</code> has the type:</p>
<pre><code class="language-hs">concat :: [[a]] -&gt; [a]
</code></pre>
<p>It flattens a list of list of something into a list of something.
In our case it will flatten <code>[String]</code> into <code>String</code>, remember that this works
because <code>String</code> is a <strong>type alias</strong> for <code>[Char]</code>, so we actually have
<code>[[Char]] -&gt; [Char]</code>.</p>
<h2 id="ghci"><a class="header" href="#ghci">GHCi</a></h2>
<p>One way we can quickly see our code in action is using the interactive development environment <strong>GHCi</strong>.
Running <code>ghci</code> will open an interactive prompt where Haskell expressions can be written and
evaluated. This is called a &quot;Read-Evaluate-Print Loop&quot; (for short - REPL).</p>
<p>For example:</p>
<pre><code>ghci&gt; 1 + 1
2
ghci&gt; putStrLn &quot;Hello, world!&quot;
Hello, world!
</code></pre>
<p>We can define new names:</p>
<pre><code>ghci&gt; double x = x + x
ghci&gt; double 2
4
</code></pre>
<p>We can write multi-line code by surrounding it with <code>:{</code> and <code>:}</code>:</p>
<pre><code>ghci&gt; :{
| escape :: String -&gt; String
| escape =
|   let
|     escapeChar c =
|       case c of
|         '&lt;' -&gt; &quot;&amp;lt;&quot;
|         '&gt;' -&gt; &quot;&amp;gt;&quot;
|         '&amp;' -&gt; &quot;&amp;amp;&quot;
|         '&quot;' -&gt; &quot;&amp;quot;&quot;
|         '\'' -&gt; &quot;&amp;#39;&quot;
|         _ -&gt; [c]
|   in
|     concat . map escapeChar
| :}

ghci&gt; escape &quot;&lt;html&gt;&quot;
&quot;&amp;lt;html&amp;gt;&quot;

</code></pre>
<p>We can import Haskell source files using the <code>:load</code> command (<code>:l</code> for short):</p>
<pre><code>ghci&gt; :load Html.hs
[1 of 1] Compiling Html    ( Html.hs, interpreted )
Ok, one module loaded.
ghci&gt; render (html_ &quot;&lt;title&gt;&quot; (p_ &quot;&lt;body&gt;&quot;))
&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&amp;lt;title&amp;gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>As well as import library modules:</p>
<pre><code>ghci&gt; import Data.Bits
ghci&gt; shiftL 32 1
64
ghci&gt; clearBit 33 0
32
</code></pre>
<p>We can even ask what the type of an expression is using the <code>:type</code> command
(<code>:t</code> for short):</p>
<pre><code>Î»&gt; :type escape
escape :: String -&gt; String
</code></pre>
<p>To exit <code>ghci</code>, use the <code>:quit</code> command (or <code>:q</code> for short)</p>
<pre><code>ghci&gt; :quit
Leaving GHCi.
</code></pre>
<p>GHCi is a very useful tool for quick experiments and exploration.
And it can be used to quickly test what our code does.</p>
<p>We've seen a couple of examples of that above - passing the string <code>&quot;&lt;html&gt;&quot;</code> to our
<code>escape</code> function returns the string <code>&quot;&amp;lt;html&amp;gt;&quot;</code>, which can be rendered by
a browser as <code>&lt;html&gt;</code> instead of the browser considering it as an HTML tag.</p>
<p>If you are having a hard time figuring out what a particular function does, consider
testing it in GHCi - pass it different inputs, and see if it matches your expectations.
Concrete examples of running code can aid a lot in understanding it!</p>
<blockquote>
<p>If you'd like to learn more about GHCi, you can find a more thorough introduction in the
<a href="https://downloads.haskell.org/%7Eghc/9.0.1/docs/html/users_guide/ghci.html">GHC user guide</a>.</p>
</blockquote>
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<hr />
<p>The user of our library can currently only supply strings in a few places:</p>
<ol>
<li>Page title</li>
<li>Paragraphs</li>
<li>Headings</li>
</ol>
<p>We can apply our escape function at these places before doing anything else with it.
That way all HTML constructions are safe.</p>
<p>Try adding the escaping function in those places.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape
</code></pre>
</details>
<hr />
<details>
  <summary><b>Our revised Html.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<p>Try constructing an invalid HTML in <code>hello.hs</code> to see if this works or not!</p>
<p>Now we can use our tiny HTML library safely. But what if the user
wants to use our library with a valid use case we didn't think about, for
example adding unordered lists? We are completely blocking them from
extending our library. We'll talk about this next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exposing-internal-functionality-internal-modules"><a class="header" href="#exposing-internal-functionality-internal-modules">Exposing internal functionality (Internal modules)</a></h1>
<p>We have now built a very small but convenient and safe way to write
HTML code in Haskell. This is something that we could (potentially)
publish as a <em>library</em> and share with the world by uploading it
to a package repository such as <a href="https://hackage.haskell.org/">Hackage</a>.
Users who are interested in our library could use a package manager
to include our library in their project and build their own HTML pages
with it.</p>
<p>It is important to note that users are building their project against
the API that we expose to them, and the package manager don't generally
provide access to the source code, so they can't, for example,
modify the <code>Html</code> module (that we expose) in their project directly
without jumping through some hoops.</p>
<p>Because we wanted our <code>Html</code> EDSL to be safe, we <strong>hid the internal
implementation from the user</strong>, and the only way to interact with the
library is via the API we provide.</p>
<p>This provides the safety we wanted to provide, but in this case it also
<em>blocks</em> the user from extending our library <em>in their own project</em> with
things we haven't implemented yet, such as lists or code blocks.</p>
<p>When a user runs into trouble with using a library (such as missing features)
the best course of action usually is to open an issue in the repository or
submit a pull request, but sometimes the user needs things to work <em>now</em>.</p>
<p>We admit that we are not perfect and can't think of all use cases for our
library. Sometimes the restrictions we add are too great and may limit
the usage of advanced users that know how things work under the hood and
need certain functionality in order to use our library.</p>
<h3 id="internal-modules"><a class="header" href="#internal-modules">Internal modules</a></h3>
<p>For that we can expose internal modules to provide some flexibility for
advanced users. Internal modules are not a language concept but
rather a (fairly common) design pattern (or idiom) in Haskell.</p>
<p>Internal modules are simply modules named <code>&lt;something&gt;.Internal</code>,
which export all of the functionality and implementation details in that module.</p>
<p>Instead of writing the implementation in (for example) the <code>Html</code> module,
we write it in the <code>Html.Internal</code> module, which will export everything.
Then we will import that module in the <code>Html</code> module, and write an explicit export list
to only export the API we'd like to export (as before).</p>
<p><code>Internal</code> modules are considered unstable and risky to use by convention.
If you end up using one yourself when using an external Haskell library,
make sure to open a ticket in the library's repository after the storm has passed!</p>
<h3 id="lets-make-the-changes"><a class="header" href="#lets-make-the-changes">Lets make the changes</a></h3>
<p>We will create a new directory named <code>Html</code> and inside it a new file
named <code>Internal.hs</code>. The name of this module should be <code>Html.Internal</code>.</p>
<p>This module will contain all of the code we previously had in the <code>Html</code>
module, but <strong>we will change the module declaration in <code>Html.Internal</code>
and <em>omit</em> the export list</strong>:</p>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

...
</code></pre>
<p>And now in <code>Html.hs</code>, we will remove the code that we moved to <code>Html/Internal.hs</code>
and in its stead we'll import the internal module:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<p>Now, users of our library can still import <code>Html</code> and safely use our library,
but if they run into trouble and have a dire need to implement unordered lists
to work with our library, they could always work with <code>Html.Internal</code> instead.</p>
<details>
  <summary><b>Our revised Html.hs and Html/Internal.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>For our particular project, <code>Internal</code> modules aren't necessary.
Because our project and the source code for the HTML EDSL are
part of the same project, and we have access the the <code>Html</code>
module directly, we can always go and edit it if we want
(and we are going to do that throughout the book).</p>
<p>However, if we were planning to release our HTML EDSL as a <em>library</em>
for other developers to use, it would be very nice of us
to also expose the internal implementation as an <code>Internal</code>
module. Just so we can save some trouble for potential users!</p>
<p>We will see how to create a package from our source code in a later chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>We need a few more features for our HTML library to be useful for
our blog software. Add the following features to our <code>Html.Internal</code> module
and expose them from <code>Html</code>.</p>
<h2 id="1-unordered-lists"><a class="header" href="#1-unordered-lists">1. Unordered lists</a></h2>
<p>These lists have the form:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>We want in our library a new function:</p>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
</code></pre>
<p>So that users can write this:</p>
<pre><code class="language-hs">ul_
  [ p_ &quot;item 1&quot;
  , p_ &quot;item 2&quot;
  , p_ &quot;item 3&quot;
  ]
</code></pre>
<p>and get this:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="2-ordered-lists"><a class="header" href="#2-ordered-lists">2. Ordered lists</a></h2>
<p>Very similar to unordered lists, but instead of <code>&lt;ul&gt;</code> we use <code>&lt;ol&gt;</code></p>
<h2 id="3-code-blocks"><a class="header" href="#3-code-blocks">3. Code blocks</a></h2>
<p>Very similar to <code>&lt;p&gt;</code>, but use the <code>&lt;pre&gt;</code> tag. Call this function <code>code_</code>.</p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<details>
  <summary>Unordered lists</summary>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
</details>
<details>
  <summary>Ordered lists</summary>
<pre><code class="language-hs">ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
<p>Note: the two functions above could be unified.</p>
</details>
<details>
  <summary>Code blocks</summary>
<pre><code class="language-hs">code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>In this chapter we built a very minimal HTML EDSL.
We will later use this library to convert our custom markup formatted text to HTML.</p>
<p>We've also learned about:</p>
<ul>
<li>Defining and using functions</li>
<li>Types and type signatures</li>
<li>Embedded domain specific languages</li>
<li>Chaining functions using the <code>.</code> operator</li>
<li>Preventing incorrect use with <code>newtype</code>s</li>
<li>Defining modules and the <code>Internal</code> module pattern</li>
<li>Encapsulation using <code>newtype</code>s and modules</li>
</ul>
<p>Here's our complete program up to this point:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , h1_
  , p_
  , ul_
  , ol_
  , code_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<blockquote>
<p>You can also <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/76c4f4b31c7883c5c0b9f09c7b1a391640a31538">browse the code as a tree</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-markup-language"><a class="header" href="#custom-markup-language">Custom markup language</a></h1>
<p>In this chapter we will define our own simple markup language
and parse documents written in this language into Haskell data structures.</p>
<p>Our markup language will contain the following features:</p>
<ul>
<li>Headings: prefix by a number of <code>*</code> characters</li>
<li>Paragraphs: a group of lines without empty lines in between</li>
<li>Unordered lists: a group of lines each prefixed with <code>- </code></li>
<li>Ordered lists: a group of lines each prefixed with <code># </code></li>
<li>Code blocks: a group of lines each prefixed with <code>&gt; </code></li>
</ul>
<p>Here's a sample document which we will use as an example:</p>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; â ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
<p>Which we will, eventually, want to convert into this (modulo formatting) HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Compiling programs with ghc&lt;/h1&gt;

&lt;p&gt;Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.
&lt;/p&gt;

&lt;p&gt;Create a new Haskell source file named hello.hs, and write
the following code in it:
&lt;/p&gt;

&lt;pre&gt;main = putStrLn &quot;Hello, Haskell!&quot;
&lt;/pre&gt;

&lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt;

&lt;pre&gt;
â ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
&lt;/pre&gt;

&lt;p&gt;GHC created the following files:
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt;
  &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt;
  &lt;li&gt;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GHC will produce an executable when the source file satisfies both conditions:
&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Defines the main function in the source file&lt;/li&gt;
  &lt;li&gt;Defines the module name to be Main, or does not have a module declaration&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, it will only produce the .o and .hi files.
&lt;/p&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-the-markup-language-as-a-haskell-data-type"><a class="header" href="#representing-the-markup-language-as-a-haskell-data-type">Representing the markup language as a Haskell data type</a></h1>
<p>One of the clear differentiators between Haskell and other ML-family of languages
from most mainstream languages is the ability to represent data precisely and succinctly.</p>
<p>So how do we represent our markup language using Haskell?</p>
<p>Previously, in our HTML builder library, we used <code>newtype</code>s to differentiate
between HTML documents, structures and titles, but we didn't really need to
differentiate between different kinds of structures such as paragraphs and headings,
not without parsing the data at least.</p>
<p>In this case, we have a list of structures, and each structure could be
one of a few specific options (a paragraph, a heading, a list, etc),
and we want to be able to know which structure is which so we can easily
convert it into the equivalent HTML representation.</p>
<p>For that, we have <code>data</code> definitions. <code>data</code> gives us the ability to
create custom types by grouping multiple types together and having
alternative structures. Think of them as combination of both structs and enums.</p>
<p><code>data</code> declarations look like this:</p>
<pre><code class="language-hs">data &lt;Type-name&gt; &lt;type-args&gt;
  = &lt;Data-constructor1&gt; &lt;types&gt;
  | &lt;Data-constructor2&gt; &lt;types&gt;
  | ...
</code></pre>
<p>It looks really similar to <code>newtype</code>, but there are two important
differences:</p>
<ol>
<li>In the <code>&lt;types&gt;</code> part we can write many types (Like <code>Int</code>, <code>String</code>, or <code>Bool</code>).
For <code>newtype</code>s we can only write one.</li>
<li>We can have alternative structures using <code>|</code>, <code>newtype</code>s have no
alternatives.</li>
</ol>
<p>This is because <code>newtype</code> is used to provide a type safe <strong>alias</strong>, and <code>data</code>
is used to build a new <strong>composite</strong> type that can potentially have <em>alternatives</em>.</p>
<p>Let's see a few of examples of data types:</p>
<ol>
<li>
<p>Bool</p>
<pre><code class="language-hs">data Bool
  = True
  | False
</code></pre>
<p>We created a new data type named <code>Bool</code> with the possible values <code>True</code> or <code>False</code>.
In this case we only have <em>constructor</em> alternatives and none of the constructors
carry additional values. This is similar to enums in other languages.</p>
</li>
<li>
<p>Person</p>
<pre><code class="language-hs">data Person
  = Person String Int -- where the first is the name and the second is
                      -- the age
</code></pre>
<p>We created a new data type named <code>Person</code>. Values of the type <code>Person</code>
look like this:</p>
<pre><code>Person &lt;some-string&gt; &lt;some-int&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>In this case we create a <em>composite</em> of multiple types, without alternatives.
This is similar to structs in other language, but structs give each field
a name, and here we distinguish them by position.</p>
<p>Alternatively, Haskell has <em>syntactic sugar</em> for naming fields called <strong>records</strong>.
The above definition can also be written like this:</p>
<pre><code class="language-hs">data Person
  = Person
    { name :: String
    , age :: Int
    }
</code></pre>
<p>Values of this type can be written exactly as before,</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>Or with this syntax:</p>
<pre><code class="language-hs">Person { name = &quot;Gil&quot;, age = 32 }
</code></pre>
<p>Haskell will also generate functions that can be used to extract the fields from the composite type:</p>
<pre><code class="language-hs">name :: Person -&gt; String
age :: Person -&gt; Int
</code></pre>
<p>Which can be used like this:</p>
<pre><code class="language-hs">ghci&gt; age (Person { name = &quot;Gil&quot;, age = 32 })
32
</code></pre>
<p>We even have special syntax for updating specific fields in a record. Of course,
we do not update records in place - we generate a new value instead.</p>
<pre><code class="language-hs">ghci&gt; gil = Person { name = &quot;Gil&quot;, age = 32 }
ghci&gt; age (gil { age = 33 })
33
ghci&gt; age gil
32
</code></pre>
<p>Unfortunately, having specialized functions for each field also means that if we
defined a different data type with the field <code>age</code>, the functions which GHC needs
to generate will clash.</p>
<p>The easiest way to solve this is to give fields unique names, for example
by adding a prefix:</p>
<pre><code class="language-hs">data Person
  = Person
    { pName :: String
    , pAge :: Int
    }
</code></pre>
<p>Another way is by using extensions to the Haskell language, which we will cover
in later chapters.</p>
</li>
<li>
<p>Tuple</p>
<pre><code class="language-hs">data Tuple a b
  = Tuple a b
</code></pre>
<p>This is pretty similar to <code>Person</code>, but we can plug any type we want
for this definition. For example:</p>
<pre><code class="language-hs">Tuple &quot;Clicked&quot; True :: Tuple String Bool

Tuple 'a' 'z' :: Tuple Char Char
</code></pre>
<p>This type has special syntax in Haskell:</p>
<pre><code class="language-hs">(&quot;Clicked&quot;, True) :: (String, Bool)

('a', 'z') :: (Char, Char)
</code></pre>
<p>This <code>Tuple</code> definition is polymorphic, we define the structure but are able to
plug different types into the structure to get concrete types. You can think of <code>Tuple</code>
as a <em>template</em> for a data type waiting to be filled, or as a <strong>function</strong> waiting
for types as input in order to return a data type. We can even take a look at the &quot;type&quot;
signature of <code>Tuple</code> in <code>ghci</code> using the <code>:kind</code> command.</p>
<pre><code class="language-hs">ghci&gt; data Tuple a b = Tuple a b
ghci&gt; :kind Tuple
Tuple :: * -&gt; * -&gt; *
</code></pre>
<blockquote>
<h4 id="quick-detour-kinds"><a class="header" href="#quick-detour-kinds">Quick detour: Kinds</a></h4>
<p>The <code>:kind</code> command is called as such because the &quot;type&quot; of a type is called a <strong>kind</strong>.
Kinds can be one of two things, either a <code>*</code> which means a saturated (or concrete) type,
such as <code>Int</code> or <code>Person</code>, or an <code>-&gt;</code> of two kinds, which is, as you might have guessed,
a type function, taking kind and returning a kind.</p>
<p>Note that only types that have the kind <code>*</code> can have values. So for example while <code>Tuple Int</code>
is a valid Haskell concept that has the <em>kind</em> <code>* -&gt; *</code>, and we can write code that will
work &quot;generically&quot; for all types that have a certain kind (e.g. <code>* -&gt; *</code>), we cannot
construct a value that will have the kind <code>* -&gt; *</code>. All values have types, and all
types that have values have the kind <code>*</code>.</p>
<p>We will talk more about kinds later, for now let's focus on types!</p>
</blockquote>
</li>
<li>
<p>Either</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Similar to Tuple but instead of having only one constructor, we have
two. This means that we can choose which side we want. Here are a
couple of values of type <code>Either String Int</code>:</p>
<pre><code class="language-hs">Left &quot;Hello&quot;

Right 17
</code></pre>
<p>This type is useful for modeling errors. Either we succeeded and got
what we wanted (The <code>Right</code> constructor with the value), or we didn't
and got an error instead (The <code>Left</code> constructor with a string or a
custom error type).</p>
</li>
</ol>
<p>In our program we use <code>data</code> types to model the different kinds of content types
in our markup language. We tag each structure using the data constructor
and provide the rest of the information (the paragraph text, the list items, etc)
in the <code>&lt;types&gt;</code> section of the data declaration for each constructor:</p>
<pre><code class="language-hs">type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
<p>Note: <code>Natural</code> is defined in the <code>base</code> package but not exported from <code>Prelude</code>.
Find out which module to import <code>Natural</code> by using <a href="https://hoogle.haskell.org">Hoogle</a>.</p>
<hr />
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<p>Represent the following markup documents as values of <code>Document</code>:</p>
<ol>
<li>
<pre><code class="language-org">Hello, world!
</code></pre>
</li>
<li>
<pre><code class="language-org">* Welcome

To this tutorial about Haskell.
</code></pre>
</li>
<li>
<pre><code class="language-org">Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
</code></pre>
</li>
<li>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; â ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
</li>
</ol>
<p>Solutions:</p>
<details>
  <summary>Solution 1</summary>
<pre><code class="language-hs">example1 :: Document
example1 =
  [ Paragraph &quot;Hello, world!&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 2</summary>
<pre><code class="language-hs">example2 :: Document
example2 =
  [ Heading 1 &quot;Welcome&quot;
  , Paragraph &quot;To this tutorial about Haskell.&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 3</summary>
<pre><code class="language-hs">example3 :: Document
example3 =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
</details>
<details>
  <summary>Solution 4</summary>
<pre><code class="language-hs">example4 :: Document
example4 =
  [ Heading 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;â ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main, or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<p>Add a new module named <code>Markup</code> and add the data type definition to it.
Note that in this case we <em>do</em> want to export the constructors of <code>Structure</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  )
where

import Numeric.Natural

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
</details>
<hr />
<h2 id="translating-directly"><a class="header" href="#translating-directly">Translating directly?</a></h2>
<p>You might ask &quot;Why do we even need to represent the markup as a type?
Why don't we convert it into HTML as soon as we parse it
instead?&quot;. That's a good question and a valid strategy. The reason we
first represent it as a Haskell type is for flexibility and modularity.</p>
<p>If the parsing code is coupled with HTML generation, we lose the
ability to pre-process the markup document. For example we might want
to take only a small part of the document (for summary) and present
it, or create a table of content from headings. Or maybe we'd like to
add other targets and not just HTML - maybe markdown format or a GUI reader?</p>
<p>Parsing to an &quot;abstract data type&quot; (ADT) representation (one that does
not contain the details of the language, that for example that we use '#' for
ordered lists) gives us the freedom to do so much more than just
conversion to HTML that it's usually worth it in my opinion unless you
really need to optimize the process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-01-recursion"><a class="header" href="#parsing-markup-part-01-recursion">Parsing markup part 01 (Recursion)</a></h1>
<p>Let's have a look at how to parse a multi-lined string of markup text
written by a user and convert it to the <code>Document</code> type we defined
in the previous chapter.</p>
<p>Our strategy is to take the string of markup text, and:</p>
<ol>
<li>Split it to a list where each element represents a separate line, and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>So the first thing we want to do is to process the string line by line.
We can do that by converting the string to a list of string.
Fortunately the Haskell
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>Prelude</code></a>
module from the Haskell standard library
<a href="https://hackage.haskell.org/package/base"><code>base</code></a> exposes the function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>
that does exactly what we want. The <code>Prelude</code> module is exposed in every
Haskell file by default so we don't need to import it.</p>
<p>For the line processing part, let's start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<p>A common solution in imperative programs would be to iterate over the lines
using some <em>loop</em> construct and accumulate lines that should be grouped together
into some intermediate mutable variable. When we reach an empty line, we insert
the content of that variable into another mutable variable that accumulates the
results.</p>
<p>Our approach in Haskell isn't so different, except that we do not use loops
or mutable variables. Instead, we use <strong>recursion</strong>.</p>
<h2 id="recursion-and-accumulating-information"><a class="header" href="#recursion-and-accumulating-information">Recursion and accumulating information</a></h2>
<p>Instead of loops, in Haskell we use recursion to model iteration.</p>
<p>Consider the following contrived example: let's say that
we want to write an algorithm for adding two natural numbers together,
and we don't have a standard operation to do that (+), but we do
have two operations we could use on each number: <code>increment</code>
and <code>decrement</code>.</p>
<p>A solution we could come up with is to slowly &quot;pass&quot; one number
to the other number iteratively, by incrementing one, and decrementing the other.
And we do that until the number we decrement reaches 0.</p>
<p>For example for <code>3</code> and <code>2</code>:</p>
<ul>
<li>We start with <code>3</code> and <code>2</code>, and we increment <code>3</code> and decrement <code>2</code></li>
<li>On the next step we now have <code>4</code> and <code>1</code>, we increment <code>4</code> and decrement <code>1</code></li>
<li>On the next step we now have <code>5</code> and <code>0</code>, since the second number is <code>0</code> we declare <code>5</code> as the result.</li>
</ul>
<p>This can be written imperatively using a loop:</p>
<pre><code class="language-js">function add(n, m) {
  while (m /= 0) {
    n = increment(n);
    m = decrement(m);
  }
  return n;
}
</code></pre>
<p>We can write the same algorithm in Haskell without mutation using recursion:</p>
<pre><code class="language-hs">add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n
</code></pre>
<p>In Haskell, in order to <em>emulate iteration with mutable state</em>, we call the function again
with the values we want the variables to have in the next iteration.</p>
<h3 id="evaluation-of-recursion"><a class="header" href="#evaluation-of-recursion">Evaluation of recursion</a></h3>
<p>Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.
This is because in imperative languages, calling a function often requires creating
a new call stack.</p>
<p>However, functional languages (and Haskell in particular) play by different
rules and implement a feature called tail call elimination - when the result of a function call
is the result of the function (this is called tail position), we can just drop the current
stack frame and then allocate one for the function we call, so we don't require <code>N</code> stack frames
for <code>N</code> iterations.</p>
<p>This is of course only one way to do tail call elimination and other
strategies exists, such as translating code like our recursive <code>add</code> above to the iteration version.</p>
<h4 id="laziness"><a class="header" href="#laziness">Laziness</a></h4>
<p>Haskell plays by slightly different rules because it uses a <em>lazy evaluation strategy</em>
instead of the much more common strict evaluation strategy. An <em>evaluation strategy</em>
refers to &quot;when do we evaluate a computation&quot;. In a strict language the answer is simple:
<em>we evaluate the arguments of a function before entering a function</em>.</p>
<p>So for example the evaluation of <code>add (increment 3) (decrement 2)</code> using strict evaluation
will look like this:</p>
<ol>
<li>Evaluate <code>increment 3</code> to <code>4</code></li>
<li>Evaluate <code>decrement 2</code> to <code>1</code></li>
<li>Evaluate <code>add 4 1</code></li>
</ol>
<p>Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments
from right-to-left instead of left-to-right.</p>
<p>On the other hand, with lazy evaluation, we <em>only evaluate computation when we need it</em>, where
'<em>when do we need it?</em>' is when it is part of a computation that will have some effect on the
outside world, for example when writing a computation to standard output or sending it over the network.</p>
<p>So unless this computation is required, it won't be evaluated. For example:</p>
<pre><code class="language-hs">main =
  if add (increment 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>In the case above, we need the result of <code>add (increment 2) (decrement 3)</code>
in order to know which message to write,
so it will be evaluated. But:</p>
<pre><code class="language-hs">main =
  let
    five = add (increment 2) (decrement 3)
  in
    putStrLn &quot;Not required&quot;
</code></pre>
<p>In the case above we don't actually need <code>five</code>, so we don't evaluate it!</p>
<p>But then if we know we need <code>add (increment 2) (decrement 3)</code>,
do we use strict evaluation now? The answer is no - because we might not need
to evaluate the arguments to complete the computation. For example in this case:</p>
<pre><code class="language-hs">const a b = a

main =
  if const (increment 2) (decrement 3) == 3
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p><code>const</code> ignores the second argument and returns the first, so we don't actually need
to calculate <code>decrement 3</code> in order to provide an answer to the computation and in
turn output an answer to the screen.</p>
<p>With the lazy evaluation strategy we will evaluate expressions when we need to (when they are required
in order to do something for the user), and we evaluate from the outside in - first
we enter functions, and then we evaluate the arguments when we need to (usually when the thing
we want to evaluate appears in some control flow such as the condition of an <code>if</code> expression
or a pattern in pattern matching).</p>
<hr />
<p>I've written a more in-depth blog post about how this works in Haskell:
<a href="https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning">Substitution and Equational Reasoning</a>.</p>
<p>Please read it and try to evaluate the following program by hand:</p>
<pre><code class="language-hs">import Prelude hiding (const) -- feel free to ignore this line

increment n = n + 1

decrement n = n - 1

const a b = a

add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n

main =
  if const (add 3 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Remember that evaluation always begins from <code>main</code>.</p>
<details>
  <summary>Solution</summary>
<p>evaluating <code>main</code></p>
<pre><code class="language-hs">if const (add 3 2) (decrement 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>const</code></p>
<pre><code class="language-hs">if add 3 2 == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>add</code></p>
<pre><code class="language-hs">if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>evaluating the control flow <code>2 /= 0</code></p>
<pre><code class="language-hs">if (if True then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if (add (increment 3) (decrement 2)) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>add</code></p>
<pre><code class="language-hs">if
  ( if decrement 2 /= 0
    then add
      (increment (increment 3))
      (decrement (decrement 2))
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating <code>decrement 2</code> in the control flow (notice how both places change!)</p>
<pre><code class="language-hs">if
  ( if 1 /= 0
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating the control flow <code>1 /= 0</code></p>
<pre><code class="language-hs">if
  ( if True
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if
  ( add
    (increment (increment 3))
    (decrement 1)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Expanding <code>add</code></p>
<pre><code class="language-hs">if
  ( if decrement 1 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement (decrement 1))
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>decrement 1</code></p>
<pre><code class="language-hs">if
  ( if 0 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>0 /= 0</code></p>
<pre><code class="language-hs">if
  ( if False
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>else</code> branch</p>
<pre><code class="language-hs">if
  (increment (increment 3)) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate control flow <code>increment (increment 3)</code></p>
<pre><code class="language-hs">if
  (increment 3 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>increment 3</code></p>
<pre><code class="language-hs">if
  (3 + 1 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>3 + 1</code></p>
<pre><code class="language-hs">if
  (4 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>4 + 1</code></p>
<pre><code class="language-hs">if
  5 == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>5 == 5</code></p>
<pre><code class="language-hs">if
  True
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">putStrLn &quot;Yes.&quot;
</code></pre>
<p>Which when run will print <code>Yes.</code> to the screen.</p>
</details>
<hr />
<h3 id="general-recursion"><a class="header" href="#general-recursion">General recursion</a></h3>
<p>In general, when trying to solve problems recursively, it is useful to think
about the problem in three parts:</p>
<ol>
<li>Finding the <strong>base case</strong> (the most simple cases - the ones we already know how to answer)</li>
<li>Figuring out how to <strong>reduce</strong> the problem to something simpler (so it gets closer to the base case)</li>
<li><strong>Mitigating the difference</strong> between the reduced version and the solution we need to provide</li>
</ol>
<p>The reduce and mitigate steps together are usually called the <em>recursive step</em>.</p>
<p>Let's take a look at another example problem: generating a list of a particular size
with a specific value in place of every element.</p>
<p>In Haskell, this function would have the following signature:</p>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
</code></pre>
<p>Here are a few usage examples of <code>replicate</code>:</p>
<pre><code class="language-hs">ghci&gt; replicate 4 True
[True,True,True,True]
ghci&gt; replicate 0 True
[]
ghci&gt; replicate (-13) True
[]
</code></pre>
<p>How would we implement this function recursively? How would describe it in three steps above?</p>
<ol>
<li><strong>Base case</strong>: the cases we already know how to generate are the cases where the length
of the list is zero (or less) - we just return an empty list.</li>
<li><strong>Reduce</strong>: while we might not know how to generate a list of size <code>N</code> (where <code>N</code> is positive),
if we knew the solution for <code>N-1</code> we could:</li>
<li><strong>Mitigate</strong>: Add another element to the solution for <code>N-1</code> using the <code>:</code> (cons) operator.</li>
</ol>
<hr />
<p>Try to write this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
replicate n x =
  if n &lt;= 0    -- recognizing the base case
    then
      []       -- the solution for the base case
    else
        x : replicate (n - 1) x
  --   ---  -------------------
  --    ^           ^
  --    |           |
  --    |           +-------- reduction
  --    |
  --    +--- mitigation
</code></pre>
</details>
<hr />
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual recursion</a></h3>
<p>When solving functions recursively we usually call the same function again,
but that doesn't have to be the case. It is possible to reduce our problem
to something simpler that requires an answer from a different function.
If, in turn, that function will (or another function in that call chain)
call our function again, we have a <strong>mutual recursive</strong> solution.</p>
<p>For example, let's write two functions, one that checks whether a natural number
is even or not, and one that checks whether a number is odd or not
only by decrementing it.</p>
<pre><code class="language-hs">even :: Int -&gt; Bool

odd :: Int -&gt; Bool
</code></pre>
<p>Let's start with <code>even</code>, how should we solve this recursively?</p>
<ol>
<li><strong>Base case</strong>: We know the answer for <code>0</code> - it is <code>True</code>.</li>
<li><strong>Reduction</strong>: We might not know the answer for a general <code>N</code>, but we could check whether <code>N - 1</code> is odd,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is odd, then <code>N</code> is even! if it isn't odd, then <code>N</code> isn't even.</li>
</ol>
<p>What about <code>odd</code>?</p>
<ol>
<li><strong>Base case</strong>: We know the answer for <code>0</code> - it is <code>False</code>.</li>
<li><strong>Reduction</strong>: We might not know the answer for a general <code>N</code>, but we could check whether <code>N - 1</code> is even,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is even, then <code>N</code> is odd! if it isn't even, then <code>N</code> isn't odd.</li>
</ol>
<hr />
<p>Try writing this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">even :: Int -&gt; Bool
even n =
  if n == 0
    then
      True
    else
      odd (n - 1)

odd :: Int -&gt; Bool
odd n =
  if n == 0
    then
      False
    else
      even (n - 1)

</code></pre>
</details>
<hr />
<h2 id="partial-functions"><a class="header" href="#partial-functions">Partial functions</a></h2>
<p>because we didn't handle negative cases in the example above, our functions will loop forever
when a negative value is passed as input. A function that does not return a result for some value
(either by not terminating or by throwing an error) is called <strong>a partial function</strong>
(because it only returns a result of a part of the possible inputs).</p>
<p>Partial functions are generally considered <strong>bad practice</strong> because they can have
unexpected behaviour at runtime, so we want to <strong>avoid using</strong> partial functions
as well as <strong>avoid writing</strong> partial functions.</p>
<p>The best way to avoid writing partial functions is by covering all inputs!
In the situation above, it is definitely possible to handle negative numbers
as well, so we should do that! Or, instead, we could require that our functions
accept a <code>Natural</code> instead of an <code>Int</code>, and then the type system would've stopped
us from using these functions with values that we did not handle.</p>
<p>There are cases where we can't possibly cover all inputs, in these cases it is important
to re-examine the code and see if we could further restrict the inputs using types to
mitigate these issues.</p>
<p>For example, the <code>head :: [a] -&gt; a</code> function from <code>Prelude</code> promises
to return the first element (the head) of a list, but we know that lists
could possibly be empty, so how can this function deliver on its promise?</p>
<p>Unfortunately, it can't. But there exists a different function that can:
<code>head :: NonEmpty a -&gt; a</code> from the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List-NonEmpty.html"><code>Data.List.NonEmpty</code></a>
module! The trick here is that this other <code>head</code> does not take a general list
as input, it takes a different type entirely, one that promises to have
at least one element, and therefore can deliver on its promise!</p>
<p>We could also potentially use smart constructors with <code>newtype</code> and enforce some sort
of a restriction in the type system, as we saw in earlier chapters.
But this solution can sometimes be less ergonomic to use.</p>
<p>An alternative approach is to use <code>data</code> types to encode the absence of a proper result,
for example, using <code>Maybe</code>, as we'll see in a future chapter.</p>
<h2 id="parsing-markup"><a class="header" href="#parsing-markup">Parsing markup?</a></h2>
<p>Let's get back to the task at hand.</p>
<p>As stated previously, our strategy for parsing the markup text is:</p>
<ol>
<li>Split the string to a list where each element is a separate line
(which we can do with <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>), and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>Remember that we want to start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of -- (4)
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (5)
          else
            parseLines (currentLine : currentParagraph) rest -- (6)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Things to note:</p>
<ol>
<li>
<p>We pass a list that contains the currently grouped paragraph (paragraphs are separated by an empty line)</p>
</li>
<li>
<p>Because of laziness, <code>paragraph</code> is not computed until it's needed, so we don't have to worry about
the performance implications in the case the we are still grouping lines</p>
</li>
<li>
<p>Why do we reverse <code>currentParagraph</code>? (See point (6))</p>
</li>
<li>
<p>We saw case expressions used to deconstruct <code>newtype</code>s and <code>Char</code>s,
but we can also pattern match on lists and other ADTs as well!
In this case we match against two patterns, an empty list (<code>[]</code>),
and a &quot;cons cell&quot; - a list with at least one element (<code>currentLine : rest</code>).
In the body of the &quot;cons&quot; pattern, we bind the first element to the name <code>currentLine</code>,
and the rest of the elements to the name <code>rest</code>.</p>
<p>We will talk about how all of this works really soon!</p>
</li>
<li>
<p>When we run into an empty line we add the accumulated paragraph to the resulting list (A <code>Document</code> is a list of structures) and start the function again with the rest of the input.</p>
</li>
<li>
<p>We pass the new lines to be grouped in a paragraph <strong>in reverse order</strong> because of
performance characteristics - because of the nature of singly-linked lists,
prepending an element is fast, and appending is slow. Prepending only requires
us to create a new cons (<code>:</code>) cell to hold a pointer to the value and a pointer to the list,
but appending requires us to traverse the list to its end and rebuild the cons cells -
the last one will contain the last value of the list and a pointer to the list to append,
the next will contain the value before the last value of the list and a pointer to the
list which contains the last element and the appended list, and so on.</p>
</li>
</ol>
<p>This code above will group together paragraphs in a structure, but how do we view our result?
In the next chapter will take a short detour and talk a bit about type classes, and how
they can help us in this scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-the-parsing-results-type-classes"><a class="header" href="#displaying-the-parsing-results-type-classes">Displaying the parsing results (type classes)</a></h1>
<p>We want to be able to print a textual representation of values
of our <code>Document</code> type. There are a few ways to do that:</p>
<ol>
<li>Write our own function of type <code>Document -&gt; String</code> which we could then print, or</li>
<li>Have Haskell write one for us</li>
</ol>
<p>Haskell provides us with a mechanism that can automatically generate the implementation of a
<em>type class</em> function called <code>show</code>, that will convert our type to <code>String</code>.</p>
<p>The type of the function <code>show</code> looks like this:</p>
<pre><code class="language-hs">show :: Show a =&gt; a -&gt; String
</code></pre>
<p>This is something new we haven't seen before. Between <code>::</code> and <code>=&gt;</code>
you see what is called a <strong>type class constraint</strong> on the type <code>a</code>. What
we say in this signature, is that the function <code>show</code> can work on any
type that is a member of the type class <code>Show</code>.</p>
<p>Type classes is a feature in Haskell that allows us to declare a common
interface for different types. In our case, Haskell's standard library
defines the type class <code>Show</code> in the following way (this is a simplified
version but good enough for our purposes):</p>
<pre><code class="language-hs">class Show a where
  show :: a -&gt; String
</code></pre>
<p>A type class declaration describes a common interface for Haskell types.
<code>show</code> is an overloaded function that will work for any type that is an <em>instance</em>
of the type class <code>Show</code>.
We can define an instance of a type class manually like this:</p>
<pre><code class="language-hs">instance Show Bool where
  show x =
    case x of
      True -&gt; &quot;True&quot;
      False -&gt; &quot;False&quot;
</code></pre>
<p>Defining an instance means providing an implementation for the interface for a specific type.
When we call the function <code>show</code> on a data type, the compiler will search the instance of
the type it inferred, and use the implementation provided in the instance declaration.</p>
<pre><code class="language-hs">ghci&gt; show True
&quot;True&quot;
ghci&gt; show 187
&quot;187&quot;
ghci&gt; show &quot;Hello&quot;
&quot;\&quot;Hello\&quot;&quot;
</code></pre>
<p>As can be seen above, the <code>show</code> function converts a value to its textual representation.
Which is why <code>&quot;Hello&quot;</code> includes the quotes as well. The <code>Show</code> type class is usually
used for debugging purposes.</p>
<h2 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving instances</a></h2>
<p>It is also possible to automatically generate implementations of a few selected
type classes. Fortunately, <code>Show</code> is one of them.</p>
<p>If all the types we use in the definition of our data type already implement
an instance of <code>Show</code>, we can <em>automatically derive</em> it by adding <code>deriving Show</code> at the
end of the data definition.</p>
<pre><code class="language-hs">data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving Show
</code></pre>
<p>Now we can use the function <code>show :: Show a =&gt; a -&gt; String</code> for any
type that implements an instance of the <code>Show</code> type class. For example, with print:</p>
<pre><code class="language-hs">print :: Show a =&gt; a -&gt; IO ()
print = putStrLn . show
</code></pre>
<p>We can first convert our type to <code>String</code> and then write it to the
standard output.</p>
<p>And because lists also implement <code>Show</code> for any element type that has
a <code>Show</code> instance, we can now print <code>Document</code>s, because they are just
aliases for <code>[Structure]</code>. Try it!</p>
<p>There are many type classes Haskellers use everyday. A couple more are
<code>Eq</code> for equality and <code>Ord</code> for ordering. These are also special type classes
that can be derived automatically.</p>
<h2 id="laws"><a class="header" href="#laws">Laws</a></h2>
<p>Type classes often come with &quot;rules&quot; or &quot;laws&quot; that instances should satisfy,
the purpose of these laws is to provide <em>predictable behaviour</em> across
instances, so that when we run into a new instance we can be confident
that it will behave in a certain expected way, and we can write code
that works generically for all instances of a type class while expecting
them to adhere to these rules.</p>
<p>As an example, let's look at the <code>Semigroup</code> type class:</p>
<pre><code class="language-hs">class Semigroup a where
  (&lt;&gt;) :: a -&gt; a -&gt; a
</code></pre>
<p>This type class provides a common interface for types with an operation <code>&lt;&gt;</code>
that can combine two values into one in some way.</p>
<p>This type class also mentions that this <code>&lt;&gt;</code> operation should be associative,
meaning that these two sides should evaluate to the same result:</p>
<pre><code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z
</code></pre>
<p>An example of a lawful instance of <code>Semigroup</code> is lists with the append operation (<code>++</code>):</p>
<pre><code class="language-hs">instance Semigroup [a] where
  (&lt;&gt;) = (++)
</code></pre>
<p>Unfortunately the Haskell type system cannot &quot;prove&quot; that instances
satisfy these laws, but as a community we often shun unlawful instances.</p>
<p>Many data types (together with their respective operations) can
form a <code>Semigroup</code>, and instances
don't even have to look similar or have a common analogy/metaphor
(and this is true for many other type classes as well).</p>
<p><strong>Type classes are often just <em>interfaces</em> with <em>laws</em></strong> (or expected behaviour if you will).
Approaching them with this mindset can be very liberating!</p>
<p>To put it a differently, <strong>type classes can be used to create abstractions</strong> -
interfaces with laws/expected behaviour where we don't actually care about the
concrete details of the underlying type, just that it <em>implements a certain
API and behaves in a certain way</em>.</p>
<p>Regarding <code>Semigroup</code>, we have <a href="04-markup/../03-html/04-safer_construction.html#appending-htmlstructure">previously</a>
created a function that looks like <code>&lt;&gt;</code> for our <code>Html</code> EDSL!
We can add a <code>Semigroup</code> instance for our <code>Structure</code> data type
and have a nicer to use API!</p>
<hr />
<p>Exercise: Please do this and remove the <code>append_</code> function from the API.</p>
<details>
  <summary>Solution</summary>
<p>Replace this:</p>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>With this:</p>
<pre><code class="language-hs">instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>And remove the export of <code>append_</code> in <code>Html.hs</code>. You won't need to further export anything
as type class instances are exported automatically.</p>
<p>You will also need replace the usage of <code>append_</code> with <code>&lt;&gt;</code> in <code>hello.hs</code>.</p>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-02-pattern-matching"><a class="header" href="#parsing-markup-part-02-pattern-matching">Parsing markup part 02 (Pattern matching)</a></h1>
<h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Previously, when we talked about partial functions, we mentioned that one way to avoid
writing partial functions is to encode the absence of a result using <code>Maybe</code>:</p>
<pre><code class="language-hs">data Maybe a
  = Nothing
  | Just a
</code></pre>
<p><code>Maybe</code> is a data type from the standard library (named <a href="https://hackage.haskell.org/package/base">base</a>)
that is used to add an additional value to a type: the absence of a value.
For example, <code>Maybe Bool</code> has three values,
two with the <code>Just</code> constructor to represent regular boolean values
(<code>Just True</code> and <code>Just False</code>) and another value, <code>Nothing</code> to represent
the absence of a boolean value.</p>
<p>We can use this to encode the result of <code>head</code>, a function that promises to return
the first element of a list, without creating a partial function:</p>
<pre><code class="language-hs">safeHead :: [a] -&gt; Maybe a
</code></pre>
<p>This way, when the list is empty, we can return <code>Nothing</code>, and when it has at least
one element, we can return <code>Just &lt;first element&gt;</code>. This function can be found in
the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html">Data.Maybe</a>
module under the name
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>.</p>
<p>In order to <em>consume</em> values of type <code>Maybe &lt;something&gt;</code>, and other types created with
<code>data</code>, we can use pattern matching.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>We've already seen pattern matching a few times.
It is an incredibly versatile feature of Haskell, we can use it to do two main things:</p>
<ol>
<li>Deconstruct complex values</li>
<li>Control flow</li>
</ol>
<p>As we've seen when discussing
<a href="04-markup/../03-html/04-safer_construction.html#using-newtypes">newtypes</a>,
we can use <strong>case expressions</strong> and <strong>function definitions</strong> to deconstruct a <code>newtype</code>,
but we can do that for <code>data</code> types as well:</p>
<pre><code class="language-hs">-- | A data type representing colors
data Color
  = RGB Word8 Word8 Word8

getBluePart :: Color -&gt; Word8
getBluePart color =
  case color of
    RGB _ _ blue -&gt; blue
</code></pre>
<p>In <code>getBluePart</code> we deconstruct a composite value into its part and extract the third component
representing the blue value in a color represented by red, green and blue components (RGB).</p>
<p>Note that <code>blue</code> is the name we give to the third component so it will be bound
to the right of the arrow that comes after the pattern. This is similar to
a function argument. Also note that <code>_</code> matches any value <em>without</em> binding it to a name.</p>
<p>We can also try to match a value with more than one pattern:</p>
<pre><code class="language-hs">data Brightness
  = Dark
  | Bright

data EightColor
  = Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

data AnsiColor
  = AnsiColor Brightness EightColor

ansiColorToVGA :: AnsiColor -&gt; Color
ansiColorToVGA ansicolor =
  case ansicolor of
    AnsiColor Dark Black -&gt;
      RGB 0 0 0
    AnsiColor Bright Black -&gt;
      RGB 85 85 85
    AnsiColor Dark Red -&gt;
      RGB 170 0 0
    AnsiColor Bright Red -&gt;
      RGB 255 85 85
    -- and so on
</code></pre>
<p>It's important to notice a few things here:</p>
<ol>
<li>Patterns can be nested, notice how we deconstructed <code>ansicolor</code> on multiple levels</li>
<li>We try to match patterns from the top down, it is possible for patterns to overlap with one another and the top one will win</li>
<li>If the value we try to match does not match any of the patterns listed, an error will be thrown at runtime</li>
</ol>
<p>We can ask GHC to notify us when we accidentally write overlapping patterns,
or when we haven't listed enough patterns to match all possible values,
by passing the flag <code>-Wall</code> to <code>ghc</code> or <code>runghc</code>.</p>
<p><strong>My recommendation is to always use <code>-Wall</code></strong>!</p>
<blockquote>
<p>As an aside, while it is possible to use pattern matching in function definitions by defining a function
multiple times, <a href="https://twitter.com/_gilmi/status/1257225601079029760">I personally don't like that feature very much</a>
and I would encourage you to avoid it,
but if you want to use it instead of case expressions, it is possible.</p>
</blockquote>
<h3 id="pattern-matching-on-linked-lists"><a class="header" href="#pattern-matching-on-linked-lists">Pattern matching on linked lists</a></h3>
<p>Because linked lists have their own <a href="04-markup//03-html/06-escaping_characters.html#linked-lists-briefly">special syntax</a>,
we also have slightly special syntax when we pattern match on them.
We can use the same special syntax for creating lists when we pattern match on lists,
replacing the <em>elements</em> of the list with patterns. For example:</p>
<pre><code class="language-hs">safeHead :: [a] -&gt; Maybe a
safeHead list =
  case list of
    -- Empty list
    [] -&gt; Nothing

    -- Cons cell pattern, will match any list with at least one element
	x : _ -&gt; Just x
</code></pre>
<pre><code class="language-hs">exactlyTwo :: [a] -&gt; Maybe (a, a)
exactlyTwo list =
  case list of
    -- Will match a list with exactly two elements
	[x, y] -&gt; Just (x, y)

    -- Will match any other pattern
	_ -&gt; Nothing
</code></pre>
<pre><code class="language-hs">-- This will also work
exactlyTwoVersion2 :: [a] -&gt; Maybe (a, a)
exactlyTwoVersion2 list =
  case list of
    -- Will match a list with exactly two elements
	x : y : [] -&gt; Just (x, y)

    -- Will match any other pattern
	_ -&gt; Nothing
</code></pre>
<hr />
<p>Exercises:</p>
<ol>
<li>Create a function <code>isBright :: AnsiColor -&gt; Bool</code> that checks whether a color is bright or not</li>
<li>Use <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">this table</a> to write <code>ansiToUbuntu</code>.</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that uses <code>listToMaybe</code> to check whether a list is empty or not</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that <em>doesn't</em> use <code>listToMaybe</code> to check whether a list is empty or not</li>
</ol>
<p>Solutions:</p>
<details><summary>Solution for (1)</summary>
<pre><code class="language-hs">isBright :: AnsiColor -&gt; Bool
isBright ansiColor =
  case ansiColor of
    AnsiColor Bright _ -&gt; True
    AnsiColor Dark _ -&gt; False
</code></pre>
</details>
<details><summary>Solution for (2)</summary>
<pre><code class="language-hs">ansiToUbuntu :: AnsiColor -&gt; Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor brightness color -&gt;
      case brightness of
        Dark -&gt;
          case color of
            Black -&gt; RGB 0 0 0
            Red -&gt; RGB 194 54 33
            Green -&gt; RGB 37 188 36
            Yellow -&gt; RGB 173 173 39
            Blue -&gt; RGB 73 46 225
            Magenta -&gt; RGB 211 56 211
            Cyan -&gt; RGB 51 187 200
            White -&gt; RGB 203 204 205

        Bright -&gt;
          case color of
            Black -&gt; RGB 129 131 131
            Red -&gt; RGB 252 57 31
            Green -&gt; RGB 49 231 34
            Yellow -&gt; RGB 234 236 35
            Blue -&gt; RGB 88 51 255
            Magenta -&gt; RGB 249 53 248
            Cyan -&gt; RGB 20 240 240
            White -&gt; RGB 233 235 235
</code></pre>
<p>Since pattern matching goes arbitrarily deep as we saw before, we could instead
pattern match all the way through in one case expression:</p>
<pre><code class="language-hs">ansiToUbuntu :: AnsiColor -&gt; Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor Dark Black -&gt; RGB 0 0 0
    AnsiColor Dark Red -&gt; RGB 194 54 33
    AnsiColor Dark Green -&gt; RGB 37 188 36
    AnsiColor Dark Yellow -&gt; RGB 173 173 39
    AnsiColor Dark Blue -&gt; RGB 73 46 225
    AnsiColor Dark Magenta -&gt; RGB 211 56 211
    AnsiColor Dark Cyan -&gt; RGB 51 187 200
    AnsiColor Dark White -&gt; RGB 203 204 205
    AnsiColor Bright Black -&gt; RGB 129 131 131
    AnsiColor Bright Red -&gt; RGB 252 57 31
    AnsiColor Bright Green -&gt; RGB 49 231 34
    AnsiColor Bright Yellow -&gt; RGB 234 236 35
    AnsiColor Bright Blue -&gt; RGB 88 51 255
    AnsiColor Bright Magenta -&gt; RGB 249 53 248
    AnsiColor Bright Cyan -&gt; RGB 20 240 240
    AnsiColor Bright White -&gt; RGB 233 235 235
</code></pre>
<p>But this is a bit too much repetition of <code>AnsiColor</code>, <code>Dark</code> and <code>Bright</code>
to my taste in this case.</p>
</details>
<details><summary>Solution for (3)</summary>
<pre><code class="language-hs">isEmpty :: [a] -&gt; Bool
isEmpty list =
  case listToMaybe list of
    Nothing -&gt; True
    Just _ -&gt; False
</code></pre>
</details>
<details><summary>Solution for (4)</summary>
<pre><code class="language-hs">isEmpty :: [a] -&gt; Bool
isEmpty list =
  case list of
    [] -&gt; True
    _ : _ -&gt; False
</code></pre>
</details>
<hr />
<h2 id="parsing-with-rich-context"><a class="header" href="#parsing-with-rich-context">Parsing with rich context</a></h2>
<p>Previously we wrote a parser that separates documents into different paragraphs.
With new features under our belt we can now remember the exact context we are in
(whether it is a text paragraph, a list, or a code block) and act accordingly!</p>
<p>Let's look again at the parsing code we wrote previously:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph))
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest
          else
            parseLines (currentLine : currentParagraph) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Previously our context, <code>currentParagraph</code>, was used to group adjacent lines in an accumulative list.</p>
<p>Next, instead of using a <code>[String]</code> type to denote adjacent lines, we can instead use a <code>Structure</code> to denote the context.</p>
<p>One issue we might have though with representing context with the <code>Structure</code> type,
is that when we start parsing we don't have any context.
But we learned of a way to represent the possibility of an absence of a value with <code>Maybe</code>! So our new context type can be <code>Maybe Structure</code> instead.</p>
<p>Let's rewrite our code above to use our new context type:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines -- (1)

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    [] -&gt; maybeToList context   -- (2)
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest) -- (3)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4), (5)
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<ol>
<li>
<p>We can now pass <code>Nothing</code> when we don't have a context</p>
</li>
<li>
<p>Unsure what <code>maybeToList</code> does? <a href="https://hoogle.haskell.org">Hoogle</a> it!</p>
</li>
<li>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:maybe">maybe</a> is a function
that works similarly to pattern matching on a <code>Maybe</code>:
the third argument to <code>maybe</code> is the value we pattern match on, the second argument is a function to apply
to the value found in a <code>Just</code> case, and the first argument is the value to return in case the value
we pattern match on is <code>Nothing</code>. This way to encode pattern matching using functions is actually
fairly common.</p>
<p>Check out the types of <code>id</code>, <code>(:)</code> and <code>maybe id (:)</code> in GHCi!</p>
</li>
<li>
<p>Hey! Didn't we say that appending <code>String</code>s/lists is slow (which is what <code>unwords</code> does)? Yes, it is.
Because in our <code>Structure</code> data type, a paragraph is defined as <code>Paragraph String</code> and not <code>Paragraph [String]</code>,
we can't use our trick of building a list of lines and the reverse it at the end.</p>
<p>So what do we do?
There are many ways to handle that, one simple way is to create a different type with the right shape:</p>
<pre><code class="language-hs">data Context
  = CtxHeading Natural String
  | CtxParagraph [String]
  | CtxUnorderedList [String]
  | CtxOrderedList [String]
  | CtxCodeBlock [String]
</code></pre>
<p>Since creating new types in Haskell is cheap, this is a very viable solution.</p>
<p>In this case I'm going with the approach of not worrying about it too much,
because it's a very local piece of code that can easily be fixed later if we see that it's an issue.</p>
</li>
<li>
<p>Anyway, if you've used <code>-Wall</code> like I've suggested,
you'd get a warning from GHC saying that the <em>&quot;pattern matches are non-exhaustive&quot;</em>.
This is because we did not cover all cases. So let's cover more cases:</p>
</li>
</ol>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context

    -- Heading 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<hr />
<p>Exercise: Add the <code>CodeBlock</code> and <code>OrderedList</code> cases.</p>
<details>
  <summary>Final module</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  , parse
  )
where

import Numeric.Natural
import Data.Maybe (maybeToList)

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving (Eq, Show)    -- (1)


parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context

    -- Heading 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Ordered list case
    ('#' : ' ' : line) : rest -&gt;
      case context of
        Just (OrderedList list) -&gt;
          parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)

    -- Code block case
    ('&gt;' : ' ' : line) : rest -&gt;
      case context of
        Just (CodeBlock code) -&gt;
          parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
</details>
<hr />
<h3 id="how-do-we-know-our-parser-works-correctly"><a class="header" href="#how-do-we-know-our-parser-works-correctly">How do we know our parser works correctly?</a></h3>
<p>In an earlier chapter, we parsed a few examples of our markup language <a href="04-markup/01-data_type.html#exercises">by hand</a>.
Now, we can try to test our parser by comparing our solutions to our parser.
By adding <code>Eq</code> to the list of type class instances to derive for our <code>Structure</code> data type
(as shown on the line marked with (1) in &quot;final module&quot; above),
we can add these to our module and use the <code>==</code> (equals) operator to compare our
solutions to the result our parser gives.</p>
<p>Try it in GHCi! You can read a text file in GHCi using the following syntax:</p>
<pre><code class="language-hs">ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;
</code></pre>
<p>And then compare with the hand written example values from the solutions
(after adding them to the module and loading them in GHCi):</p>
<pre><code class="language-hs">ghci&gt; parse txt == example4
</code></pre>
<p>In a later chapter, we'll discuss how to use a testing framework and
write automated tests for our parser. But first, I'd like to glue things together
so we'll be able to:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text</li>
<li>Convert the result to our HTML EDSL</li>
<li>Generate HTML code</li>
</ol>
<p>And also discuss how to work with IO in Haskell while we're at it.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/4ee2adbdf9b2657f547bcc4b268be6f6798981a6">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/76c4f4b31c7883c5c0b9f09c7b1a391640a31538">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gluing-things-together"><a class="header" href="#gluing-things-together">Gluing things together</a></h1>
<p>In this chapter we are going to glue the pieces that we built together
and build an actual blog generator. We will:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text to a <code>Document</code></li>
<li>Convert the result to our <code>Html</code> EDSL</li>
<li>Generate HTML code</li>
<li>Write it to file</li>
</ol>
<p>While doing so, we will learn:</p>
<ul>
<li>How to work with IO</li>
<li>How to import external libraries to process whole directories and create a simple command-line interface</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-markup-to-html"><a class="header" href="#converting-markup-to-html">Converting Markup to HTML</a></h1>
<p>One key part is missing before we can do glue everything together, and that is
to convert our <code>Markup</code> data types to <code>Html</code>.</p>
<p>We'll start by creating a new module and import both the <code>Markup</code> and the <code>Html</code> modules.</p>
<pre><code class="language-hs">module Convert where

import qualified Markup
import qualified Html
</code></pre>
<h2 id="qualified-imports"><a class="header" href="#qualified-imports">Qualified Imports</a></h2>
<p>This time, we've imported the modules qualified. Qualified imports means that
instead of exposing the names that we've defined in the imported module to
the general module name space, they now have to be prefixed with the module name.</p>
<p>For example, <code>parse</code> becomes <code>Markup.parse</code>.
If we would've imported <code>Html.Internal</code> qualified, we'd have to write
<code>Html.Internal.el</code> which is a bit long.</p>
<p>We can also give a new name to the module to be used instead with the <code>as</code>
keyword:</p>
<pre><code class="language-hs">import qualified Html.Internal as HI
</code></pre>
<p>And now write <code>HI.el</code> instead.</p>
<p>I like using qualified imports because readers do not have to guess where a
name came from. Some modules are even designed to be imported qualified.
For example, many container APIs such as maps, sets and vectors have very similar
API. If we want to multiple containers in a single module we pretty much have
to use qualified imports so that when we write a function such as <code>singleton</code>,
which creates a container with a single value, GHC will know to which <code>singleton</code>
function from which module we are referring.</p>
<p>Some people prefer to use import lists instead of qualified imports as well,
because qualified names can be a bit verbose and noisy. I usually prefer them,
but up to you. For more information about imports,
see this <a href="https://wiki.haskell.org/Import">wiki article</a>.</p>
<h2 id="converting-markupstructure-to-htmlstructure"><a class="header" href="#converting-markupstructure-to-htmlstructure">Converting <code>Markup.Structure</code> to <code>Html.Structure</code></a></h2>
<p>Converting a markup structure to an HTML structure is mostly straightforward
at this point, we need to pattern match on the markup structure and use
the relevant HTML API.</p>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading 1 txt -&gt;
      Html.h1_ txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<p>Notice that running this code with <code>-Wall</code> will reveal that the pattern matching
is <em>non-exhaustive</em>. This is because we don't currently have a way to build
headings that are not <code>h1</code>. There are a few ways to handle this:</p>
<ul>
<li>Ignore the warning - this will likely fail at runtime one day and the user will be sad</li>
<li>Pattern match other cases and add a nice error with the <code>error</code> function, has
the same disadvantage above, but will also not notify that there's a possible issue
here at compile time.</li>
<li>Pattern match and do the wrong thing - user is still sad</li>
<li>Encode errors in the type system using <code>Either</code>, we'll see how to do this in later
chapters</li>
<li>Restrict the input - change <code>Markup.Heading</code> to not include a number but rather
specific supported headings. This is a reasonable approach.</li>
<li>Implement an HTML function supporting arbitrary headings. Should be straightforward
to do.</li>
</ul>
<hr />
<p>Exercise: Implement <code>h_ :: Natural -&gt; String -&gt; Structure</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">import Numeric.Natural

h_ :: Natural -&gt; String -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . escape
</code></pre>
<p>Don't forget to export it from <code>Html.hs</code>!</p>
</details>
<p>Exercise: Fix <code>convertStructure</code> using <code>h_</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
<hr />
<h2 id="document---html"><a class="header" href="#document---html">Document -&gt; Html</a></h2>
<p>In order to create an <code>Html</code> document, we need to use the <code>html_</code> function.
This function expects two things: a <code>Title</code>, and a <code>Structure</code>.</p>
<p>For a title we just could supply it from outside using the file name.</p>
<p>In order to convert our markup <code>Document</code> (which is a list of markup <code>Structure</code>)
to an HTML <code>Structure</code>, we need to convert each markup <code>Structure</code> and then
concatenate them together.</p>
<p>We already know how to convert each markup <code>Structure</code>, we can use the
<code>convertStructure</code> function we wrote and <code>map</code>. This will provide
us with the following function:</p>
<pre><code>map convertStructure :: Markup.Document -&gt; [Html.Structure]
</code></pre>
<p>To concatenate all of the <code>Html.Structure</code>, we could write a recursive
function that tries to do that. However we will quickly run to an issue
with the base case, what to do when the list is empty?</p>
<p>We could just provide dummy <code>Html.Structure</code> that represents an empty
HTML structure.</p>
<p>Let's add this to <code>Html.Internal</code>:</p>
<pre><code class="language-hs">empty_ :: Structure
empty_ = Structure &quot;&quot;
</code></pre>
<hr />
<p>Now we can write our recursive function. Try it!</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">concatStructure :: [Structure] -&gt; Structure
concatStructure list =
  case list of
    [] -&gt; empty_
    x : xs -&gt; x &lt;&gt; concatStructure xs
</code></pre>
</details>
<hr />
<p>Remember the <code>&lt;&gt;</code> function we implemented as an instance of the <code>Semigroup</code>
type class? We said that <code>Semigroup</code> is an <strong>abstraction</strong> for things
that implements <code>(&lt;&gt;) :: a -&gt; a -&gt; a</code>, where  <code>&lt;&gt;</code> is associative
(<code>a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c</code>).</p>
<p>It turns out that things that have an &quot;empty&quot; value and are also
an instance of <code>Semigroup</code> is quite a common thing. For example a string.
And this is actually a well known <strong>abstraction</strong>. This abstraction
is called a <strong>monoid</strong>.</p>
<h2 id="monoids"><a class="header" href="#monoids">Monoids</a></h2>
<p>Actually, maybe &quot;empty&quot; isn't a very good description of what we want,
and isn't very useful as an abstraction. Instead, we can describe it as
what is often called an &quot;identity&quot; element.
An identity element is one that satisfy the following laws:</p>
<ul>
<li><code>x &lt;&gt; &lt;identity&gt; = x</code></li>
<li><code>&lt;identity&gt; &lt;&gt; x = x</code></li>
</ul>
<p>In other words, if we try to use this &quot;empty&quot; - this identity value,
as one argument to <code>&lt;&gt;</code>, we will always get the other argument back.</p>
<p>For <code>String</code>, the empty string, <code>&quot;&quot;</code>, satisfies this:</p>
<pre><code class="language-hs">&quot;&quot; &lt;&gt; &quot;world&quot; = &quot;world&quot;
&quot;hello&quot; &lt;&gt; &quot;&quot; = &quot;hello&quot;
</code></pre>
<p>This is of course true for any value we'd write and not just &quot;world&quot; and &quot;hello&quot;.</p>
<p>Actually, if we move out of the Haskell world for a second, even integers
with <code>+</code> as the associative binary operations <code>+</code> (in place of <code>&lt;&gt;</code>)
and <code>0</code> in place of the identity member form a monoid:</p>
<pre><code class="language-hs">17 + 0 = 17
0 + 99 = 99
</code></pre>
<p>So integers together with the <code>+</code> operation form a semigroup, and
together with <code>0</code> form a monoid.</p>
<p>We learn new things from this:</p>
<ol>
<li>A monoid is a more specific abstraction over semigroup, it builds on it
by adding a new condition (the existence of an identity member)</li>
<li>This abstraction can be useful! We can write a general <code>concatStructure</code>
that could work for any monoid</li>
</ol>
<p>And indeed, there exists a type class in <code>base</code> called <code>Monoid</code> which has
<code>Semigroup</code> as a <strong>super class</strong>.</p>
<pre><code class="language-hs">class Semigroup a =&gt; Monoid a where
  mempty :: a
</code></pre>
<blockquote>
<p>Note: this is actually a simplified version. The
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Monoid">actual</a>
is a bit more complicated because of backwards compatibility and performance reasons.
<code>Semigroup</code> was actually introduced in Haskell after <code>Monoid</code>!</p>
</blockquote>
<p>We could add an instance of <code>Monoid</code> for our markup <code>Structure</code> data type:</p>
<pre><code class="language-hs">instance Monoid Structure where
  mempty = empty_
</code></pre>
<p>And now, instead of using our own <code>concatStructure</code>, we can use the library function</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
</code></pre>
<p>Which could theoretically be implemented as:</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
mconcat list =
  case list of
    [] -&gt; mempty
    x : xs -&gt; x &lt;&gt; mconcat xs
</code></pre>
<p>(Notice that because <code>Semigroup</code> is a <em>super class</em> of <code>Monoid</code>,
we can still use the <code>&lt;&gt;</code> function from the <code>Semigroup</code> class
without adding the <code>Semigroup a</code> constraint to the left side of <code>=&gt;</code>.
By adding the <code>Monoid a</code> constraint we implicitly add a <code>Semigroup a</code>
constraint as well!)</p>
<p>This <code>mconcat</code> function we wrote is very similar to the <code>concatStructure</code> function we wrote,
but this one works for any <code>Monoid</code>, including <code>Structure</code>!
Abstractions are useful and help us <strong>reuse</strong> code!</p>
<blockquote>
<p>Side note: integers with <code>+</code> and <code>0</code> aren't actually an instance of <code>Monoid</code> in Haskell.
This is because integers can also form a monoid with <code>*</code> and <code>1</code>! But <strong>there can only
be one instance per type</strong>. Instead, two other <code>newtype</code>s exist that provide that
functionality, <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Monoid.html#t:Sum">Sum</a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Monoid.html#t:Product">Product</a>.
See how they can be used in <code>ghci</code>:</p>
<pre><code class="language-hs">ghci&gt; import Data.Monoid
ghci&gt; Product 2 &lt;&gt; Product 3 -- note, Product is a data constructor
Product {getProduct = 6}
ghci&gt; getProduct (Product 2 &lt;&gt; Product 3)
6
ghci&gt; getProduct $ mconcat $ map Product [1..5]
120
</code></pre>
</blockquote>
<h2 id="another-abstraction"><a class="header" href="#another-abstraction">Another abstraction?</a></h2>
<p>We've used <code>map</code> and then <code>mconcat</code> twice now. Surely there has to be a function
that unifies this pattern. And indeed, it is called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Foldable.html#v:foldMap"><code>foldMap</code></a>,
and it works not only for lists, it will work for any data structure that can be &quot;folded&quot;,
or &quot;reduced&quot;, into a summary value. This abstraction and type class is called <strong>Foldable</strong>.</p>
<p>For a simpler understanding of <code>Foldable</code>, we can look at <code>fold</code>:</p>
<pre><code class="language-hs">fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m

-- compare with
mconcat :: Monoid m            =&gt; [m] -&gt; m
</code></pre>
<p><code>mconcat</code> is just a specialized version of <code>fold</code> for lists.
And <code>fold</code> can be a used for any pair of a data structure that implements
<code>Foldable</code> and a payload type that implements <code>Monoid</code>. This
could be <code>[]</code> with <code>Structure</code>, or <code>Maybe</code> with <code>Product Int</code>, or
your new shiny binary tree with <code>String</code> as the payload type. But note that
the <code>Foldable</code> type must be of <em>kind</em> <code>* -&gt; *</code>. So for example <code>Html</code>
cannot be a <code>Foldable</code>.</p>
<p><code>foldMap</code> is a function that allows us to apply a function to the
payload type of the <code>Foldable</code> type right before combining them
with the <code>&lt;&gt;</code> function.</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) -&gt; (a -&gt; m) -&gt; t a -&gt; m

-- compare to a specialized version with:
-- - t ~ []
-- - m ~ Html.Structure
-- - a ~ Markup.Structure
foldMap
  :: (Markup.Structure -&gt; Html.Structure)
  -&gt; [Markup.Structure]
  -&gt; Html.Structure
</code></pre>
<p>True to its name, it really &quot;maps&quot; before it &quot;folds&quot;. You might pause here
and think &quot;this 'map' we are talking about isn't specific for lists, maybe
that's another abstraction?&quot;, yes. It is actually a very important and
fundamental abstraction called <code>Functor</code>.
But I think we had enough abstractions for this chapter.
We'll cover it in a later chapter!</p>
<h2 id="finishing-our-conversion-module"><a class="header" href="#finishing-our-conversion-module">Finishing our conversion module</a></h2>
<p>Let's finish our code by writing <code>convert</code>:</p>
<pre><code class="language-hs">convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure
</code></pre>
<p>Now we have a full implementation and are able to convert markup documents
to HTML:</p>
<pre><code class="language-hs">-- Convert.hs
module Convert where

import qualified Markup
import qualified Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>We learned about:</p>
<ul>
<li>Qualified imports</li>
<li>Ways to handle errors</li>
<li>The <code>Monoid</code> type class and abstraction</li>
<li>The <code>Foldable</code> type class and abstraction</li>
</ul>
<p>Next, we are going to glue our functionality together and learn about
I/O in Haskell!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/84c92cbe8679e66b191ca4d4692241b4e5c13a57">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/4ee2adbdf9b2657f547bcc4b268be6f6798981a6">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-io"><a class="header" href="#working-with-io">Working with IO</a></h1>
<p>In previous chapters we were able to build a parser from a text
string to a Haskell representation of our markup language,
and we built an EDSL for easy writing of HTML code.
However, our program is still not useful to other users because
we did not make this functionality accessible to a user via some sort of
user interface.</p>
<p>In our program, we'd like to learn from the user what they'd
like our program to convert to HTML, and then convert that for them.
There are many ways to design this kind of interface, for example:</p>
<ul>
<li>Get text as input via the <em>standard input</em> and output HTML
via the <em>standard output</em></li>
<li>Receive two file names as <em>command-line arguments</em>, read the contents
of the first one, and write the output to the second one</li>
<li>Ask for some fancier command-line arguments parsing and prefix
the file with a flag saying what they are</li>
<li>Some fancy GUI interface</li>
<li>Combination of all of the above</li>
</ul>
<p>To make this interesting, we will start with the following interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
<p>In a later chapter, we will add a little fancier command-line interface
using a library, and also read whole directories and not single files.</p>
<p>But first, we need to learn a bit about I/O in Haskell, what makes
it special, and why it's a bit different from other programming languages.</p>
<h2 id="purely-functional"><a class="header" href="#purely-functional">Purely functional</a></h2>
<p>Originally, Haskell was designed in order to become an <em>open standard</em>
functional programming language with <strong>non-strict semantics</strong>, to serve
as a unifying language for future research in functional language design.</p>
<p>In GHC Haskell, we use a <em>lazy evaluation strategy</em> to implement non-strict
semantics (We've talked about laziness
<a href="05-glue/../04-markup/02-parsing_01.html#laziness">before</a>).</p>
<p>The requirement for non-strict semantics raises an interesting challenge:
How do we design a language that can do more than just evaluate expressions,
how do we model interaction with the outside world, how do we do I/O?</p>
<p>The challenge with doing I/O operations in a language with a lazy evaluation strategy
is that as programs grow larger, the order of evaluation becomes less trivial to
figure out. Consider this hypothetical code example
(which won't actually type-check in Haskell, we'll see why soon):</p>
<pre><code class="language-hs">addWithInput :: Int -&gt; Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
</code></pre>
<p>This hypothetical program will read 2 integers from the standard input,
and then will subtract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language
we expect the order of operations to to happen from the top-down.</p>
<p>But in a lazy language we don't actually evaluate an expression until
it is needed, and so neither <code>result1</code> nor <code>result2</code> are evaluated
until we wish to print the result of subtracting one from the other,
and then when we try to evaluate <code>-</code>, it requires to evaluate the two arguments
in order from left to right, so we first evaluate <code>result2</code>.</p>
<p>Evaluating <code>result2</code>, with substitution, means to replace occurrences of <code>n</code>
with the input <code>2</code>, and then evaluate the top level function (<code>+</code>), which is a
primitive function. We then evaluate its arguments, <code>readIntFromStdin</code>
and then <code>n</code>; at this point <em>we are reading the first integer from the stdin</em>.</p>
<p>After calculating the result, we can move to evaluate <code>result1</code>, in which,
during evaluation, <em>will read the second integer from stdin</em>. This is the
complete opposite of what we wanted!</p>
<p>Issues like these make lazy evaluation hard to work with in the presence of
<strong>side effects</strong> - when the evaluation of an expression <em>can affect or be affected
by the outside world</em>, this includes reading/writing from mutable memory
or performing I/O operations.</p>
<p>We call functions that has side-effects such as <code>addWithInput</code> <strong>impure functions</strong>.
And an unfortunate consequence of impure functions is that
<strong>they can return different results even when they takes the same input</strong>.</p>
<p>The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use <em>equational reasoning</em> to understand programs.</p>
<p>Therefore, in Haskell, it was decided to only allow <strong>pure</strong> functions and expressions - ones that
have <em>no side effects</em>. Pure functions will <em>always</em> return the same output (given the same input)
and <strong>evaluating pure expressions is deterministic</strong>.</p>
<p>But now, how can we do input/output operations? There are many possible solutions
for the design space - for Haskell it was decided to design a first class interface
with an accompanied type called <code>IO</code>. <code>IO</code>'s interface will force a distinction
from non-I/O expressions, and will also require that in order to combine
multiple <code>IO</code> operations, we will have to determine the order between them.</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p><code>IO</code> is an opaque type, like our <code>Html</code> type in which we hid its internal
representation from the user behind an interface. But in this case <code>IO</code> is a
built-in type that is hidden by the Haskell language rather than a module.</p>
<p><code>IO</code> has a payload type like <code>Maybe</code> has which represents the
result of an <code>IO</code> operation/action/computation.
When there isn't a meaningful result, we use the unit type,
<code>()</code> (which only has one value: <code>()</code>) to represent that.</p>
<p>Here are a few <code>IO</code> operations and functions that return <code>IO</code> operations:</p>
<pre><code class="language-hs">putStrLn :: String -&gt; IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -&gt; IO (Maybe String)

writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html) module.
which is shipped with `base`. -->
<p>Notice that each function returns an <code>IO &lt;something&gt;</code>, but what does that mean?</p>
<p>The meaning behind <code>IO a</code> is that it is a <em>description of a program (or subroutine)
that when executed will produce some value of type <code>a</code>, and may do some I/O effects
during execution</em>.</p>
<p>Executing an <code>IO a</code> is different from evaluating it.
Evaluating an <code>IO a</code> expression is pure - the <strong>evaluation</strong> will always reduce to
the same <strong>description</strong> of a program. This helps us keep purity and equational reasoning!</p>
<p>The Haskell runtime will <em>execute</em> the entry point to the program
(the expression <code>main</code>, that must have the type <code>IO ()</code>) in order for our IO operation
to also run it has to be <em>combined into</em> the <code>main</code> expression - let's see what that means.</p>
<h2 id="combining-io-expressions"><a class="header" href="#combining-io-expressions">Combining IO expressions</a></h2>
<p>Just like our <code>Html.Structure</code> type, the IO interface provides <strong>combinators</strong> for composing
small <code>IO</code> operations into bigger ones. This interface also makes sure that the order
of operations is well defined!</p>
<p>Note that, just like with <code>&lt;&gt;</code> we've defined for <code>Html.Structure</code>, the combinators for <code>IO</code>
are implemented as <strong>type-class instances</strong> rather than specialized variants
(for example our <code>append_</code> function was a specialized version of <code>&lt;&gt;</code> tailored only
for <code>Structure</code>).</p>
<p>In this section I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.</p>
<h3 id=""><a class="header" href="#">&gt;&gt;=</a></h3>
<p>Our first combinator is <code>&gt;&gt;=</code> (pronounced bind), and is the most useful of the bunch:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>This combinator takes two arguments, the first is an IO operation, and the second is
a function that <em>takes as input the result of the first IO operation</em> and returns
a new <code>IO b</code> which is the final result.</p>
<p>Here are a few examples using the functions we described above:</p>
<ol>
<li>
<p>Echo</p>
<pre><code>getLine &gt;&gt;= (\line -&gt; putStrLn line)
</code></pre>
<p>We are reading a line from the standard input on the left of <code>&gt;&gt;=</code>,
and receive the input to the left of <code>&gt;&gt;=</code>, and then write it to the
standard output. <code>&gt;&gt;=</code>'s role here is to <strong>pass the result of the IO operation
on the left to the function returning an IO operation on the right</strong>.</p>
<p>Notice how <code>&gt;&gt;=</code> <em>defines an order of operations - from left to right</em>.</p>
<p>The type of each sub expression here is:</p>
<pre><code class="language-hs">getLine :: IO String

putStrLn :: String -&gt; IO ()

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO ()

line :: String
</code></pre>
<ul>
<li>Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details></li>
</ul>
<p>Also note that this example above can be written in a more concise manner
in point free style <code>getLine &gt;&gt;= putStrLn</code>.</p>
</li>
<li>
<p>Appending two inputs</p>
<pre><code>getLine &gt;&gt;= (\honorific -&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)))
</code></pre>
<p>This subroutine combines multiple operations together, it reads two lines from
the standard input and prints a greeting.
Note that:</p>
<ul>
<li>Using <code>&gt;&gt;=</code> defines the order of operation from left to right</li>
<li>Because of the scoping rules in Haskell, <code>honorific</code> will be in scope
in the body of the function for which it is its input, including the most inner function</li>
</ul>
<p>This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read:</p>
<pre><code>getLine &gt;&gt;= \honorific -&gt;
  getLine &gt;&gt;= \name -&gt;
    putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)
</code></pre>
</li>
</ol>
<p>Let's see a few more combinators!</p>
<h3 id="-and"><a class="header" href="#-and">*&gt; and &gt;&gt;</a></h3>
<pre><code class="language-hs">(*&gt;) :: IO a -&gt; IO b -&gt; IO b
(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b
</code></pre>
<p><code>*&gt;</code> and <code>&gt;&gt;</code> have the same type signature for <code>IO</code> and mean the same thing,
in fact, <code>*&gt;</code> is a slightly more generalized version of <code>&gt;&gt;</code> and can always
be used instead of <code>&gt;&gt;</code>, which only still exists to avoid breaking backward
compatibility.</p>
<p><code>*&gt;</code> for <code>IO</code> means run the first IO operation, discard the result
then run the second operation. It can be implemented using <code>&gt;&gt;=</code>:</p>
<pre><code>a *&gt; b = a &gt;&gt;= \_ -&gt; b
</code></pre>
<p>This combinator is useful when we want to run several <code>IO</code> operations one after
the other that might not return anything meaningful, such as <code>putStrLn</code>:</p>
<pre><code>putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;
</code></pre>
<h3 id="pure-and-return"><a class="header" href="#pure-and-return">pure and return</a></h3>
<pre><code class="language-hs">pure :: a -&gt; IO a
</code></pre>
<p>like <code>*&gt;</code> and <code>&gt;&gt;</code>, <code>pure</code> is a more general version of <code>return</code>. <code>pure</code> also has the
advantage of not having a resemblance to an unrelated keyword in other languages.</p>
<p>Remember that we said <code>IO a</code> is description of a program
that when executed will produce some value of type <code>a</code> and may do some I/O effects
during execution?</p>
<p>With <code>pure</code>, we can build an <code>IO a</code> that does no I/O, and will produce a
specific value of type <code>a</code>, the one we supply to <code>pure</code>!</p>
<p>This function is useful when we want to do some uneffectful computation that depends on <code>IO</code>.</p>
<p>For example:</p>
<pre><code class="language-hs">confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt;
          putStrLn &quot;Invalid response. use y or n&quot; *&gt;
            confirm
</code></pre>
<p>Trying to return just <code>True</code> or <code>False</code> here wouldn't work because of the
type of <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>The right side of <code>&gt;&gt;=</code> in our code example (<code>\answer -&gt; case ...</code>) must
be of type <code>String -&gt; IO Bool</code>. This is because:</p>
<ol>
<li><code>getLine :: IO String</code>, so the <code>a</code> in the type signature of <code>&gt;&gt;=</code>
should be the same as <code>String</code> in this instance, and</li>
<li><code>confirm :: IO Bool</code>, so <code>b</code> should be <code>Bool</code></li>
</ol>
<h3 id="fmap-and-"><a class="header" href="#fmap-and-">fmap and &lt;$&gt;</a></h3>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>&lt;$&gt;</code> is the infix version of <code>fmap</code>. Use it at your discretion.</p>
<p>What if we wanted to write a function that reads a line from stdin
and returns it with <code>!</code> at the end? We could write it using a combination
of <code>&gt;&gt;=</code> and <code>pure</code>:</p>
<pre><code>getLine &gt;&gt;= \line -&gt; pure (line ++ &quot;!&quot;)
</code></pre>
<p>The pattern is unified to the <code>fmap</code> function:</p>
<pre><code>fmap (\line -&gt; line ++ &quot;!&quot;) getLine
</code></pre>
<p>What <code>fmap</code> does is apply a function to the value to be returning
from the <code>IO</code> operation, also known as &quot;mapping&quot; over it.</p>
<p>(By the way, Have you noticed the similarities between <code>fmap</code> and <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>?)</p>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<p>Here's a list of <code>IO</code> combinators we ran into:</p>
<pre><code class="language-hs">-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced &quot;bind&quot;.
(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b

-- sequence two IO operations, discarding the payload of the first.
(*&gt;) :: IO a -&gt; IO b -&gt; IO b

-- &quot;lift&quot; a value into IO context, does not add any I/O effects.
pure :: a -&gt; IO a

-- &quot;map&quot; (or apply a function) over the payload value of an IO operation.
fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<h2 id="io-is-first-class"><a class="header" href="#io-is-first-class">IO is first class</a></h2>
<p>The beauty of <code>IO</code> is that it's a completely first-class construct in the language,
and is not really different from <code>Maybe</code>, <code>Either</code> or <code>Structure</code>. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without combining it into <code>main</code> in some way won't actually
<em>do</em> anything. It is just a value!</p>
<p>Here's an example of a function that takes IO actions as input:</p>
<pre><code class="language-hs">whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
<p>And how it can be used:</p>
<pre><code class="language-hs">main :: IO ()
main =
  putStrLn &quot;This program will tell you a secret&quot; *&gt;
    whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt;
      putStrLn &quot;Bye&quot;
</code></pre>
<p>Notice how <code>putStrLn &quot;IO is actually pretty awesome&quot;</code> isn't executed
right away, but only if it is what <code>whenIO</code> returns, and in turn is <em>combined</em>
with <code>*&gt;</code> as part of the <code>main</code> expression.</p>
<h2 id="getting-out-of-io"><a class="header" href="#getting-out-of-io">Getting out of IO?</a></h2>
<p>What we've seen above has great consequences to the Haskell language.
In our <code>Html</code> type, we had a function <code>render :: Html -&gt; String</code>
that could turn an <code>Html</code> to a string value.</p>
<p>In Haskell, <strong>there is no way</strong> to implement a function such as <code>execute :: IO a -&gt; a</code>
in a way that preserves purity and equational reasoning!</p>
<p>Also, <code>IO</code> is <em>opaque</em>, it does not let us examine it. So we are really bound
to what the Haskell API for <code>IO</code> allows us to do.</p>
<p>This means that <strong>we need to think about using IO differently</strong>!</p>
<p>In Haskell, once we get into <code>IO</code>, there is no getting out.
The only thing we can do is build bigger IO computations by <em>combining</em>
it with more IO computations.</p>
<p>We also can't use <code>IO a</code> in place of an <code>a</code>, so for example,
we can't write <code>getLine ++ &quot;!&quot;</code> because <code>++</code> expects both
sides to be Strings, and <code>getLine</code>'s type is <code>IO String</code>. The types do not match!
We have to use <code>fmap</code> and the return type must be <code>IO String</code>, like we've seen before.</p>
<p>In Haskell we like to keep <code>IO</code> usage minimal, and we like to push it to the edges
of the program. This pattern is often called <em>Functional core, imperative shell</em>.</p>
<h2 id="functional-core-imperative-shell"><a class="header" href="#functional-core-imperative-shell">Functional core, imperative shell</a></h2>
<p>In our blog generator program, we want to read a file, parse it, and convert it to HTML,
and then print the result to the console.</p>
<p>In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the HTML conversion. But we don't mix these here.
Parsing operates on a <code>String</code> value rather than some file handle,
and <code>Html</code> is being converted to a <code>String</code> rather than being written to the screen directly.</p>
<p>This approach of separating <code>IO</code> and pushing it to the edge of the program gives us
a lot of flexibility. These functions without <code>IO</code> are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular and can work in many contexts (reading from stdin,
reading from network socket, writing to an HTTP connection, and more).</p>
<p>This pattern is often a good approach for building Haskell programs, especially
batch programs.</p>
<h2 id="building-a-blog-generator"><a class="header" href="#building-a-blog-generator">Building a blog generator</a></h2>
<p>We'd like to start building a blog generator, and we want to have the following
interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name which we will read, and the second one
will be the output file name to which we will write</li>
<li>If the output file already exists, we'll ask the user if they want
to override the file</li>
<li>On any other kind of input, we'll output a generic message explaining
the usage as we described above</li>
</ol>
<p>We are going to need a few functions:</p>
<pre><code class="language-hs">getArgs :: IO [String] -- Get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -&gt; IO String -- Read all of the content from a file

writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file

doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists
</code></pre>
<p>And the following imports:</p>
<pre><code class="language-hs">import System.Directory (doesFileExist)
import System.Environment (getArgs)
</code></pre>
<p>We don't need to add the following import because <code>Prelude</code> already imports
these functions for us:</p>
<pre><code class="language-hs">-- imported by Prelude
import System.IO (getContents, readFile, writeFile)
</code></pre>
<hr />
<ol>
<li>
<p>Implement a function <code>process :: Title -&gt; String -&gt; String</code> which will parse
a document to markup, convert it to HTML, and then render the HTML to a string.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
</li>
<li>
<p>Try implementing the &quot;imperative shell&quot; for our blog generator program.
Start with <code>main</code>, pattern match on the result of <code>getArgs</code>, and decide what to
do. Look back at the examples above for inspiration.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main =
  getArgs &gt;&gt;= \args -&gt;
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] -&gt;
        getContents &gt;&gt;= \content -&gt;
          putStrLn (process &quot;Empty title&quot; content)

      -- With input and output file paths as program arguments
      [input, output] -&gt;
        readFile input &gt;&gt;= \content -&gt;
          doesFileExist output &gt;&gt;= \exists -&gt;
            let
              writeResult = writeFile output (process input content)
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ -&gt;
        putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="do-notation"><a class="header" href="#do-notation">Do notation</a></h2>
<p>While using <code>&gt;&gt;=</code> to chain <code>IO</code> actions is manageable, Haskell provides
an even more convenient syntactic sugar called <em>do notation</em>
which emulates imperative programming.</p>
<p>A <em>do block</em> starts with the <code>do</code> keyword, and continues with one or more
&quot;statements&quot; which can be one of the following:</p>
<ol>
<li>An expression of type <code>IO ()</code>, such as:
<ul>
<li><code>putStrLn &quot;Hello&quot;</code></li>
<li><code>if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot;</code></li>
</ul>
</li>
<li>A let block, such as
<ul>
<li><code>let x = 1</code></li>
<li>or multiple let declarations:
<pre><code class="language-hs">let
  x = 1
  y = 2
</code></pre>
Note that we do not write the <code>in</code> here.</li>
</ul>
</li>
<li>A binding <code>&lt;variable&gt; &lt;- &lt;expresion&gt;</code>, such as
<pre><code class="language-hs">line &lt;- getLine
</code></pre>
</li>
</ol>
<p>And the last &quot;statement&quot; must be an expression of type <code>IO &lt;something&gt;</code> -
this will be the result type of the do block.</p>
<p>These constructs are desugared (translated) by the Haskell compiler to:</p>
<ol>
<li><code>&lt;expression&gt; *&gt;</code>,</li>
<li><code>let ... in</code> and</li>
<li><code>&lt;expression&gt; &gt;&gt;= \&lt;variable&gt;</code></li>
</ol>
<p>respectively.</p>
<p>For example:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting = do
  putStrLn &quot;Tell me your name.&quot;
  let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
  name &lt;- getLine
  putStrLn (greet name)
</code></pre>
<p>Is just syntactic sugar for:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting =
  putStrLn &quot;Tell me your name.&quot; *&gt;
    let
      greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
    in
      getLine &gt;&gt;= \name -&gt;
        putStrLn (greet name)
</code></pre>
<p>It's important to note the difference between <code>let</code> and <code>&lt;-</code> (bind).
<code>let</code> is used to give a new name to an expression which will be in scope
for subsequent lines, and <code>&lt;-</code> is used to bind the result <code>a</code> in an <code>IO a</code>
action to a new name which will be in scope for subsequent lines.</p>
<table>
  <tr>
    <th>code</th>
    <th>operator</th>
    <th>type of the left side</th>
    <th>type of the right side</th>
    <th>comment</th>
  </tr>
  <tr>
    <td><pre><pre>let gretting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>Both sides are interchangeable</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>We just create a new name for <code>getLine</code></td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>
  </tr>
</table>
<p>Do notation is very very common and is often preferable to using <code>&gt;&gt;=</code> directly.</p>
<hr />
<ol>
<li>
<p>Exercise: Translate the examples in this chapter to <em>do notation</em>.</p>
</li>
<li>
<p>Exercise: Translate our glue code for the blog generator to <em>do notation</em>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main = do
  args &lt;- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -&gt; do
      content &lt;- getContents
      putStrLn (process &quot;Empty title&quot; content)

    -- With input and output file paths as program arguments
    [input, output] -&gt; do
      content &lt;- readFile input
      exists &lt;- doesFileExist output
      let
        writeResult = writeFile output (process input content)
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ -&gt;
      putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm = do
  putStrLn &quot;Are you sure? (y/n)&quot;
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. use y or n&quot;
      confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>In this chapter we discussed what &quot;purely functional&quot; means,
where the initial motivation for being purely functional came from,
and how Haskell's I/O interface allows us to create descriptions of programs
without breaking purity.</p>
<p>We have also achieved a major milestone. With this chapter, we implemented
enough pieces that we can finally run our program on a single document
and get an HTML rendered result!</p>
<p>However, our command-line interface is still sub-par. We want to render a blog
with multiple articles, create an index page, and more. We still have more to do
to be able to call our program a blog generator.</p>
<p>Let's keep going!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/e5c2f0ea5792892207421dbdbf41d921b0c0a84b">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/e5c2f0ea5792892207421dbdbf41d921b0c0a84b">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-project-description"><a class="header" href="#defining-a-project-description">Defining a project description</a></h1>
<p>Up until now we've only used <code>base</code> and the libraries
<a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/9.0.1-notes.html#included-libraries">included</a>
with GHC. Because of that we didn't really need to do anything more fancy
than <code>runghc</code> to run our program. However, we want to start using
external libraries which are not included with GHC in our programs.</p>
<p>External packages can be downloaded from <a href="https://hackage.haskell.org/">Hackage</a> -
Haskell's central package archive, <a href="https://www.stackage.org/">Stackage</a> -
a subset of Hackage packages that are known to work together, or even
from remote git repositories. Usually Haskellers use a <strong>package manager</strong> to
download and manage packages for different projects. The most popular package
managers for Haskell are <a href="https://cabal.readthedocs.io">cabal</a> and
<a href="https://haskellstack.org">stack</a>.</p>
<p>A major difference between the two tools is their philosophy.
<code>cabal</code> tries to be a more minimalist tool that handles building Haskell projects,
doing package management using the whole of Hackage, and uses complicated algorithms
to make sure packages work together.
<code>stack</code> tries to be a more maximalistic tool that handles installing the right GHC
for each project, provides integration with external tools like hoogle,
and lets the user choose which 'set' of packages (including their versions) they want to use.</p>
<p>If you've installed Haskell using GHCup, you most likely have <code>cabal</code> installed.
If you've installed Haskell using stack, well, you have <code>stack</code> installed.
Check the <a href="https://www.haskell.org/downloads/">haskell.org downloads page</a> if that's not the case.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>Using external packages can be done in multiple ways.
For quick experimentation, we can just
<a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools#using-external-packages-in-ghci">ask stack or cabal</a>
to build or even run our program with external packages.
But as programs get larger, use more dependencies, and require more functionality,
it is better to just <strong>create a project description</strong> for our programs and even libraries.</p>
<p>Describing packages is done in a <strong>cabal file</strong>. We can ask cabal or stack
to generate one for use using <code>cabal init --libandexe</code> or <code>stack new</code>,
along with many other files, but we will likely need to edit the file by hand
later so let's just paste some sort of an initial example and then edit it.</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                name should match with &lt;name&gt;.cabal
version:             version should use PvP
synopsis:            Synopsis will appear in the hackage package listing and search
description:         The description will appear at the top of a library
homepage:            Homepage url
bug-reports:         issue-tracker url
license:             License name
license-file:        License file
author:              Author name
maintainer:          Maintainer email
category:            Hackage categories, separated by commas
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , &lt;package-name&gt;
  ghc-options:
    -O
</code></pre>
<p>Let's break it down to a few parts, the
<a href="05-glue/03-project.html#package-metadata">package metadata</a>,
<a href="05-glue/03-project.html#common-settings">common settings</a>,
<a href="05-glue/03-project.html#library">library</a> and
<a href="05-glue/03-project.html#executable">executable</a>.</p>
<h3 id="package-metadata"><a class="header" href="#package-metadata">Package metadata</a></h3>
<p>The first part should be fairly straightforward from the comments, maybe except for:</p>
<ul>
<li><code>cabal-version</code>: Defines which cabal versions can build this project. We've specified 2.4 and above.
<a href="https://cabal.readthedocs.io/en/3.6/file-format-changelog.html">More info on different versions</a>.</li>
<li><code>name</code>: The name of your library and package. Must match with the .cabal filename. Usually starts with a lowercase. <a href="https://hackage.haskell.org/packages/search?terms=name">Check if your package name is already taken on Hackage</a>.</li>
<li><code>version</code>: Some Haskell packages use <a href="https://semver.org/">semver</a>, most use <a href="https://pvp.haskell.org/">PvP</a>.</li>
<li><code>license</code>: Most Haskell packages use <a href="https://choosealicense.com/licenses/bsd-3-clause/">BSD-3-Clause</a>. <a href="https://neilmitchell.blogspot.com/2018/08/licensing-my-haskell-packages.html">Neil Mitchell blogged about this</a>. You can find more licenses if you'd like at <a href="https://choosealicense.com">choosealicense.com</a>.</li>
<li><code>extra-doc-files</code>: Include extra doc files here, such as <code>README</code> or <code>CHANGELOG</code>.</li>
</ul>
<p>Let's fill this with the metadata of our project:</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parser for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md
</code></pre>
<h3 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h3>
<p>Cabal package descriptions can include multiple &quot;targets&quot;: libraries, executables,
and test suites. Since Cabal 2.2, we can use
<a href="https://cabal.readthedocs.io/en/3.6/cabal-package.html#common-stanzas">common stanzas</a>
to group settings to be shared between different targets, so we don't have to repeat them for each target.</p>
<p>In our case we've created a new common stanza (or block) called <code>common-settings</code> and
defined the default language (Haskell has two standards, 98 and 2010),
and instructed GHC to compile with <code>-Wall</code>.</p>
<pre><code class="language-cabal">common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall
</code></pre>
<p>Later, in our targets' descriptions, we can add <code>import: common-settings</code> ,
and all of these settings will be automatically added.</p>
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<p>In a <code>library</code> target, we define:</p>
<ul>
<li>The settings with which to build the library (in this case we just import <code>common-settings</code>)</li>
<li>The directory in which the source files can be found</li>
<li>The packages we require to build the library</li>
<li>The modules exposed from the library and can be used by others</li>
<li>The modules <em>not</em> exposed from the library and which <em>cannot</em> be used by others;
these could be any module you don't wish to export, such as an internal utility
functions module.
In our case we don't have anything like this, so we commented out the <code>other-modules</code>
label.</li>
</ul>
<p>Note that it is common to specify <strong>version bounds</strong> for packages.
Version bounds specify <em>which package versions this library works with</em>.
These can also be generated using cabal with the <code>cabal gen-bounds</code> command.</p>
<pre><code class="language-cabal">library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:
</code></pre>
<p>Also note that we've added an additional <em>hierarchy</em> for our modules and defined
a different source directory. This means we will need to move the files around
a bit and change the <code>module</code> name in each file and the <code>import</code> statements. This is to avoid
conflict with other packages that a user might import.</p>
<hr />
<p>Do this now.</p>
<details><summary>Solution</summary>
<ol>
<li>
<p><code>Main.hs</code> -&gt; <code>src/HsBlog.hs</code></p>
<pre><code class="language-hs">module HsBlog
  ( main
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)
</code></pre>
</li>
<li>
<p><code>Convert.hs</code> -&gt; <code>src/HsBlog/Convert.hs</code></p>
<pre><code class="language-hs">module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
</code></pre>
</li>
<li>
<p><code>Html.hs</code> -&gt; <code>src/HsBlog/Html.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html
...

import HsBlog.Html.Internal
</code></pre>
</li>
<li>
<p><code>Html/Internal.hs</code> -&gt; <code>src/HsBlog/Html/Internal.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html.Internal where
</code></pre>
</li>
<li>
<p><code>Markup.hs</code> -&gt; <code>src/HsBlog/Markup.hs</code></p>
<pre><code class="language-hs">module HsBlog.Markup
</code></pre>
</li>
</ol>
</details>
<hr />
<h3 id="executable"><a class="header" href="#executable">Executable</a></h3>
<p>We have separated our code into two sections: a library and an executable, why?</p>
<p>First, libraries can be used by others. If we publish our code and someone wants to
use it and build upon it, they can. Executables can't be imported by other projects.
Second, we can write unit tests for libraries. It is usually
benefitical to write most, if not all, of our logic as a library, and provide
a thin executable over it.</p>
<p>Executables' descriptions are very similar to libraries, here we define:</p>
<ul>
<li>The name of the executable</li>
<li>Where the source directory for this application is</li>
<li>Which file is the 'Main' file</li>
<li>Import our library, which is named <code>hs-blog</code></li>
<li>Add additional flag for GHC: <code>-O</code> to compile with optimizations</li>
</ul>
<pre><code class="language-cabal">executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We can write many executables descriptions. In this case we only need one.</p>
<hr />
<p><strong>Exercise</strong>: Add a new file: <code>app/Main.hs</code> which imports <code>HsBlog</code> and runs <code>main</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- app/Main.hs

module Main where

import qualified HsBlog

main :: IO ()
main = HsBlog.main
</code></pre>
</details>
<hr />
<h3 id="test-suites"><a class="header" href="#test-suites">Test-suites</a></h3>
<p><code>test-suite</code> defines a target for running package tests. We will get back to it
in a later chapter.</p>
<h2 id="our-complete-cabal-file"><a class="header" href="#our-complete-cabal-file">Our complete .cabal file</a></h2>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parser for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We'll also add a <code>README.md</code> file and a <code>LICENSE.txt</code> file:</p>
<details><summary>README.md</summary>
<p>Just write whatever you want here:</p>
<pre><code class="language-md"># hs-blog

One day it will be a static blog generator.

[Read the book](https://lhbg-book.link).
</code></pre>
</details>
<details><summary>LICENSE.txt</summary>
<p>This is BSD-3-Clause with me as the author. Please write your own name for your projects :)</p>
<pre><code>BSD 3-Clause License

Copyright (c) 2021-2022, Gil Mizrahi
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</code></pre>
</details>
<h2 id="cabalproject-and-stackyaml"><a class="header" href="#cabalproject-and-stackyaml"><code>cabal.project</code> and <code>stack.yaml</code></a></h2>
<p>The <a href="https://cabal.readthedocs.io/en/3.6/cabal-project.html">cabal.project</a> and
<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#project-specific-config">stack.yaml</a>
files are used by <code>cabal</code> and <code>stack</code> respectively to add additional information on <em>how
to build the package</em>. While <code>cabal.project</code> isn't necessary to use <code>cabal</code>, <code>stack.yaml</code>
is necessary in order to use <code>stack</code>, so we will cover it briefly.</p>
<p>There are two important fields a <code>stack.yaml</code> file must have:</p>
<ul>
<li><code>resolver</code>: Describes which snapshot to use for packages and ghc version.
We will choose the latest (at time of writing) on the <code>lts</code> branch: <code>lts-18.22</code>.
Visit <a href="https://www.stackage.org/lts-18.22">this link</a> to find out which packages this
snapshot includes, what their versions are, and which GHC version is used
with this snapshot.</li>
<li><code>packages</code>: Describes the location of packages we plan to build. In our case
we have only one and it can be found in the current directory.</li>
</ul>
<p>We'll add <code>stack.yaml</code> to our project directory:</p>
<pre><code class="language-yaml">resolver: lts-18.22

packages:
- .
</code></pre>
<p>For additional options and configurations, please consult the relevant user guides.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Now, instead of manually running <code>runghc Main.hs</code>, we will use either <code>stack</code>
or <code>cabal</code> to build and run our program and package (I mostly use stack, but it's up to you).</p>
<h3 id="for-cabal"><a class="header" href="#for-cabal">For cabal:</a></h3>
<p>Building the project - on the first run, cabal will download the package dependencies
and use the GHC on PATH to build the project.</p>
<p>Cabal caches packages between projects, so if a new project uses the same packages
with the same versions (and the same flag settings) they will not need to be reinstalled.
<code>cabal</code> commands are usually prefixed with <code>v2-</code> to note that we want to use the new
build system implementation.</p>
<blockquote>
<p>In older version of cabal, packages could be installed either globally, or in sandboxes.
In each sandbox (and globally) there could only be one version of a package installed,
and users would usually create different sandboxes for different projects, without caching
packages between projects.</p>
<p>With the new build system implementation, multiple versions of the same package can be
installed globally, and for each project cabal will (try to) choose a specific version for each
package dependency such that they all work together, without needing sandboxing.
This change helps us increase sharing of built packages while avoiding conflicts and manual
handling of sandboxes.</p>
</blockquote>
<p>A few important commands we should be familiar with:</p>
<pre><code class="language-sh">cabal v2-update
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-update"><code>v2-update</code></a>
fetches information from remote package repositories (specifically Hackage unless specified otherwise)
and updates the local package index which includes various information about available packages such as
their names, versions and dependencies.</p>
<p>Usually the first command to run before fetching package dependencies.</p>
<pre><code class="language-sh">cabal v2-build
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-build"><code>v2-build</code></a>
compiles the various targets (such as <code>library</code> and <code>executable</code>s).
It will also fetch and install the package dependencies when they're not already installed.</p>
<pre><code class="language-sh">cabal v2-run hs-blog-gen -- &lt;program arguments&gt;
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-run"><code>v2-run</code></a>
Can be used to compile and then run a target (in our case our <code>executable</code> which we named <code>hs-blog-gen</code>).
We separate arguments passed to <code>cabal</code> and arguments passed to our target program with <code>--</code>.</p>
<pre><code class="language-sh">cabal v2-repl hs-blog
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-repl"><code>v2-repl</code></a>
runs <code>ghci</code> in the context of the target (in our case our <code>library</code> which we named <code>hs-blog</code>) -
it will load the target's package dependencies and modules to be available in <code>ghci</code>.</p>
<pre><code class="language-sh">cabal v2-clean
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html#cabal-v2-clean"><code>v2-clean</code></a>
Deletes the build artifacts that we built.</p>
<p>There are more interesting commands we could use, such as <code>cabal v2-freeze</code> to generate
a file which records the packages versions and flags we used to build this project,
and <code>cabal v2-sdist</code> to bundle the project source to a package tarball which can be
uploaded to Hackage. If you'd like to learn more visit the
<a href="https://cabal.readthedocs.io/en/3.6/cabal-commands.html">Cabal user guide</a>.</p>
<h3 id="for-stack"><a class="header" href="#for-stack">For stack:</a></h3>
<p>Building the project - on the first run, stack will install the right GHC for this project
which is specified by the <code>resolver</code> field in the <code>stack.yaml</code> file,
download the package dependencies, and compile the project.</p>
<p>Stack caches these installations between projects that use the same resolver,
so future projects with the same resolver and future runs of this project won't
require reinstallation. This approach is kind of a middle ground between full packages
sharing and sandboxes.</p>
<p>Let's look at the (somewhat) equivalent commands for Stack:</p>
<pre><code class="language-sh">stack build
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/build_command/#build-command"><code>build</code></a>
will compile the project as described above - installing GHC and package dependencies if they are not
installed.</p>
<pre><code class="language-sh">stack exec hs-blog-gen -- &lt;program arguments&gt;
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/GUIDE/#stack-exec"><code>exec</code></a>
will run the executable passing the program arguments to our executable.</p>
<pre><code class="language-sh">stack ghci hs-blog
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/ghci/#ghci"><code>ghci</code></a>
runs <code>ghci</code> in the context of our library <code>hs-blog</code> - loading the library modules
and packages.</p>
<pre><code class="language-sh">stack clean
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/GUIDE/#cleaning-your-project"><code>clean</code></a>
cleans up build artifacts.</p>
<p>The <a href="https://docs.haskellstack.org/en/stable/GUIDE/">Stack user guide</a> contains more
information about how stack works and how to use it effectively.</p>
<h3 id="build-artifacts"><a class="header" href="#build-artifacts">Build artifacts</a></h3>
<p>Both stack and cabal create build artifacts that we will not want to track using
our version control. These build artifacts are found in the <code>dist</code>, <code>dist-newstyle</code>
and <code>.stack-work</code> directories. We can add these to a <code>.gitignore</code> file
(or similar for other version control programs) to ignore them:</p>
<pre><code class="language-txt">dist
dist-newstyle
.stack-work
</code></pre>
<h2 id="finding-packages"><a class="header" href="#finding-packages">Finding packages</a></h2>
<p>Finding packages isn't a very straightforward process at the moment.
People have written on
<a href="https://www.haskellforall.com/2018/05/how-i-evaluate-haskell-packages.html">how they choose packages</a>,
<a href="https://github.com/soupi/haskell-study-plan#useful-packages">recommendation</a> <a href="https://haskelliseasy.readthedocs.io/en/latest/">lists</a>, and more.</p>
<p>My suggestion is:</p>
<ul>
<li>Search for a tutorial on something you'd like to do, and see which packages come up</li>
<li>Use the download amount on Hackage as an indication of package popularity</li>
<li>Use <a href="https://www.stackage.org/lts">Stackage</a> package synopses to locate a relevant package</li>
<li>Check social network channels for recommendations, but know that sometimes people tend
to recommend inappropriate solutions and packages that might be too complicated or
still experimental</li>
</ul>
<p>It's also important to note the amount of dependencies a package has. Adding many dependencies
will affect compilation time and code size. And it can sometimes be a good thing to consider
when comparing packages, or considering whether a package is needed at all.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>We've created a package description for our library and used <code>stack</code> or/and <code>cabal</code>
to build our program. In future chapters we'll start adding external packages,
we'll only have to add them to the <code>build-depends</code> section in the cabal file and
our package manager will download and install the required package for us!</p>
<p>We've made some change to our project directory, and it should now look like this:</p>
<pre><code>.
âââ app
âÂ Â  âââ Main.hs
âââ hs-blog.cabal
âââ LICENSE.txt
âââ README.md
âââ src
âÂ Â  âââ HsBlog
âÂ Â  âÂ Â  âââ Convert.hs
âÂ Â  âÂ Â  âââ Html
âÂ Â  âÂ Â  âÂ Â  âââ Internal.hs
âÂ Â  âÂ Â  âââ Html.hs
âÂ Â  âÂ Â  âââ Markup.hs
âÂ Â  âââ HsBlog.hs
âââ stack.yaml

4 directories, 10 files
</code></pre>
<p>Note that this package format is something we could release on <a href="https://hackage.haskell.org/">Hackage</a>
for other Haskell developers to use!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/826948302d08bfa4e889cf7013b911705c965445">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/826948302d08bfa4e889cf7013b911705c965445">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fancy-options-parsing"><a class="header" href="#fancy-options-parsing">Fancy options parsing</a></h1>
<p>We'd like to define a nicer interface for our program. And while we could manage something
ourselves with <code>getArgs</code> and pattern matching, using a library for this case is easier.
We are going to use a package called
<a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>.</p>
<p><code>optparse-applicative</code> provides us with an EDSL (yes, another one) to build
command arguments parsers. Things like commands, switches, and flags can be built
and composed together to make a parser for command-line arguments without actually
writing operations on strings as we did when we wrote our Markup parser, and will
provide other benefits such as automatic generation of usage lines, help screens,
error reporting, and more.</p>
<p>While <code>optparse-applicative</code>'s dependency footprint isn't very large,
it is likely that a user of our library wouldn't need command-line parsing
in this particular case, so it makes sense to add this dependency to the <code>executable</code> section
(rather than the <code>library</code> section) in the <code>.cabal</code> file:</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
   build-depends:
       base
+    , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="building-a-command-line-parser"><a class="header" href="#building-a-command-line-parser">Building a command-line parser</a></h2>
<p>The optparse-applicative package has pretty decent
<a href="https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative">documentation</a>,
but we will cover a few important things to pay attention to in this chapter.</p>
<p>In general, there are four important things we need to do:</p>
<ol>
<li>
<p>Define our model - we want to define an ADT that describes the various options
and commands for our program.</p>
</li>
<li>
<p>Define a parser that will produce our value of our model type when run</p>
</li>
<li>
<p>Run the parser on our program arguments input</p>
</li>
<li>
<p>Pattern match on the model and call the right operations according to the options</p>
</li>
</ol>
<h3 id="define-a-model"><a class="header" href="#define-a-model">Define a model</a></h3>
<p>Let's envision our command-line interface for a second, what would we like it to
look like?</p>
<p>We want to be able to convert a single file or input stream and produce either a file
or an output stream, or we want to process a whole directory and create a new directory.
We can model it in an ADT like this:</p>
<pre><code class="language-hs">data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show
</code></pre>
<blockquote>
<p>Note that we could technically also use <code>Maybe FilePath</code> to encode both <code>SingleInput</code>
and <code>SingleOutput</code>, but then we would have to remember what <code>Nothing</code> meant
in each context. By creating a new type with properly named constructors
for each option we make it easier for readers of the code to understand
the meaning of our code.</p>
</blockquote>
<p>In terms of interface, we could decide that when a user would like to convert
a single input source, they would use the <code>convert</code> command, and supply the optional flags
<code>--input FILEPATH</code> and <code>--output FILEPATH</code> to read or write from a file.
When the user does not supply one or both flag, we will read or write from
the standard input/output accordingly instead.</p>
<p>If the user would like to convert a directory, they can use the <code>convert-dir</code>
command and supply the two mandatory flags <code>--input FILEPATH</code> and
<code>--output FILEPATH</code>.</p>
<h3 id="build-a-parser"><a class="header" href="#build-a-parser">Build a parser</a></h3>
<p>This is the most interesting part of the process. How do we build a parser
that fits our model?</p>
<p>The <code>optparse-applicative</code> library introduces a new type called <code>Parser</code>.
<code>Parser</code>, similar to <code>Maybe</code> and <code>IO</code>, has the kind <code>* -&gt; *</code> - when it
is supplied with a saturated (or concrete) type such as <code>Int</code>, <code>Bool</code> or
<code>Options</code>, it can become a saturated type (one that has values).</p>
<p>A <code>Parser a</code> represents a specification of a parser for a set of options
that will produce a value of type <code>a</code> when the command-line arguments are
successfully parsed.
This is a bit similar to how <code>IO a</code> represents a description of a program
that can produce a value of type <code>a</code>. The main difference between these
two types is that while we can't really convert an <code>IO a</code> to an <code>a</code>
(we just chain IO operations and have the Haskell runtime execute them),
we <em>can</em> convert a <code>Parser a</code> to a function that takes a list of strings
representing the program arguments and produces an <code>a</code> if it manages
to parse the arguments.</p>
<p>As we've seen with previous EDSLs, this library uses the <em>combinator pattern</em>
as well. We need to consider what are the basic primitives for building
a parser, and what are the methods of composing small parsers into bigger
parsers.</p>
<p>Let's see an example for a small parser:</p>
<pre><code class="language-hs">inp :: Parser FilePath
inp =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Input file&quot;
    )

out :: Parser FilePath
out =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Output file&quot;
    )
</code></pre>
<p><code>strOption</code> is a parser builder. It is a function that takes a combined
<em>option modifiers</em> as an argument, and returns a parser that will parse a string.
We can specify the type to be <code>FilePath</code> because <code>FilePath</code> is an
alias to <code>String</code>. The parser builder describes how to parse the value,
and the modifiers describe its properties, such as the flag name,
the shorthand of the flag name, and how it would be described in the usage
and help messages.</p>
<blockquote>
<p>Actually <code>strOption</code> can return any string type
that implements the interface <code>IsString</code>. There are a few such types,
such as <code>Text</code>, a much more efficient Unicode text type from the <code>text</code> package.
It is more efficient than <code>String</code> because while <code>String</code> is implemented as a
linked list of <code>Char</code>, <code>Text</code> is implemented as an array of bytes.
<code>Text</code> is usually what we should use for text values. We haven't
been using it up until now because it is slightly less ergonomic to use
than <code>String</code>. But it is often the preferred type to use for text!</p>
</blockquote>
<p>As you can see, modifiers can be composed using the <code>&lt;&gt;</code> function,
which means modifiers implement an instance of the <code>Semigroup</code> type class!</p>
<p>With such an interface we don't have to supply all the modifier
options, but only the relevant ones. So if we don't want to
have a shortened flag name, we don't have to add it.</p>
<h4 id="functor"><a class="header" href="#functor">Functor</a></h4>
<p>For the data type we've defined, having <code>Parser FilePath</code> takes us
a good step in the right direction, but it is not exactly what we need
for a <code>ConvertSingle</code>. We need a <code>Parser SingleInput</code> and a
<code>Parser SingleOutput</code>. If we had a <code>FilePath</code>, we could convert
it into <code>SingleInput</code> by using the <code>InputFile</code> constructor.
Remember, <code>InputFile</code> is also a function:</p>
<pre><code class="language-hs">InputFile :: FilePath -&gt; SingleInput
OutputFile :: FilePath -&gt; SingleOutput
</code></pre>
<p>However, to convert a parser, we need functions with these types:</p>
<pre><code class="language-hs">f :: Parser FilePath -&gt; Parser SingleInput
g :: Parser FilePath -&gt; Parser SingleOutput
</code></pre>
<p>Fortunately, the <code>Parser</code> interface provides us with a function to &quot;lift&quot;
a function like <code>FilePath -&gt; SingleInput</code> to work on parsers, making
it a function with the type <code>Parser FilePath -&gt; Parser SingleInput</code>.
Of course, this function will work for any input and output,
so if we have a function with the type <code>a -&gt; b</code>, we can pass it to
that function and get a new function of the type <code>Parser a -&gt; Parser b</code>.</p>
<p>This function is called <code>fmap</code>:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b

-- Or with its infix version
(&lt;$&gt;)  :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
</code></pre>
<p>We've seen <code>fmap</code> before in the interface of other types:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]

fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>fmap</code> is a type class function like <code>&lt;&gt;</code> and <code>show</code>. It belongs
to the type class <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>:</p>
<pre><code class="language-hs">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And it has the following laws:</p>
<pre><code class="language-hs">-- 1. Identity law:
--    if we don't change the values, nothing should change
fmap id = id

-- 2. Composition law:
--    Composing the lifted functions is the same a composing
--    them after fmap
fmap (f . g) == fmap f . fmap g
</code></pre>
<p>Any type <code>f</code> that can implement <code>fmap</code> and follow these laws can be a valid
instance of functor.</p>
<blockquote>
<p>Notice how <code>f</code> has a kind <code>* -&gt; *</code>, we can infer the kind of <code>f</code>
by looking at the other types in the type signature of <code>fmap</code>:</p>
<ol>
<li><code>a</code> and <code>b</code> have the kind <code>*</code> because they are used as arguments/return
types of functions</li>
<li><code>f a</code> has the kind <code>*</code> because it is used as an argument to a function, therefore</li>
<li><code>f</code> has the kind <code>* -&gt; *</code></li>
</ol>
</blockquote>
<p>Let's choose a data type and see if we can implement a <code>Functor</code> instance.
We need to choose a data type that has the kind <code>* -&gt; *</code>. <code>Maybe</code> fits the bill.
We need to implement a function <code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>.
Here's one very simple (and wrong) implementation:</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX = Nothing
</code></pre>
<p>check it yourself! It compiles and everything! But unfortunately it does not
satisfy the first law. <code>fmap id = id</code> means that
<code>mapMaybe id (Just x) == Just x</code>, however from the definition we can
clearly see that <code>mapMaybe id (Just x) == Nothing</code>.</p>
<p>This is a good example of how Haskell doesn't help us make sure the laws
are satisfied, and why they are important. Unlawful <code>Functor</code> instances
will behave differently than we'd expect a <code>Functor</code> to behave.
Let's try again!</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX =
  case maybeX of
    Nothing -&gt; Nothing
    Just x -&gt; Just (func x)
</code></pre>
<p>This <code>mapMaybe</code> will satisfy the functor laws. This can be proved
by doing algebra - if we can do substitution and reach the other side of the
equation in each law, then the law holds.</p>
<p>Functor is a very important type class, and many types implement this interface.
As we know, <code>IO</code>, <code>Maybe</code>, <code>[]</code> and <code>Parser</code> all have the kind <code>* -&gt; *</code>,
and all allows us to map over their &quot;payload&quot; type.</p>
<blockquote>
<p>Often people try to look for analogies and metaphors to what a type class mean,
but type classes with funny names like <code>Functor</code> don't usually have an
analogy or a metaphor that fits them in all cases. It is easier to give up
on the metaphor and think about it as it is - an interface with laws.</p>
</blockquote>
<p>We can use <code>fmap</code> on <code>Parser</code> to make a parser that returns <code>FilePath</code>
return a <code>SingleInput</code> or <code>SingleOutput</code> instead:</p>
<pre><code class="language-hs">pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>Now that we have two parsers,
<code>pInputFile :: Parser SingleInput</code>
and <code>pOutputFile :: Parser SingleOutput</code>,
we want to <em>combine</em> them as <code>Options</code>. Again, if we only had
<code>SingleInput</code> and <code>SingleOutput</code>, we could use the constructor <code>ConvertSingle</code>:</p>
<pre><code class="language-hs">ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options
</code></pre>
<p>Can we do a similar trick to the one we saw before with <code>fmap</code>?
Does a function exist that can lift a binary function to work
on <code>Parser</code>s instead? One with this type signature:</p>
<pre><code>???
  :: (SingleInput -&gt; SingleOutput -&gt; Options)
  -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)
</code></pre>
<p>Yes. This function is called <code>liftA2</code> and it is from the <code>Applicative</code>
type class. <code>Applicative</code> (also known as applicative functor) has three
primary functions:</p>
<pre><code class="language-hs">class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>
is another very popular type class with many instances.</p>
<p>Just like any <code>Monoid</code> is a <code>Semigroup</code>, any <code>Applicative</code>
is a <code>Functor</code>. This means that any type that wants to implement
the <code>Applicative</code> interface should also implement the <code>Functor</code> interface.</p>
<p>Beyond what a regular functor can do, which is to lift a function over
a certain <code>f</code>, applicative functors allow us to apply a function to
<em>multiple instances</em> of a certain <code>f</code>, as well as &quot;lift&quot; any value of type <code>a</code> into an <code>f a</code>.</p>
<p>You should already be familiar with <code>pure</code>, we've seen it when we
talked about <code>IO</code>. For <code>IO</code>, <code>pure</code> lets us create an <code>IO</code> action
that would return a specific value without doing IO.
With <code>pure</code> for <code>Parser</code>, we can create a <code>Parser</code> that when run
will return a specific value as output.</p>
<p><code>liftA2</code> and <code>&lt;*&gt;</code> are two functions that can be implemented in
terms of one another. <code>&lt;*&gt;</code> is actually the more useful one between
the two. Because when combined with <code>fmap</code> (or rather the infix version <code>&lt;$&gt;</code>),
it can be used to apply a function with many arguments over many values of the
same type which is an instance of an applicative functor.</p>
<p>To combine our two parsers to one, we can use either <code>liftA2</code> or
a combination of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>:</p>
<pre><code class="language-hs">-- with liftA2
pConvertSingle :: Parser Options
pConvertSingle =
  liftA2 ConvertSingle pInputFile pOutputFile

-- with &lt;$&gt; and &lt;*&gt;
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile
</code></pre>
<p>Note that both <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> associate to the left,
so we have invisible parenthesis that look like this:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile
</code></pre>
<p>Let's take a deeper look at the types of the sub-expressions
we have here, to prove that this type-checks:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options

pInputFile :: Parser SingleInput
pOutputFile :: Parser SingleOutput

ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options

(&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a` is `SingleInput`
  -- and `b` is `SingleOutput -&gt; Options`,

ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options)

(&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options`
  -- so `a` is `SingleOutput` and `b` is `Options`

-- So we get:
(ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options
</code></pre>
<p>With <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can chain as many parsers (or any applicative really)
as we want. This is because of two things: currying and parametric polymorphism:
Because functions in Haskell take exactly one argument and return exactly one,
any multiple argument function can be represented as <code>a -&gt; b</code>.</p>
<blockquote>
<p>You can find the laws for the applicative functors in this article called
<a href="https://wiki.haskell.org/Typeclassopedia#Laws_2">Typeclassopedia</a>, which
talks about various useful type classes and their laws.</p>
</blockquote>
<p>Applicative functors are a very important concept and will appear in various
parser interfaces (not just for command-line arguments, but also JSON
parsers and general parsers), I/O, concurrency, non-determinism, and more.
The reason this library is called optparse-applicative is because
it uses the <code>Applicative</code> interface as the main API for
constructing parsers.</p>
<hr />
<p><strong>Exercise</strong>: create a similar interface for the <code>ConvertDir</code> constructor of <code>Options</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir
</code></pre>
</details>
<hr />
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<p>One thing we forgot about is that each input and output for
<code>ConvertSingle</code> could also potentially use the standard input and output instead.
Up until now we only offered one option: reading from or writing to a file
by specifying the flags <code>--input</code> and <code>--output</code>.
However, we'd like to make these flags optional, and when they are
not specified, use the alternative standard i/o. We can do that by using
the function <code>optional</code> from <code>Control.Applicative</code>:</p>
<pre><code class="language-hs">optional :: Alternative f =&gt; f a -&gt; f (Maybe a)
</code></pre>
<p><code>optional</code> works on types which implement instances of the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a> type class:</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
  empty :: f a
</code></pre>
<p><code>Alternative</code> looks very similar to the <code>Monoid</code> type class,
but it works on applicative functors. This type class isn't
very common and is mostly used for parsing libraries as far as I know.
It provides us with an interface to combine two <code>Parser</code>s -
if the first one fails to parse, we try the other.
It also provides other useful functions such as <code>optional</code>,
which will help us with our case:</p>
<pre><code class="language-hs">pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile
</code></pre>
<p>Note that with <code>fromMaybe :: a -&gt; Maybe a -&gt; a</code> we can extract
the <code>a</code> out of the <code>Maybe</code> by supplying a value for the <code>Nothing</code> case.</p>
<p>Now we can use these more appropriate functions in <code>pConvertSingle</code> instead:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput
</code></pre>
<h4 id="commands-and-subparsers"><a class="header" href="#commands-and-subparsers">Commands and subparsers</a></h4>
<p>We currently have two possible operations in our interface,
convert a single source, or convert a directory. A nice interface for
selecting the right operation would be via commands.
If the user would like to convert a single source, they can use
<code>convert</code>, for a directory, <code>convert-dir</code>.</p>
<p>We can create a a parser with commands with the <code>subparser</code> and <code>command</code>
functions:</p>
<pre><code class="language-hs">subparser :: Mod CommandFields a -&gt; Parser a

command :: String -&gt; ParserInfo a -&gt; Mod CommandFields a
</code></pre>
<p><code>subparser</code> takes <em>command modifiers</em> (which can be constructed
with the <code>command</code> function) as input, and produces a <code>Parser</code>.
<code>command</code> takes the command name (in our case &quot;convert&quot; or &quot;convert-dir&quot;)
and a <code>ParserInfo a</code>, and produces a command modifier. As we've seen
before these modifiers have a <code>Monoid</code> instance and they can be
composed, meaning that we can append multiple commands to serve as alternatives.</p>
<p>A <code>ParserInfo a</code> can be constructed with the <code>info</code> function:</p>
<pre><code class="language-hs">info :: Parser a -&gt; InfoMod a -&gt; ParserInfo a
</code></pre>
<p>This function wraps a <code>Parser</code> with some additional information
such as a helper message, description, and more, so that the program
itself and each sub command can print some additional information.</p>
<p>Let's see how to construct a <code>ParserInfo</code>:</p>
<pre><code class="language-hs">pConvertSingleInfo :: ParserInfo Options
pConvertSingleInfo =
  info
    (helper &lt;*&gt; pConvertSingle)
    (progDesc &quot;Convert a single markup source to html&quot;)
</code></pre>
<p>Note that <code>helper</code> adds a helper output screen in case the parser fails.</p>
<p>Let's also build a command:</p>
<pre><code class="language-hs">pConvertSingleCommand :: Mod CommandFields Options
pConvertSingleCommand =
  command &quot;convert&quot; pConvertSingleInfo
</code></pre>
<p>Try creating a <code>Parser Options</code> combining the two options with <code>subparser</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )
</code></pre>
</details>
<h4 id="parserinfo"><a class="header" href="#parserinfo">ParserInfo</a></h4>
<p>Since we finished building a parser, we should wrap it up in a <code>ParserInfo</code>
and add some information to it to make it ready to run.</p>
<pre><code class="language-hs">opts :: ParserInfo Options
opts =
  info (helper &lt;*&gt; pOptions)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )
</code></pre>
<h3 id="running-a-parser"><a class="header" href="#running-a-parser">Running a parser</a></h3>
<p><code>optparse-applicative</code> provides a non-<code>IO</code> interface to parse arguments,
but the most convenient way to use it is to let it take care of fetching
program arguments, try to parse them, and throw errors and help messages in case
it fails. This can be done with the function <code>execParser :: ParserInfo a -&gt; IO a</code>.</p>
<p>We can place all this options parsing stuff in a new module
and then import it from <code>app/Main.hs</code>. Let's do that.
Here's what we have up until now:</p>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">-- | Command-line options parsing

module OptParse
  ( Options(..)
  , SingleInput(..)
  , SingleOutput(..)
  , parse
  )
  where

import Data.Maybe (fromMaybe)
import Options.Applicative

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

-- | Parse command-line options
parse :: IO Options
parse = execParser opts

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

-- | Parser for single output sink
pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
</details>
<h3 id="pattern-matching-on-options"><a class="header" href="#pattern-matching-on-options">Pattern matching on Options</a></h3>
<p>After running the command-line arguments parser, we can pattern match
on our model and call the right functions. Currently, our program
does not expose this kind of API. So let's go to our <code>src/HsBlog.hs</code>
module and change the API. We can delete <code>main</code> from that file and
add two new functions instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO.html#t:Handle"><code>Handle</code></a>
is an I/O abstraction over file system objects, including <code>stdin</code> and <code>stdout</code>.
Before, we used <code>writeFile</code> and <code>getContents</code> - these functions either
get a <code>FilePath</code> to open and work on, or they assume the <code>Handle</code> is the standard I/O.
We can use the explicit versions that take a <code>Handle</code> from <code>System.IO</code> instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)
</code></pre>
<p>We will leave <code>convertDirectory</code> unimplemented for now and implement it in the next chapter.</p>
<p>In <code>app/Main.hs</code>, we will need to pattern match on the <code>Options</code> and
prepare to call the right functions from <code>HsBlog</code>.</p>
<p>Let's look at our full <code>app/Main.hs</code> and <code>src/HsBlog.hs</code>:</p>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import OptParse
import qualified HsBlog

import System.Exit (exitFailure)
import System.Directory (doesFileExist)
import System.IO

main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output -&gt;
      HsBlog.convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            pure (&quot;&quot;, stdin)
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; pure stdout
          OutputFile file -&gt; do
            exists &lt;- doesFileExist file
            shouldOpenFile &lt;-
              if exists
                then confirm
                else pure True
            if shouldOpenFile
              then
                openFile file WriteMode
              else
                exitFailure

      HsBlog.convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle

------------------------------------------------
-- * Utilities

-- | Confirm user action
confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm
</code></pre>
</details>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">-- HsBlog.hs
module HsBlog
  ( convertSingle
  , convertDirectory
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)

import System.IO

convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory = error &quot;Not implemented&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
<p>We need to make a few small changes to the <code>.cabal</code> file.</p>
<p>First, we need to add the dependency <code>directory</code> to the <code>executable</code>,
because we use the library <code>System.Directory</code> in <code>Main</code>.</p>
<p>Second, we need to list <code>OptParse</code> in the list of modules in
the <code>executable</code>.</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
+  other-modules:
+    OptParse
   build-depends:
       base
+    , directory
     , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>We've learned about a new fancy library called <code>optparse-applicative</code>
and used it to create a fancier command-line interface in a declarative way.
See the result of running <code>hs-blog-gen --help</code>:</p>
<pre><code>hs-blog-gen - a static blog generator

Usage: hs-blog-gen COMMAND
  Convert markup files or directories to html

Available options:
  -h,--help                Show this help text

Available commands:
  convert                  Convert a single markup source to html
  convert-dir              Convert a directory of markup files to html
</code></pre>
<p>Along the way we've learned two powerful new abstractions, <code>Functor</code>
and <code>Applicative</code>. As well as revisited an abstraction we were familiar
with called <code>Monoid</code>. With this library we've seen (another) example
of the usefulness of these abstractions for constructing APIs and EDSLs.</p>
<p>We will continue to meet these abstractions in the rest of the book.</p>
<hr />
<p><strong>Bonus exercise</strong>: Add another flag named <code>--replace</code> to indicate that
if the output file or directory already exists, it's okay to replace them.</p>
<hr />
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/6efea76deb62332b23e90fc74b6b74b404fd8c3d">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/6efea76deb62332b23e90fc74b6b74b404fd8c3d">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors-and-multiple-files"><a class="header" href="#handling-errors-and-multiple-files">Handling errors and multiple files</a></h1>
<p>We have left an unimplemented function last chapter,
and there are a few more things left for us to do to actually call our program a static blog generator.
We still need to process multiple files in a directory and create an index landing page with links to other pages.</p>
<h2 id="links-in-html"><a class="header" href="#links-in-html">Links in HTML</a></h2>
<p>Our HTML EDSL currently does not support links or other content modifiers such as bold and italics.
We should add these so we can use them when creating an index.</p>
<p>Up until now we've passed <code>String</code> to <code>Structure</code> creating functions such as <code>p_</code>
and <code>h_</code>. Instead, we could create and pass them a new type, <code>Content</code>, which
can be regular text, links, images, and so on.</p>
<hr />
<p><strong>Exercise</strong>: implement what we've just discussed. Follow the compiler errors and refactor what needs refactoring.</p>
<details><summary>Solution</summary>
<details><summary>src/Html/Internal.hs</summary>
<pre><code class="language-hs">module HsBlog.Html.Internal where

import Numeric.Natural

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

newtype Content
  = Content String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Structure

p_ :: Content -&gt; Structure
p_ = Structure . el &quot;p&quot; . getContentString

h_ :: Natural -&gt; Content -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . getContentString

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape

instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)

instance Monoid Structure where
  mempty = Structure &quot;&quot;

-- * Content

txt_ :: String -&gt; Content
txt_ = Content . escape

link_ :: FilePath -&gt; Content -&gt; Content
link_ path content =
  Content $
    elAttr
      &quot;a&quot;
      (&quot;href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&quot;)
      (getContentString content)

img_ :: FilePath -&gt; Content
img_ path =
  Content $ &quot;&lt;img src=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

b_ :: Content -&gt; Content
b_ content =
  Content $ el &quot;b&quot; (getContentString content)

i_ :: Content -&gt; Content
i_ content =
  Content $ el &quot;i&quot; (getContentString content)

instance Semigroup Content where
  (&lt;&gt;) c1 c2 =
    Content (getContentString c1 &lt;&gt; getContentString c2)

instance Monoid Content where
  mempty = Content &quot;&quot;

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

elAttr :: String -&gt; String -&gt; String -&gt; String
elAttr tag attrs content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot; &quot; &lt;&gt; attrs &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString structure =
  case structure of
    Structure str -&gt; str

getContentString :: Content -&gt; String
getContentString content =
  case content of
    Content str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar


</code></pre>
</details>
<details><summary>src/Html.hs</summary>
<pre><code class="language-hs">module HsBlog.Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h_
  , ul_
  , ol_
  , code_
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
  where

import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/Convert.hs</summary>
<pre><code class="language-hs">module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n $ Html.txt_ txt

    Markup.Paragraph p -&gt;
      Html.p_ $ Html.txt_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map (Html.p_ . Html.txt_) list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map (Html.p_ . Html.txt_) list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
</details>
<hr />
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/2f867fe7ad89b962a37f9c56da4f44fa4f4b3a1c">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/2f867fe7ad89b962a37f9c56da4f44fa4f4b3a1c">code up until now</a>.</p>
</blockquote>
<h2 id="creating-an-index-page"><a class="header" href="#creating-an-index-page">Creating an index page</a></h2>
<p>With our extended HTML EDSL, we can now create an index page with links to the other pages.</p>
<p>To create an index page, we need a list of files with their <em>target destination</em>,
as well as their <code>Markup</code> (so we can extract information to include in our index page,
such as the first heading and paragraph). Our output should be an <code>Html</code> page.</p>
<hr />
<p>We need to implement the following function:</p>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup)] -&gt; Html
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 3 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
<hr />
<h2 id="processing-directories"><a class="header" href="#processing-directories">Processing directories</a></h2>
<p>Our general strategy for processing whole directories is going to be:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension, we want to process <code>txt</code> file and
copy other files without modification</li>
<li>We want to parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<p>While our parsing function can't really fail, trying to read or write a file
to the file-system can fail in several ways. It would be nice if our
static blog generator was robust enough that it wouldn't fail completely if one
single file gave it some trouble. This is a good opportunity to learn about
error handling in Haskell, both in uneffectful code and for I/O code.</p>
<p>In the next few chapters we'll survey the landscape of error handling in Haskell
before figuring out what is the right approach for our use case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors-with-either"><a class="header" href="#handling-errors-with-either">Handling errors with Either</a></h1>
<p>There are quite a few ways to indicate and handle errors in Haskell.
We are going to look at one solution: using the type
<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html">Either</a>.
Either is defined like this:</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Simply put, a value of type <code>Either a b</code> can contain either a value of type <code>a</code>,
or a value of type <code>b</code>.
We can tell them apart from the constructor used.</p>
<pre><code class="language-hs">Left True :: Either Bool b
Right 'a' :: Either a Char
</code></pre>
<p>Using this type, we can represent computations that may fail by using the
<code>Left</code> constructor to indicate failure with some error value attached,
and the <code>Right</code> constructor with one type to represent success with the
expected result.</p>
<p>Since <code>Either</code> is polymorphic, we can use any two types to represent
failure and success. It is often useful to describe the failure modes
using an ADT.</p>
<p>For example, let's say that we want to parse a <code>Char</code> as a decimal digit
to an <code>Int</code>. This operation could fail if the Character is not a digit.
We can represent this error as a data type:</p>
<pre><code class="language-hs">data ParseDigitError
  = NotADigit Char
  deriving Show
</code></pre>
<p>And our parsing function can have the type:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
</code></pre>
<p>Now when we implement our parsing function we can return <code>Left</code> on an error
describing the problem, and <code>Right</code> with the parsed value on successful parsing:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p><code>Either a</code> is also an instance of <code>Functor</code> and <code>Applicative</code>,
so we have some combinators to work with if we want to combine these
kind of computations.</p>
<p>For example, if we had three characters and we wanted to try and parse
each of them and then find the maximum between them, we could use the
applicative interface:</p>
<pre><code class="language-hs">max3chars :: Char -&gt; Char -&gt; Char -&gt; Either ParseDigitError Int
max3chars x y z =
  (\a b c -&gt; max a (max b c))
    &lt;$&gt; parseDigit x
    &lt;*&gt; parseDigit y
    &lt;*&gt; parseDigit z
</code></pre>
<p>The <code>Functor</code> and <code>Applicative</code> interfaces of <code>Either a</code> allow us to
apply functions to the payload values and <strong>delay</strong> the error handling to a
later phase. Semantically, the first Either in order that returns a <code>Left</code>
will be the return value. We can see how this works in the implementation
of the applicative instance:</p>
<pre><code class="language-hs">instance Applicative (Either e) where
    pure          = Right
    Left  e &lt;*&gt; _ = Left e
    Right f &lt;*&gt; r = fmap f r
</code></pre>
<p>At some point, someone will actually want to <strong>inspect</strong> the result
and see if we got an error (with the <code>Left</code> constructor) or the expected value
(with the <code>Right</code> constructor) and they can do that by pattern matching on the result.</p>
<h2 id="applicative--traversable"><a class="header" href="#applicative--traversable">Applicative + Traversable</a></h2>
<p>The <code>Applicative</code> interface of <code>Either</code> is very powerful, and can be combined
with another abstraction called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Traversable.html#g:1"><code>Traversable</code></a> -
for data structures that can be traversed from left to right, like a linked list or a binary tree.
With these, we can combine an unspecified amount of values such as <code>Either ParseDigitError Int</code>,
as long as they are all in a data structure that implements <code>Traversable</code>.</p>
<p>Let's see an example:</p>
<pre><code class="language-hs">ghci&gt; :t &quot;1234567&quot;
&quot;1234567&quot; :: String
-- remember, a String is an alias for a list of Char
ghci&gt; :info String
type String :: *
type String = [Char]
      -- Defined in âGHC.Baseâ

ghci&gt; :t map parseDigit &quot;1234567&quot;
map parseDigit mystring :: [Either ParseDigitError Int]
ghci&gt; map parseDigit &quot;1234567&quot;
[Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7]

ghci&gt; :t sequenceA
sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a)
-- Substitute `t` with `[]`, and `f` with `Either Error` for a specialized version

ghci&gt; sequenceA (map parseDigit mystring)
Right [1,2,3,4,5,6,7]

ghci&gt; map parseDigit &quot;1a2&quot;
[Right 1,Left (NotADigit 'a'),Right 2]
ghci&gt; sequenceA (map parseDigit &quot;1a2&quot;)
Left (NotADigit 'a')
</code></pre>
<p>The pattern of doing <code>map</code> and then <code>sequenceA</code> is another function called <code>traverse</code>:</p>
<pre><code class="language-hs">ghci&gt; :t traverse
traverse
  :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
ghci&gt; traverse parseDigit &quot;1234567&quot;
Right [1,2,3,4,5,6,7]
ghci&gt; traverse parseDigit &quot;1a2&quot;
Left (NotADigit 'a')
</code></pre>
<p>We can use <code>traverse</code> on any two types where one implements the <code>Applicative</code>
interface, like <code>Either a</code> or <code>IO</code>, and the other implements the <code>Traversable</code> interface,
like <code>[]</code> (linked lists) and
<a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#t:Map"><code>Map k</code></a>
(also known as a dictionary in other languages - a mapping from keys to values).
For example using <code>IO</code> and <code>Map</code>. Note that we can construct a <code>Map</code> data structure
from a list of tuples using the
<a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#v:fromList"><code>fromList</code></a>
function - the first value in the tuple is the key, and the second is the type.</p>
<pre><code class="language-hs">ghci&gt; import qualified Data.Map as M -- from the containers package

ghci&gt; file1 = (&quot;output/file1.html&quot;, &quot;input/file1.txt&quot;)
ghci&gt; file2 = (&quot;output/file2.html&quot;, &quot;input/file2.txt&quot;)
ghci&gt; file3 = (&quot;output/file3.html&quot;, &quot;input/file3.txt&quot;)
ghci&gt; files = M.fromList [file1, file2, file3]
ghci&gt; :t files :: M.Map FilePath FilePath -- FilePath is an alias of String
files :: M.Map FilePath FilePath :: M.Map FilePath FilePath

ghci&gt; readFiles = traverse readFile
ghci&gt; :t readFiles
readFiles :: Traversable t =&gt; t FilePath -&gt; IO (t String)

ghci&gt; readFiles files
fromList [(&quot;output/file1.html&quot;,&quot;I'm the content of file1.txt\n&quot;),(&quot;output/file2.html&quot;,&quot;I'm the content of file2.txt\n&quot;),(&quot;output/file3.html&quot;,&quot;I'm the content of file3.txt\n&quot;)]
ghci&gt; :t readFiles files
readFiles files :: IO (Map String String)
</code></pre>
<p>Above, we created a function <code>readFiles</code> that will take a mapping from <em>output file path</em>
to <em>input file path</em> and returns an IO operation that when run will read the input files
and replace their contents right there in the map! Surely this will be useful later.</p>
<h2 id="multiple-errors"><a class="header" href="#multiple-errors">Multiple errors</a></h2>
<p>Note, since <code>Either</code> has the kind <code>* -&gt; * -&gt; *</code> (it takes two type
parameters) <code>Either</code> cannot be an instance of <code>Functor</code> and <code>Applicative</code>,
instances for these type classes can only be implemented for types that have the
kind <code>* -&gt; *</code>.
Remember that when we look at a type class function signature like:</p>
<pre><code class="language-hs">fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And we want to implement it for a specific type (in place of the <code>f</code>),
we need to be able to <em>substitute</em> the <code>f</code> with the target type. If we'd try
to do it with <code>Either</code> we'll get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Either a -&gt; Either b
</code></pre>
<p>And neither <code>Either a</code> or <code>Either b</code> are <em>saturated</em>, so this won't type check.
For the same reason if we'll try to substitute <code>f</code> with, say, <code>Int</code>, we'll get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b
</code></pre>
<p>Which also doesn't make sense.</p>
<p>So while we can't use <code>Either</code>, we can use <code>Either e</code>, which has the kind
<code>* -&gt; *</code>. Now let's try substituting <code>f</code> with <code>Either e</code> in this signature:</p>
<pre><code class="language-hs">liftA2 :: Applicative =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>And we'll get:</p>
<pre><code class="language-hs">liftA2 :: (a -&gt; b -&gt; c) -&gt; Either e a -&gt; Either e b -&gt; Either e c
</code></pre>
<p>What this teaches us is that we can only use the applicative interface to
combine two <em><code>Either</code>s with the same type for the <code>Left</code> constructor</em>.</p>
<p>So what can we do if we have two functions that can return different errors?
There are a few approaches, the most prominent ones are:</p>
<ol>
<li>Make them return the same error type. Write an ADT that holds all possible
error descriptions. This can work in some cases but isn't always ideal
because for example a user calling <code>parseDigit</code> shouldn't be forced to
handle a possible case that the input might be an empty string.</li>
<li>Use a specialized error type for each type, and when they are composed together,
map the error type of each function to a more general error type. This can
be done with the function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Bifunctor.html#v:first"><code>first</code></a>
from the <code>Bifunctor</code> type class.</li>
</ol>
<h2 id="monadic-interface"><a class="header" href="#monadic-interface">Monadic interface</a></h2>
<p>The applicative interface allows us to lift a function on to work on multiple
<code>Either</code> values (or other applicative functor instances such as <code>IO</code> and <code>Parser</code>). 
But more often than not, we'd like to be able to use a value from one computation
that might return an error in another computation that might return an error.</p>
<p>For example, a compiler such has GHC operates in stages, such as lexical analysis,
parsing, type-checking, and so on. Each stage depends on the output of the stage
before it, and each stage might fail. We can write the types for these functions:</p>
<pre><code class="language-hs">tokenize :: String -&gt; Either Error [Token]

parse :: [Token] -&gt; Either Error AST

typcheck :: AST -&gt; Either Error TypedAST
</code></pre>
<p>We want to compose these functions so that they work in a chain. The output of <code>tokenize</code>
goes to <code>parse</code>, the output of <code>parse</code> goes into to <code>typecheck</code>.</p>
<p>We know that we can lift a function over an <code>Either</code> (and other functors),
we could also lift a function that returns an <code>Either</code>:</p>
<pre><code class="language-hs">-- reminder the type of fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- specialized for `Either Error`
fmap :: (a -&gt; b) -&gt; Either Error a -&gt; Either Error b

-- here, `a` is [Token] and `b` is `Either Error AST`:

&gt; fmap parse (tokenize string) :: Either Error (Either Error AST)
</code></pre>
<p>While this code compiles, it isn't great, because we are building
layers of <code>Either Error</code> and we can't use this trick again with
<code>typecheck</code>! <code>typecheck</code> expects an <code>AST</code>, but if we try to fmap it
on <code>fmap parse (tokenize string)</code>, the <code>a</code> will be <code>Either Error AST</code>
instead.</p>
<p>What we would really like is to flatten this structure instead of building it.
If we look at the kind of values <code>Either Error (Either Error AST)</code> could have,
it looks something like this:</p>
<ul>
<li><code>Left &lt;error&gt;</code></li>
<li><code>Right (Left error)</code></li>
<li><code>Right (Right &lt;ast&gt;)</code></li>
</ul>
<hr />
<p><strong>Exercise</strong>: What if we just used pattern matching for this instead? How would this look like?</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">case tokenize string of
  Left err -&gt;
    Left err
  Right tokens -&gt;
    case parse tokens of
      Left err -&gt;
        Left err
      Right ast -&gt;
        typecheck ast
</code></pre>
<p>If we run into an error in a stage, we return that error and stop. If we succeed, we
use the value on the next stage.</p>
</details>
<hr />
<p>Flattening this structure for <code>Either</code> is very similar to that last part - the body
of the <code>Right tokens</code> case:</p>
<pre><code class="language-hs">flatten :: Either e (Either e a) -&gt; Either e a
flatten e =
  case e of
    Left l -&gt; Left l
    Right x -&gt; x
</code></pre>
<p>Because we have this function, we can now use it on the output of
<code>fmap parse (tokenize string) :: Either Error (Either Error AST)</code>
from before:</p>
<pre><code>&gt; flatten (fmap parse (tokenize string)) :: Either Error AST
</code></pre>
<p>And now we can use this function again to compose with <code>typecheck</code>:</p>
<pre><code class="language-hs">&gt; flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST
</code></pre>
<p>This <code>flatten</code> + <code>fmap</code> combination looks like a recurring pattern which
we can combine into a function:</p>
<pre><code class="language-hs">flatMap :: (a -&gt; Either e b) -&gt; Either a -&gt; Either b
flatMap func val = flatten (fmap func val)
</code></pre>
<p>And now we can write the code this way:</p>
<pre><code class="language-hs">&gt; flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST

-- Or using backticks syntax to convert the function to infix form:
&gt; typecheck `flatMap` parse `flatMap` tokenize string

-- Or create a custom infix operator: (=&lt;&lt;) = flatMap
&gt; typeCheck =&lt;&lt; parse =&lt;&lt; tokenize string
</code></pre>
<p>This function, <code>flatten</code> (and <code>flatMap</code> as well), have different names in Haskell.
They are called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:join"><code>join</code></a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:-61--60--60-"><code>=&lt;&lt;</code></a>
(pronounced &quot;reverse bind&quot;),
and they are the essence of another incredibly useful abstraction in Haskell.</p>
<p>If we have a type that can implement:</p>
<ol>
<li>The <code>Functor</code> interface, specifically the <code>fmap</code> function</li>
<li>The <code>Applicative</code> interface, most importantly the <code>pure</code> function</li>
<li>This <code>join</code> function</li>
</ol>
<p>They can implement an instance of the <code>Monad</code> type class.</p>
<p>With functors, we were able to &quot;lift&quot; a function to work over the type implementing the functor type class:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>With applicative functors we were able to &quot;lift&quot; a function of multiple arguments
over multiple values of a type implementing the applicative functor type class,
and also lift a value into that type:</p>
<pre><code class="language-hs">pure :: a -&gt; f a

liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>With monads we can now flatten (or, &quot;join&quot; in Haskell terminology) types that implement
the <code>Monad</code> interface:</p>
<pre><code class="language-hs">join :: m (m a) -&gt; m a

-- this is =&lt;&lt; with the arguments reversed, pronounced &quot;bind&quot;
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>With <code>&gt;&gt;=</code> we can write our compilation pipeline from before in a left-to-right
manner, which seems to be more popular for monads:</p>
<pre><code class="language-hs">&gt; tokenize string &gt;&gt;= parse &gt;&gt;= typecheck
</code></pre>
<p>We have already met this function before when we talked about <code>IO</code>. Yes,
<code>IO</code> also implements the <code>Monad</code> interface. The monadic interface for <code>IO</code>
helped us with creating a proper ordering of effects.</p>
<p>The essence of the <code>Monad</code> interface is the <code>join</code>/<code>&gt;&gt;=</code> functions, and as we've seen
we can implement <code>&gt;&gt;=</code> in terms of <code>join</code>, we can also implement <code>join</code> in terms
of <code>&gt;&gt;=</code> (try it!).</p>
<p>The monadic interface can mean very different things for different types. For <code>IO</code> this
is ordering of effects, for <code>Either</code> it is early cutoff,
for <a href="https://hackage.haskell.org/package/logict-0.7.1.0"><code>Logic</code></a> this means backtracking computation, etc.</p>
<p>Again, don't worry about analogies and metaphors, focus on the API and the
<a href="https://wiki.haskell.org/Monad_laws">laws</a>.</p>
<blockquote>
<p>Hey, did you check the monad laws? left identity, right identity and associativity? We've already
discussed a type class with exactly these laws - the <code>Monoid</code> type class. Maybe this is related
to the famous quote about monads beings just monoids in something something...</p>
</blockquote>
<h3 id="do-notation-1"><a class="header" href="#do-notation-1">Do notation?</a></h3>
<p>Remember <a href="06-errors_and_files/../05-glue/02-io.html#do-notation">do notation</a>? Turns out it works for any type that is
an instance of <code>Monad</code>. How cool is that? Instead of writing:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string =
  tokenize string &gt;&gt;= \tokens -&gt;
    parse tokens &gt;&gt;= \ast -&gt;
      typecheck ast
</code></pre>
<p>We can write:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string = do
  tokens &lt;- tokenize string
  ast &lt;- parse tokens
  typecheck ast
</code></pre>
<p>And it will work! Still, in this particular case <code>tokenize string &gt;&gt;= parse &gt;&gt;= typecheck</code>
is so concise it can only be beaten by using
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Monad.html#v:-62--61--62-">&gt;=&gt;</a></p>
<pre><code class="language-hs">&gt;=&gt; :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c

-- compare with function composition:
(.) ::            (a -&gt;   b) -&gt; (b -&gt;   c) -&gt; a -&gt;   c
</code></pre>
<pre><code class="language-hs">pipeline = tokenize &gt;=&gt; parse &gt;=&gt; typecheck
</code></pre>
<p>This ability of Haskell's to create very concise code using great abstractions makes it
great once one is familiar with the abstractions. Knowing the monad abstraction,
we are now already familiar with the core composition API of many libraries - for example:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/stm">Concurrent</a>
and <a href="https://hackage.haskell.org/package/async">asynchronous programming</a></li>
<li><a href="https://gilmi.me/blog/post/2020/12/05/scotty-bulletin-board">Web programming</a></li>
<li><a href="http://hspec.github.io/">Testing</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#g:2">Emulating stateful computation</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2">sharing environment between computations</a></li>
<li>and many more.</li>
</ul>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Using <code>Either</code> for error handling is useful for two reasons:</p>
<ol>
<li>We encode possible errors using types, and we <strong>force users to acknowledge and handle</strong> them, thus
making our code more resilient to crashes and bad behaviour.</li>
<li>The <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> interfaces provide us with mechanisms for
<strong>composing</strong> functions that might fail (almost) effortlessly - reducing boilerplate while
maintaining strong guarantees about our code, and delaying the need to handle errors until
it is appropriate.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="either-with-io"><a class="header" href="#either-with-io">Either with IO?</a></h1>
<p>When we create <code>IO</code> actions that may require I/O we risk running into all kinds of errors.
For example, when we use <code>writeFile</code>, we could run out of disk space in the middle of writing,
or the file might be write protected. While these scenarios aren't super common, they are definitely
possible.</p>
<p>We could've potentially encoded Haskell functions like <code>readFile</code> and <code>writeFile</code> as <code>IO</code> operations
that return <code>Either</code>, for example:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; IO (Either ReadFileError String)
writeFile :: FilePath -&gt; String -&gt; IO (Either WriteFileError ())
</code></pre>
<p>However there are a couple of issues here, the first is that now composing <code>IO</code> actions
became more difficult. Previously we could write:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;output.html&quot;
</code></pre>
<p>But now the types no longer match - <code>readFile</code> will return an <code>Either ReadFileError String</code>,
but <code>writeFile</code> wants to take a <code>String</code> as input. We are forced to handle the error
before calling <code>writeFile</code>.</p>
<h2 id="composing-io--either-using-exceptt"><a class="header" href="#composing-io--either-using-exceptt">Composing IO + Either using ExceptT</a></h2>
<p>One way to handle this is by using <strong>monad transformers</strong>. Monad transformers are a method
to stack monad capabilities on top of one another. They are called transformers because
<strong>they take a type that has an instance of monad as input, and return a new type that
implements the monad interface, stacking a new capability on top of it</strong>.</p>
<p>For example, if we want to create a value with a type similar to <code>IO (Either Error a)</code>
that we can compose using the monadic interface (the function <code>&gt;&gt;=</code>) with other values
of a type similar to <code>IO (Either Error a)</code>, we can using a monad transformer
called <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#g:2"><code>ExceptT</code></a>.
Let's see how <code>ExceptT</code> is defined:</p>
<pre><code class="language-hs">newtype ExceptT e m a = ExceptT (m (Either e a))
</code></pre>
<p>Remember, a <code>newtype</code> is a new name for an existing type. And if we substitute
<code>e</code> with <code>Error</code> and <code>m</code> with <code>IO</code> we'll get exactly <code>IO (Either Error a)</code> as we wanted.
And we can convert an <code>ExceptT Error IO a</code> into <code>IO (Either Error a)</code> using
the function <code>runExceptT</code>:</p>
<pre><code class="language-hs">runExceptT :: ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>ExceptT</code> implements the monadic interface in a way that combines the capabilities of
<code>Either</code>, and whatever <code>m</code> it takes. Because <code>ExceptT e m</code> has a <code>Monad</code> instance,
a specialized version of <code>&gt;&gt;=</code> would look like this:</p>
<pre><code class="language-hs">-- Generalized version
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Specialized version, replace `m` with `ExceptT e m`
(&gt;&gt;=) :: ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b
</code></pre>
<hr />
<p>Unsure how this works? Try to implement <code>&gt;&gt;=</code> for <code>IO (Either Error a)</code>:</p>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either Error a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>Note that we didn't actually use the implementation details of <code>Error</code> or <code>IO</code>,
<code>Error</code> isn't mentioned at all, and for <code>IO</code> we only used the monadic interface with
the do notation. We could write the same function with a more generalized type signature:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; m (Either e a) -&gt; (a -&gt; m (Either e b)) -&gt; m (Either e b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either e a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>And because <code>newtype ExceptT e m a = ExceptT (m (Either e a))</code> we can just
pack and unpack that <code>ExceptT</code> constructor and get:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b
bindExceptT mx f = ExceptT $ do
  -- `runExceptT mx` has the type `m (Either e a)`
  -- `x` has the type `Either e a`
  x &lt;- runExceptT mx
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
</details>
<hr />
<blockquote>
<p>Note that when stacking monad transformers, the order in which we stack them matters.
With <code>ExceptT Error IO a</code>, we have an <code>IO</code> operation that when run will return <code>Either</code>
an error or a value.</p>
</blockquote>
<p><code>ExceptT</code> can enjoy both worlds - we can return error values using the function <code>throwError</code>:</p>
<pre><code class="language-hs">throwError :: e -&gt; ExceptT e m a
</code></pre>
<p>and we can &quot;lift&quot; functions that return a value of the underlying monadic type <code>m</code> to return
a value of <code>ExceptT e m a</code> instead:</p>
<pre><code class="language-hs">lift :: m a -&gt; ExceptT e m a
</code></pre>
<p>for example:</p>
<pre><code class="language-hs">getLine :: IO String

lift getLine :: ExceptT e IO String
</code></pre>
<blockquote>
<p>(Actually, <code>lift</code> is also a type class function from <code>MonadTrans</code>, the type class
of monad transformers. So technically <code>lift getLine :: MonadTrans t =&gt; t IO String</code>,
but we are specializing for concreteness)</p>
</blockquote>
<p>Now, if we had:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; ExceptT IOError IO String

writeFile :: FilePath -&gt; String -&gt; ExceptT IOError IO ()
</code></pre>
<p>We could compose them again without issue:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;ouptut.html&quot;
</code></pre>
<p>But remember - the error type <code>e</code> (in both the case <code>Either</code> and <code>Except</code>)
must be the same between composed functions! This means that the type representing
errors for both <code>readFile</code> and <code>writeFile</code> must be the same - that would also
force anyone using these functions to handle these errors - should a user who
called <code>writeFile</code> be required to handle a &quot;file not found&quot; error? Should a user
who called <code>readFile</code> be required to handle an &quot;out of disk space&quot; error?
There are many many more possible IO errors! &quot;network unreachable&quot;, &quot;out of memory&quot;,
&quot;cancelled thread&quot;, we cannot require a user to handle all these errors, or
even cover them all in a data type.</p>
<p>So what do we do?</p>
<p>We give up on this approach <strong>for IO code</strong>, and use a different one: Exceptions.
As we'll see in the next chapter.</p>
<blockquote>
<p>Note - when we stack <code>ExceptT</code> on top of a different type called
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor-Identity.html"><code>Identity</code></a>
that also implements the <code>Monad</code> interface, we get a type that is exactly like <code>Either</code>
called <a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Except.html#t:Except"><code>Except</code></a>
(without the <code>T</code> at the end). You might sometimes want to use <code>Except</code> instead of <code>Either</code>
because it has a more appropriate name and better API for error handling than <code>Either</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>The <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html">Control.Exception</a>
module provides us with the ability to
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#v:throwIO">throw</a>
exceptions from <code>IO</code> code,
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#g:5"><code>catch</code></a>
Haskell exceptions in <code>IO</code> code, and even convert them to <code>IO (Either ...)</code>
with the function <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#g:7"><code>try</code></a>:</p>
<pre><code class="language-hs">throwIO :: Exception e =&gt; e -&gt; IO a

catch
  :: Exception e
  =&gt; IO a         -- The computation to run
  -&gt; (e -&gt; IO a)  -- Handler to invoke if an exception is raised
  -&gt; IO a

try :: Exception e =&gt; IO a -&gt; IO (Either e a)
</code></pre>
<p>The important part of these type signatures is the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#t:Exception"><code>Exception</code></a>
type class. By making a type an instance of the <code>Exception</code> type class, we can throw it
and catch it in <code>IO</code> code:</p>
<pre><code class="language-hs">{-# language LambdaCase #-}

import Control.Exception
import System.IO

data MyException
  = ErrZero
  | ErrOdd Int
  deriving Show

instance Exception MyException

sayDiv2 :: Int -&gt; IO ()
sayDiv2 n
  | n == 0 = throwIO ErrZero
  | n `mod` 2 /= 0 = throwIO (ErrOdd n)
  | otherwise = print (n `div` 2)

main :: IO ()
main =
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
    )
</code></pre>
<blockquote>
<p>Note: we are using two new things here: guards, and the <code>LambdaCase</code> language extension.</p>
<ol>
<li>
<p>Guards as seen in <code>sayDiv2</code> are just a nicer syntax around <code>if-then-else</code> expressions.
Using guards we can have multiple <code>if</code> branches and finally use the <code>else</code> branch
by using <code>otherwise</code>. After each guard (<code>|</code>) there's a condition, after the condition there's
a <code>=</code> and then the expression (the part after <code>then</code> in an <code>if</code> expression).</p>
</li>
<li>
<p>LambdaCase as seen in <code>catch</code>, is just a syntactic sugar to save a few characters,
instead of writing <code>\e -&gt; case e of</code>, we can write <code>\case</code>. It requires enabling the
<code>LambdaCase</code> extension.</p>
<h4 id="language-extensions"><a class="header" href="#language-extensions">Language extensions</a></h4>
<p>Haskell is a standardized language. However, GHC provides <em>extensions</em> to the language -
additional features that aren't covered in the 98 or 2010 standards of Haskell.
Features such as syntactic extensions (like LambdaCase above), extensions to the type checker,
and more.</p>
<p>These extensions can be added by adding <code>{-# language &lt;extension-name&gt; #-}</code>
(the <code>language</code> part is case insensitive)
to the top of a Haskell source file, or they can be set globally for an entire project by
specifying them in the
<a href="https://cabal.readthedocs.io/en/3.6/cabal-package.html#pkg-field-default-extensions">default-extensions</a>
section in the <code>.cabal file</code>.</p>
<p>The list of language extensions can be found in the
<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html">GHC manual</a>,
feel free to browse it, but don't worry about trying to memorize all the extensions.</p>
</li>
</ol>
</blockquote>
<p>This example, of course, is an example that would work much better using <code>Either</code> and separating
the division and printing Ã  la 'functional core, imperative shell'. But as an example it works.
We have created a custom exception and handled it specifically outside an <code>IO</code> block.
However, we have not handled exceptions that might be raised by <code>putStrLn</code>.
What if, for example, for some reason we close the <code>stdout</code> handle before this block:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
    )
</code></pre>
<p>Our program will crash with an error:</p>
<pre><code>ghc: &lt;stdout&gt;: hFlush: illegal operation (handle is closed)
</code></pre>
<p>First, how do we know which exception we should handle? Some functions' documentation
will include this, but unfortunately <code>putStrLn</code> does not. We could guess from the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#i:Exception">list of instances</a>
the <code>Exception</code> type class has; I think
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-IO-Exception.html#t:IOException"><code>IOException</code></a> fits. Now, how can we handle this case as well? We can chain catches:</p>
<pre><code class="language-hs">-- need to add these at the top

{-# language ScopedTypeVariables #-}

import GHC.IO.Exception (IOException(..))

main :: IO ()
main = do
  hClose stdout
  catch
    ( catch
      ( do
        putStrLn &quot;Going to print a number now.&quot;
        sayDiv2 7
        putStrLn &quot;Did you like it?&quot;
      )
      ( \case
        ErrZero -&gt;
          hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
        ErrOdd n -&gt;
          hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
      )
    )
    ( \(e :: IOException) -&gt;
      -- we can check if the error was an illegal operation on the stderr handle
      if ioe_handle e /= Just stderr &amp;&amp; ioe_type e /= IllegalOperation
        then pure () -- we can't write to stderr because it is closed
        else hPutStrLn stderr (displayException e)
    )
</code></pre>
<blockquote>
<p>We use the <code>ScopedTypeVariables</code> to be able to specify types inside let expressions,
lambdas, pattern matching and more.</p>
</blockquote>
<p>Or we could use the convenient function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#v:catches"><code>catches</code></a>
to pass a list of exception
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#t:Handler">handlers</a>:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catches
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    [ Handler $ \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
    
    , Handler $ \(e :: IOException) -&gt;
      -- we can check if the error was an illegal operation on the stderr handle
      if ioe_handle e /= Just stderr &amp;&amp; ioe_type e /= IllegalOperation
        then pure () -- we can't write to stderr because it is closed
        else hPutStrLn stderr (displayException e)
    ]
</code></pre>
<blockquote>
<p>As an aside, <code>Handler</code> uses a concept called
<a href="https://en.m.wikibooks.org/wiki/Haskell/Existentially_quantified_types">existentially quantified types</a>
to hide inside it a function that takes an arbitrary type that implements <code>Exception</code>.
This is why we can encode a seemingly heterogeneous list of functions that handle exceptions
for <code>catches</code> to take as input.
This pattern is rarely useful, but I've included it here to avoid confusion.</p>
</blockquote>
<p>And if we wanted to catch any exception, we'd catch <code>SomeException</code>:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \(SomeException e) -&gt;
      hPutStrLn stderr (show e)
    )
</code></pre>
<p>This could also go in <code>catches</code> as the last element in the list if we wanted specialized
handling for other scenarios.</p>
<p>A couple more functions worth knowing are
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#v:bracket"><code>bracket</code></a>
and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception.html#v:finally"><code>finally</code></a>.
These functions can help us handle resource acquisition more safely when errors are present.</p>
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Exceptions are useful and often necessary when we work with <code>IO</code> and want to make sure
our program is handling errors gracefully. They have an advantage over <code>Either</code> in that
we can easily compose functions that may throw errors of different types, but also have
a disadvantage of not encoding types as return values, and therefore does not force us
to handle them.</p>
<p>For Haskell, the language designers have made a choice for us by designing <code>IO</code> to
use exceptions instead of <code>Either</code>. And this is what I would recommend to use for
handling your own effectful computations. However, I think that <code>Either</code> is more
fitting for uneffectful code, because it forces us to acknowledge and handle errors
(eventually) thus making our programs more robust. And also because we can only
catch exceptions in <code>IO</code> code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-code-already"><a class="header" href="#lets-code-already">Lets code already!</a></h1>
<p>This was a long info dump. Let's practice what we've learned. We want to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension</li>
<li>Process .txt files</li>
<li>Copy other files without modification</li>
<li>Parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<blockquote>
<p>Note: I did not write this code immediately in the final form it was presented.
It was an iterative process of writing code, refactoring, splitting functions, changing
type signatures, and more. When solving a coding problem, start small and simple,
do the thing that works, and refactor it when it makes sense and makes the code clearer
and more modular. In Haskell we pride ourselves in our ability to refactor code and improve
it over time, and that principle holds when writing new software as well!</p>
</blockquote>
<h2 id="new-module"><a class="header" href="#new-module">New module</a></h2>
<p>Let's create a new module, <code>HsBlog.Directory</code>, which will be responsible for handling
directories and multiple files. From this module we will export the <code>convertDirectory</code>
and <code>buildIndex</code> functions we've defined before.</p>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
</code></pre>
<p>In this module we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html">directory</a>
and <a href="https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html">filepath</a>
libraries to manipulate directories, files and filepaths.
We'll use the new abstractions we've learned, <code>Traversable</code> and <code>Monad</code>, and the concepts
and types we've learned about: <code>Either</code>, <code>IO</code> and exceptions.</p>
<p>For all of that, we need quite a few imports:</p>
<pre><code class="language-hs">import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
</code></pre>
<p>If you are unsure what a specific function we're using does, look it up at
<a href="https://hoogle.haskell.org/">Hoogle</a>,
read the type signature and the documentation, and play around with it in <code>ghci</code>.</p>
<h2 id="converting-a-directory"><a class="header" href="#converting-a-directory">Converting a directory</a></h2>
<p>We can start by describing the high-level function <code>convertDirectory</code> which
encapsulates many smaller functions, each responsible for doing a specific thing.
<code>convertDirectory</code> is quite imperative looking, and looks like a different way to
describe the steps of completing our task:</p>
<pre><code class="language-hs">-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>Here we trust that each <code>IO</code> function handles errors responsibly,
and terminates the project when necessary.</p>
<p>Let's examine the steps in order.</p>
<h3 id="getdirfilesandcontent"><a class="header" href="#getdirfilesandcontent"><code>getDirFilesAndContent</code></a></h3>
<pre><code class="language-hs">-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents

</code></pre>
<p><code>getDirFilesAndContent</code> is responsible for providing the relevant files for processing --
both the ones we need to convert to markup (and their textual content) and other files we
might want to copy as-is (such as images and style-sheets).</p>
<pre><code class="language-hs">-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
</code></pre>
<p>This function does 4 important things:</p>
<ol>
<li>Lists all the files in the directory</li>
<li>Splits the files into 2 groups according to their file extension</li>
<li>Reads the contents of the .txt files and report when files failed to be read</li>
<li>Returns the results. We've defined a data type to make what each result is more obvious</li>
</ol>
<p>Part (3) is a little bit more involved than the rest, lets explore it.</p>
<h4 id="applyioonlist"><a class="header" href="#applyioonlist"><code>applyIoOnList</code></a></h4>
<pre><code class="language-hs">-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)
</code></pre>
<p><code>applyIoOnList</code> is a higher order function that applies a particular <code>IO</code> function
(in our case <code>readFile</code>) on a list of things (in our case <code>FilePath</code>s),
and for each thing, it returns the thing itself along with the result of
applying the <code>IO</code> function as an <code>Either</code>, where the <code>Left</code> side is a <code>String</code>
representation of an error if one occurred.</p>
<p>Notice how much the type of this function tells us about what it might do.
Because the types are polymorphic, there is nothing else to do with with
the <code>a</code>s other than apply them to the function, and nowhere to generate <code>b</code>
from other than the result of the function.</p>
<blockquote>
<p>Note: when I first wrote this function, it was specialized to work only on <code>readFile</code>,
take specifically <code>[FilePath]</code> and return <code>IO [(FilePath, Either String String)]</code>.
But after running into other use cases where I could use it (<code>writeFiles</code> and <code>copyFiles</code>)
I refactored out the <code>action</code>, the input type and the return type.</p>
</blockquote>
<p>This function uses exceptions to catch any error that might be thrown, and encodes
both the failure and success cases in the type system using <code>Either</code>, delaying
the handling of exceptions to the caller of the function while making sure it won't
be forgotten!</p>
<p>Next, let's look at the function that handles the errors by reporting and then filtering out
all the cases that failed.</p>
<h4 id="filterandreportfailures"><a class="header" href="#filterandreportfailures"><code>filterAndReportFailures</code></a></h4>
<pre><code class="language-hs">-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]
</code></pre>
<p>This code may seem a bit surprising - how come we can use <code>foldMap</code> here? Reminder,
the type of <code>foldMap</code> is:</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</code></pre>
<p>If we specialize this function for our use case, substituting the general type
with the types we are using, we learn that <code>IO [(a, b)]</code> is a monoid.
And indeed - <code>[a]</code> is a monoid for any <code>a</code> with <code>[]</code> (the empty list) as <code>mempty</code>
and <code>++</code> as <code>&lt;&gt;</code>, but also <code>IO a</code> is a monoid for any <code>a</code> that is itself
a monoid with <code>pure mempty</code> as <code>mempty</code> and <code>liftA2 (&lt;&gt;)</code> as <code>&lt;&gt;</code>!</p>
<p>Using these instances, we can <code>map</code> over the content, handling errors and returning
an empty list to filter a failed case out, or a singleton list to keep the result.
and the <code>fold</code> in <code>foldMap</code> will concatenate the resulting list where we return
all of the successful cases!</p>
<p>These functions were responsible for fetching the right information. Next,
let's look at the code for creating a new directory.</p>
<h3 id="createoutputdirectoryorexit"><a class="header" href="#createoutputdirectoryorexit"><code>createOutputDirectoryOrExit</code></a></h3>
<pre><code class="language-hs">-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
</code></pre>
<p><code>createOutputDirectoryOrExit</code> itself is not terribly exciting, it does
what it is named -- it tries to create the output directory, and exits the
program in case it didn't succeed.</p>
<p><code>createOutputDirectory</code> is the function that actually does the heavy lifting.
It checks if the directory already exists, and checks if the user would like to
override it. If they do, we remove it and create the new directory; if they don't,
we do nothing and report their decision.</p>
<h3 id="txtstorenderedhtml"><a class="header" href="#txtstorenderedhtml"><code>txtsToRenderedHtml</code></a></h3>
<pre><code class="language-hs">let
  outputHtmls = txtsToRenderedHtml filesToProcess
</code></pre>
<p>In this part of the code we convert files to markup and change the
input file paths to their respective output file paths (<code>.txt</code> -&gt; <code>.html</code>).
We then build the index page, and convert everything to HTML.</p>
<pre><code class="language-hs">-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
</code></pre>
<p>One possibly surprising thing about this code could be the <code>map (fmap Html.render)</code>
part. We can use <code>fmap</code> on the tuple because it is a <code>Functor</code> on the second
argument, just like <code>Either</code>!</p>
<h3 id="copyfiles-and-writefiles"><a class="header" href="#copyfiles-and-writefiles"><code>copyFiles</code> and <code>writeFiles</code></a></h3>
<p>The only thing left to do is to write the directory
content, after the processing is completed, to the newly created directory:</p>
<pre><code class="language-hs">-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Here we use <code>applyIoOnList</code> again to do something a bit more complicated,
instead of reading from a file, it copies from the input path to a newly generated
output path. Then we pass the result (which has the type <code>[(FilePath, Either String ())]</code>)
to <code>filterAndReportFailures</code> to print the errors and filter out the unsuccessful copies.
Because we are not really interested in the output of <code>filterAndReportFailures</code>,
we discard it with <code>void</code>, returning <code>()</code> as a result instead.</p>
<pre><code class="language-hs">-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Once again, this code looks almost exactly like <code>copyFiles</code>, but the types are different.
Haskell's combination of parametric polymorphism + type class for abstractions is really
powerful, and has helped us reduce quite a bit of code.</p>
<hr />
<p>This pattern of using <code>applyIoOnList</code> and then <code>filterAndReportFailures</code>
happens more than once. It might be a good candidate for refactoring. Try it!
What do you think about the resulting code? Is it easier or more difficult to
understand? Is it more modular or less? What are the pros and cons?</p>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>With that, we have completed our <code>HsBlog.Directory</code> module that handles converting
a directory safely. Note that the code could probably be simplified quite a bit if we
were fine with errors crashing the entire program altogether, but sometimes this is
the price we pay for robustness. It is up to you to choose what you can live with
and what not, but I hope this saga has taught you how to approach handling errors
in Haskell in case you need to.</p>
<hr />
<p>View the full module:</p>
<details><summary>HsBlog.Directory</summary>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;

------------------------------------
-- * Read directory content

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

------------------------------------
-- * Build index page

buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h1_ (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )

------------------------------------
-- * Conversion

-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * Output to directory

-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures

-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures

------------------------------------
-- * IO work and handling errors

-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)

-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]

------------------------------------
-- * Utilities

confirm :: String -&gt; IO Bool
confirm question = do
  putStrLn (question &lt;&gt; &quot; (y/n)&quot;)
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. Use y or n.&quot;
      confirm question

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-10"><a class="header" href="#summary-10">Summary</a></h1>
<p>This was quite a section. Let's recount the things we've learned.</p>
<p>We discussed several ways to handle errors in Haskell:</p>
<ol>
<li>Encoding errors as a data type and using the <code>Either</code> type to encode &quot;a value or an error&quot;.
Useful approach for uneffectful code.</li>
<li>Using <code>ExceptT</code> when we want to combine the approach in (1) on top on an existing
type with monadic capabilities.</li>
<li>Using exceptions for IO code.</li>
</ol>
<p>We've also learned a few new abstractions and techniques:</p>
<ol>
<li>The <code>Traversable</code> type class, for data structures that can be traversed from left to right
such as linked lists, binary trees and <code>Map</code>s.
Pretty useful when combined with another applicative functor type like <code>Either</code> or <code>IO</code>.</li>
<li>The <code>Monad</code> type class extends the <code>Applicative</code> type class with the <code>join :: m (m a) -&gt; m a</code>
function. We learned that <code>Either</code> implements this type class interface and so does <code>IO</code>.</li>
<li>The <code>MonadTrans</code> type class for <em>monad transformers</em> for types that take other monads as inputs
and provide a monadic interface (<code>&gt;&gt;=</code>, do notation, etc.) while combining both their capabilities.
We saw how to stack an <code>Either</code>-like monad transformer, <code>ExceptT</code>, on top of <code>IO</code>.</li>
</ol>
<p>We are almost done. Only a couple more things left to do with this project. Let's go!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/0025762fbe91e159f82b8fc5d39d86cac39c4f7d">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/0025762fbe91e159f82b8fc5d39d86cac39c4f7d">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-environment-variables"><a class="header" href="#passing-environment-variables">Passing environment variables</a></h1>
<p>We'd like to add some sort of an environment to keep general information on
the blog for various processing. Things like the blog name, stylesheet
location, and so on.</p>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<p>We can represent our environment as a record data type and build it from user input.
The user input can be from command-line arguments, a configuration file,
or something else.</p>
<pre><code class="language-hs">module HsBlog.Env where

data Env
  = Env
    { eBlogName :: String
    , eStylesheetPath :: FilePath
    }
  deriving Show

defaultEnv :: Env
defaultEnv = Env &quot;My Blog&quot; &quot;style.css&quot;
</code></pre>
<p>After filling this record with the requested information, we can pass it as
input to any function that might need it. This is a simple approach that can definitely
work for small projects. But sometimes when the project gets bigger and many
nested functions need the same information, threading the environment can get
tedious.</p>
<p>There is an alternative solution to threading the environment as input to functions,
and that is using the
<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2"><code>ReaderT</code></a>
type from the <code>mtl</code> (or <code>transformers</code>) package.</p>
<h3 id="readert"><a class="header" href="#readert">ReaderT</a></h3>
<pre><code class="language-hs">newType ReaderT r m a = ReaderT (r -&gt; m a)
</code></pre>
<p><code>ReaderT</code> is another <em>monad transformer</em> like <code>ExceptT</code>, which means
that it also has an instance of <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> and <code>MonadTrans</code>.</p>
<p>As we can see in the definition, <code>ReaderT</code> is <em>a newtype</em> over a function that takes
some value of type <code>r</code>, and returns a value of type <code>m a</code>. The <code>r</code> usually
represents the environment we want to share between different functions that we want to
compose together, and the <code>m a</code> represents the underlying result that we return.
The <code>m</code> could be any type that implements <code>Monad</code> that we are familiar with.
Usually goes well with <code>IO</code> or <code>Identity</code>, depending if we want to share
an environment between effectful or uneffectful computations.</p>
<p>What <code>ReaderT</code> does is <em>carry</em> a value of type <code>r</code> and passes it around to
other functions when we use the <code>Applicative</code> and <code>Monad</code> interfaces so that
we don't have to pass the value around manually. And when we want to grab
the <code>r</code> and use it, all we have to do is <code>ask</code>.</p>
<p>For our case, this means that instead of Passing around <code>Env</code>, we can instead
convert our functions to use <code>ReaderT</code> - those that are uneffectful and don't use
<code>IO</code>, can return <code>ReaderT Env Identity a</code>  instead of <code>a</code> (or the simplified version, <code>Reader Env a</code>),
and those that are effectful can return <code>ReaderT Env IO a</code> instead of <code>IO a</code>.</p>
<p>Note, as we've said before, <code>Functor</code>, <code>Applicative</code> and <code>Monad</code> all expect the type
that implements their interface to have the kind <code>* -&gt; *</code>.
This means that it is <code>ReaderT r m</code> which implements these interfaces,
and when we compose functions with <code>&lt;*&gt;</code> or <code>&gt;&gt;=</code> we replace the <code>f</code> or <code>m</code>
in their type signature with <code>ReaderT r m</code>.</p>
<p>This means that, as with <code>Either e</code> when we had composed functions with the same error type,
so it is with <code>ReaderT r m</code> - we have to compose functions with the same <code>r</code> type and same
<code>m</code> type, so we can't mix different environment types or different underlying <code>m</code> types.</p>
<p>We're going to use a specialized version of <code>ReaderT</code> that uses a specific <code>m</code> = <code>Identity</code>
called <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2"><code>Reader</code></a>.
The <code>Control.Monad.Reader</code> provides an alias: <code>Reader r a = ReaderT r Identity a</code>.</p>
<blockquote>
<p>If the idea behind <code>ReaderT</code> is still a bit fuzzy to you and you want
to get a better understanding of how <code>ReaderT</code> works,
try doing the following exercise:</p>
<ol>
<li>Choose an <code>Applicative</code> or <code>Monad</code> interface function, I recommend <code>liftA2</code>,
and specialize its type signature by replacing <code>f</code> (or <code>m</code>) with a concrete <code>ReaderT</code> type such as
<code>ReaderT Int IO</code>.</li>
<li>Unpack the <code>ReaderT</code> newtype, replacing <code>ReaderT Int IO t</code> with <code>Int -&gt; IO t</code>.</li>
<li>Implement this specialized version of the function you've chosen</li>
</ol>
<details><summary>Solution for liftA2</summary>
<pre><code class="language-hs">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<details><summary>Solution for (1)</summary>
<pre><code class="language-hs">-- Specialize: replace `f` with `ReaderT Env IO`
liftA2 :: (a -&gt; b -&gt; c) -&gt; ReaderT Env IO a -&gt; ReaderT Env IO b -&gt; ReaderT Env IO c
</code></pre>
</details>
<details><summary>Solution for (2)</summary>
<pre><code class="language-hs">-- Unpack the newtype, replacing `ReaderT Env IO a` with `Env -&gt; IO a`
liftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
</code></pre>
</details>
<details><summary>Solution for (3)</summary>
<pre><code class="language-hs">specialLiftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
specialLiftA2 combine funcA funcB env =
  liftA2 combine (funcA env) (funcB env)
</code></pre>
<p>Notice how the job of our special <code>liftA2</code> for <code>ReaderT</code> is to supply the
two functions with <code>env</code>, and then use the <code>liftA2</code>
implementation of the underlying <code>m</code> type (in our case <code>IO</code>) to do the rest of the work.
Does it look like we're adding a capability on top of a different <code>m</code>?
That's the idea behind monad transformers.</p>
</details>
</details>
</blockquote>
<h3 id="how-to-use-reader"><a class="header" href="#how-to-use-reader">How to use Reader</a></h3>
<h4 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a function</a></h4>
<p>Instead of defining a function like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
</code></pre>
<p>We define it like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
</code></pre>
<p>Now that our code uses <code>Reader</code>, we have to accommodate that in the way we write our function:</p>
<p>Before:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml env txtFiles =
 let
   txtOutputFiles = map toOutputMarkupFile txtFiles
   index = (&quot;index.html&quot;, buildIndex env txtOutputFiles)
   htmlPages = map (convertFile env) txtOutputFiles
 in
   map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we needed to thread the <code>env</code> to the other functions that use it.</p>
<p>After:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
txtsToRenderedHtml txtFiles = do
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
  index &lt;- (,) &quot;index.html&quot; &lt;$&gt; buildIndex txtOutputFiles
  htmlPages &lt;- traverse convertFile txtOutputFiles
  pure $ map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we use <em>do notation</em> now, and <em>instead of threading</em> <code>env</code> around we <em>compose</em>
the relevant functions, <code>buildIndex</code> and <code>convertFile</code>, we use the type classes
interfaces to compose the functions. Note how we needed to <code>fmap</code> over <code>buildIndex</code>
to add the output file we needed with the tuple, and how we needed to use <code>traverse</code> instead
of <code>map</code> to compose the various <code>Reader</code> values <code>convertFile</code> will produce.</p>
<h3 id="extracting-env"><a class="header" href="#extracting-env">Extracting <code>Env</code></a></h3>
<p>When we want to use our <code>Env</code>, we need to <em>extract</em> it from the <code>Reader</code>.
We can do it with:</p>
<pre><code class="language-hs">ask :: ReaderT r m r
</code></pre>
<p>Which yanks the <code>r</code> from the <code>Reader</code> - we can extract with <code>&gt;&gt;=</code> or <code>&lt;-</code> in do notation.
See the comparison:</p>
<p>Before:</p>
<pre><code class="language-hs">convertFile :: Env -&gt; (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile env (file, doc) =
  (file, convert env (takeBaseName file) doc)
</code></pre>
<p>After:</p>
<pre><code class="language-hs">convertFile :: (FilePath, Markup.Document) -&gt; Reader Env (FilePath, Html.Html)
convertFile (file, doc) = do
  env &lt;- ask
  pure (file, convert env (takeBaseName file) doc)
</code></pre>
<blockquote>
<p>Note: we didn't change <code>convert</code> to use <code>Reader</code> because it is a user facing API for our
library. By providing a simpler interface we allow more users to use our library -
even those that aren't yet familiar with monad transformers.</p>
<p>Providing a simple function argument passing interface is preferred in this case.</p>
</blockquote>
<h3 id="run-a-reader"><a class="header" href="#run-a-reader">Run a <code>Reader</code></a></h3>
<p>Similar to handling the errors with <code>Either</code>, at some point we need to supply the environment to
a computation that uses <code>Reader</code>, and extract the result from the computation.
We can do that with the functions <code>runReader</code> and <code>runReaderT</code>:</p>
<pre><code class="language-hs">runReader :: Reader r a -&gt; (r -&gt; a)

runReaderT :: ReaderT r m a -&gt; (r -&gt; m a)
</code></pre>
<p>These functions convert a <code>Reader</code> or <code>ReaderT</code> to a function that takes and <code>r</code>.
Then we can pass the initial environment to that function:</p>
<pre><code class="language-hs">convertDirectory :: Env -&gt; FilePath -&gt; FilePath -&gt; IO ()
convertDirectory env inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>See the <code>let outputHtmls</code>part.</p>
<h3 id="extra-transforming-env-for-a-particular-call"><a class="header" href="#extra-transforming-env-for-a-particular-call">Extra: Transforming <code>Env</code> for a particular call</a></h3>
<p>Sometimes we may want to modify the <code>Env</code> we pass to a particular function call.
For example, we may have a general <code>Env</code> type that contains a lot of information, and
functions that only need a part of that information.</p>
<p>If the functions we are calling are like <code>convert</code> and take the environment as an
argument instead of using a <code>Reader</code>, we can just extract the environment
with <code>ask</code>, apply a function to the extracted environment,
and pass the result to the function, like this:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  pure (inner (extractSmallEnv env))

inner :: SmallEnv -&gt; MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>But if <code>inner</code> uses a <code>Reader SmallEnv</code> instead of argument passing,
we can use <code>runReader</code> to <em>convert <code>inner</code> to a normal function</em>,
and use the same idea as above!</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  -- Here the type of `runReader inner` is `SmallEnv -&gt; MyResult`
  pure (runReader inner (extractSmallEnv env))

inner :: Reader SmallEnv MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>This pattern is generalized and captured by a function called
<a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Reader.html#v:withReaderT">withReaderT</a>,
and works even for <code>ReaderT</code>:</p>
<pre><code class="language-hs">withReaderT :: (env2 -&gt; env1) -&gt; ReaderT env1 m a -&gt; ReaderT env2 m a
</code></pre>
<p><code>withReaderT</code> takes a function that modifies the environment,
and converts a <code>ReaderT env1 m a</code> computation to a <code>ReaderT env2 m a</code> computation
using this function.</p>
<p>Let's see it concretely with our example:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = withReaderT extractSmallEnv inner
</code></pre>
<hr />
<p>Question: what is the type of <code>withReaderT</code> when specialized in our case?</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">withReaderT
  :: (BigEnv -&gt; SmallEnv)     -- This is the type of `extractSmallEnv`
  -&gt; Reader SmallEnv MyResult -- This is the type of `inner`
  -&gt; Reader BigEnv   MyResult -- This is the type of `outer`
</code></pre>
</details>
<hr />
<p>Note the order of the environments! We use a function from a <code>BigEnv</code> to a <code>SmallEnv</code>,
to convert a <code>Reader</code> of <code>SmallEnv</code> to a <code>Reader</code> of <code>BigEnv</code>!</p>
<p>This is because we are mapping over the <em>input</em> of a function rather than the <em>output</em>,
and is related to topics like variance and covariance, but isn't terribly important
for us at the moment.</p>
<h3 id="using-env-in-our-logic-code"><a class="header" href="#using-env-in-our-logic-code">Using <code>Env</code> in our logic code</a></h3>
<p>One thing we haven't talked about yet is actually using our environment in the <code>convert</code>
function to generate the pages we want. And actually, we don't even have the ability to add
stylesheets to our HTML EDSL at the moment! We need to go back and extend it. Let's do all
that now:</p>
<hr />
<p>Since stylesheets go in the <code>head</code> element, perhaps it's a good idea to create an additional
<code>newtype</code> like <code>Structure</code> for <code>head</code> information? Things like title, stylesheet,
and even meta elements can be composed together just like we did for <code>Structure</code>
to build the <code>head</code>!</p>
<ol>
<li>
<p>Do it now: extend our HTML library to include headings and add 3 functions:
<code>title_</code> for titles, <code>stylesheet_</code> for stylesheets, and <code>meta_</code> for meta elements
like <a href="https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards">twitter cards</a>.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Html.hs</summary>
<pre><code class="language-hs">-- Html.hs

module HsBlog.Html
  ( Html
  , Head
  , title_
  , stylesheet_
  , meta_
  , Structure
  , html_
  , p_
  , h_
  , ul_
  , ol_
  , code_
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
  where

import Prelude hiding (head)
import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/HsBlog/Html/Internal.hs</summary>
<pre><code class="language-hs">newtype Head
  = Head String

-- * EDSL

html_ :: Head -&gt; Structure -&gt; Html
html_ (Head head) content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; head
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Head

title_ :: String -&gt; Head
title_ = Head . el &quot;title&quot; . escape

stylesheet_ :: FilePath -&gt; Head
stylesheet_ path =
  Head $ &quot;&lt;link rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

meta_ :: String -&gt; String -&gt; Head
meta_ name content =
  Head $ &quot;&lt;meta name=\&quot;&quot; &lt;&gt; escape name &lt;&gt; &quot;\&quot; content=\&quot;&quot; &lt;&gt; escape content &lt;&gt; &quot;\&quot;&gt;&quot;

instance Semigroup Head where
  (&lt;&gt;) (Head h1) (Head h2) =
    Head (h1 &lt;&gt; h2)

instance Monoid Head where
  mempty = Head &quot;&quot;
</code></pre>
</details>
</details>
</li>
<li>
<p>Fix <code>convert</code> and <code>buildIndex</code> to use the new API. Note: <code>buildIndex</code> should return
<code>Reader</code>!</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Convert.hs</summary>
<pre><code class="language-hs">import Prelude hiding (head)
import HsBlog.Env (Env(..))

convert :: Env -&gt; String -&gt; Markup.Document -&gt; Html.Html
convert env title doc =
  let
    head =
      Html.title_ (eBlogName env &lt;&gt; &quot; - &quot; &lt;&gt; title)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
    article =
      foldMap convertStructure doc
    websiteTitle =
      Html.h_ 1 (Html.link_ &quot;index.html&quot; $ Html.txt_ $ eBlogName env)
    body =
      websiteTitle &lt;&gt; article
  in
    Html.html_ head body
</code></pre>
</details>
<details><summary>src/HsBlog/Directory.hs</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Reader Env Html.Html
buildIndex files = do
  env &lt;- ask
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Head 1 head : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ head))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  pure $ Html.html_
      ( Html.title_ (eBlogName env)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
      )
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
</details>
</li>
<li>
<p>Create a command-line parser for <code>Env</code>, attach it to the <code>convert-dir</code> command,
and pass the result it to the <code>convertDirectory</code> function.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">import HsBlog.Env (defaultEnv)

convertSingle :: String -&gt; Handle -&gt; Handle -&gt; IO ()

process :: String -&gt; String -&gt; String
process title = Html.render . convert defaultEnv title . Markup.parse
</code></pre>
</details>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">import HsBlog.Env

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath Env
  deriving Show

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir &lt;*&gt; pEnv

-- | Parser for blog environment
pEnv :: Parser Env
pEnv =
  Env &lt;$&gt; pBlogName &lt;*&gt; pStylesheet

-- | Blog name parser
pBlogName :: Parser String
pBlogName =
  strOption
    ( long &quot;name&quot;
      &lt;&gt; short 'N'
      &lt;&gt; metavar &quot;STRING&quot;
      &lt;&gt; help &quot;Blog name&quot;
      &lt;&gt; value (eBlogName defaultEnv)
      &lt;&gt; showDefault
    )

-- | Stylesheet parser
pStylesheet :: Parser String
pStylesheet =
  strOption
    ( long &quot;style&quot;
      &lt;&gt; short 'S'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Stylesheet filename&quot;
      &lt;&gt; value (eStylesheetPath defaultEnv)
      &lt;&gt; showDefault
    )

</code></pre>
</details>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output env -&gt;
      HsBlog.convertDirectory env input output

    ...
</code></pre>
</details>
</details>
</li>
</ol>
<hr />
<h3 id="summary-11"><a class="header" href="#summary-11">Summary</a></h3>
<p>Which version do you like better? Manually passing arguments, or using <code>Reader</code>?</p>
<p>To me, it is not clear that the second version with <code>Reader</code> is better than the first
with explicit argument passing in our particular case.</p>
<p>Using <code>Reader</code> and <code>ReaderT</code> makes our code a little less friendly toward beginners
that are not yet familiar with these concepts and techniques, and we don't see
(in this case) much benefit.</p>
<p>As programs grow larger, techniques like using <code>Reader</code> become more attractive to use.
For our relatively small example, using <code>Reader</code> might not be appropriate.
I've included it in this book because it is an important technique to have in our
arsenal and I wanted to demonstrate it.</p>
<p>It is important to weigh the benefits and costs of using advanced techniques,
and it's often better to try and get away with simpler techniques if we can.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/b4c986fb52cd6d78a1acecad189490a8d13f8909">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/b4c986fb52cd6d78a1acecad189490a8d13f8909">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>We want to add some tests to our blog generator. At the very least
a few regression tests to make sure that if we extend or change our markup parsing code,
HTML generation code, or translation from markup to HTML code, and make a mistake, we'll
have a safety net alerting us of issues.</p>
<p>We will use the <a href="https://hspec.github.io/">hspec</a> testing framework to write our tests.
There are other testing frameworks in Haskell, for example
<a href="https://hackage.haskell.org/package/tasty">tasty</a>, but I like <code>hspec</code>'s documentation,
so we'll use that.</p>
<h2 id="initial-setup"><a class="header" href="#initial-setup">Initial setup</a></h2>
<h3 id="cabal-file-additions"><a class="header" href="#cabal-file-additions">Cabal file additions</a></h3>
<p>We're going to define a new section in our <code>hs-blog-gen.cabal</code> file for our new test suite.
This section is called <code>test-suite</code> and it is fairly similar to the <code>library</code> and
<code>executable</code> sections.</p>
<p>The interfaces for how to define a test suite are described in the
<a href="https://cabal.readthedocs.io/en/3.6/cabal-package.html#test-suites">Cabal documentation</a>.
We are going to use the <code>exitcode-stdio-1.0</code> interface. Let's go over the different settings
and options:</p>
<pre><code class="language-cabal">test-suite hs-blog-gen-test
  import: common-settings
  type: exitcode-stdio-1.0
  hs-source-dirs: test
  main-is: Spec.hs

  -- other-modules:
  build-depends:
      base
    , hspec
    , hspec-discover
    , raw-strings-qq
    , hs-blog
  ghc-options:
    -O -threaded -rtsopts -with-rtsopts=-N
  build-tool-depends:
    hspec-discover:hspec-discover
</code></pre>
<ul>
<li><code>hs-source-dirs: test</code> - The directory of the source file for the test suite</li>
<li><code>main-is: Spec.hs</code> - The entry point to the test suite source file</li>
<li><code>other-modules</code> - The modules in our test suite.
Currently commented out because we haven't added any yet.</li>
<li><code>build-depends</code> - The packages we are going to use:
<ul>
<li><a href="https://hackage.haskell.org/package/base"><code>base</code></a> -
The standard library for Haskell, as we've used before</li>
<li><a href="https://hackage.haskell.org/package/hspec"><code>hspec</code></a> -
The test framework we are going to use</li>
<li><a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> -
Automatic discovery of hspec tests</li>
<li><a href="https://hackage.haskell.org/package/raw-strings-qq"><code>raw-strings-qq</code></a> -
Additional syntax for writing raw string literals</li>
<li><code>hs-blog</code> - Our library</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/3.6/cabal-package.html#pkg-field-ghc-options"><code>ghc-options</code></a> -
Extra options and flags for GHC
<ul>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-optimisation.html#options-optimise"><code>-O</code></a> -
Compile with optimizations</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--threaded"><code>-threaded</code></a> -
Use the multi-core runtime instead of single-core runtime. The multi-core
runtime is generally a bit slower in my experience, but when writing code that actually uses
multiple cores (such as a test framework that runs tests in parallel) it can gives a good
performance boost.</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts</code></a> -
lets us manipulate the Haskell runtime system by passing command-line arguments to our application</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=-N</code></a> -
Set specific default options for the program at link-time.
Specifically, <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--N%20%E2%9F%A8x%E2%9F%A9"><code>-N</code></a>
Sets the number of cores to use in our program.</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/3.6/cabal-package.html#pkg-field-build-tool-depends"><code>build-tool-depends</code></a> -
Uses a specific executable from a package dependency in aid of building the package.
In this case, we are using the <code>hspec-discover</code> executable from the
<a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> package, which
goes over the source directory for the tests, finds all of the <code>Spec</code> files,
and creates an entry point for the program that will run all the tests it discovered.</li>
</ul>
<h3 id="hspec-discovery"><a class="header" href="#hspec-discovery">Hspec discovery</a></h3>
<p>In order for <code>hspec-discover</code> to work, we need to add the following
to the &quot;main&quot; file of the test suite, for us this is <code>test/Spec.hs</code>:</p>
<pre><code class="language-hs">{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
</code></pre>
<p>That's it! <code>hspec-discover</code> will automatically define a <code>main</code> for us.
Now we can run the tests using <code>stack test</code> or <code>cabal v2-test</code> (your choice).
Because we haven't defined any tests, our output is:</p>
<pre><code class="language-sh">Finished in 0.0000 seconds
0 examples, 0 failures
</code></pre>
<p>When we add new hspec tests, <code>hspec-discover</code> will find and run them automatically
(though we will still need add them to the <code>other-modules</code> section in the cabal file).</p>
<p>For <code>hspec-discover</code> to identify modules as test modules, the modules must follow
a convention:</p>
<ol>
<li>Their module names must end with <code>Spec</code></li>
<li>They must define a value <code>spec :: Spec</code> (which describes the test) and export it
outside of the module (by adding it to the export list of the module, for example).</li>
</ol>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>Let's write our first test. We'll create a new module to test
markup parsing. We'll call it <code>MarkupParsingSpec.hs</code>. We'll need
the following imports as well:</p>
<pre><code class="language-hs">module MarkupParsingSpec where

import Test.Hspec
import HsBlog.Markup
</code></pre>
<p><code>hspec</code> provides us with a monadic interface for describing, composing and
nesting test specifications (<code>Spec</code>s).</p>
<p>Using the <code>describe</code> function we can
describe a group of tests, using the <code>it</code> function we can add a new test,
and using a function like <code>shouldBe</code> we can compare two values and make
sure they are equal by using their <code>Eq</code> instance.
If they are, the test will pass, and if not, it will fail with a descriptive error.</p>
<p>Let's try it and write a test that obviously fails!</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        [Heading 1 &quot;bug&quot;]
</code></pre>
<p>After adding the module to the <code>other-modules</code> list in the cabal file:</p>
<pre><code class="language-hs">  other-modules:
    MarkupParsingSpec
</code></pre>
<p>And running the tests, we get this output:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty FAILED [1]

Failures:

  test/MarkupParsingSpec.hs:10:7:
  1) MarkupParsing, Markup parsing tests, empty
       expected: [Heading 1 &quot;bug&quot;]
        but got: []

  To rerun use: --match &quot;/MarkupParsing/Markup parsing tests/empty/&quot;

Randomized with seed 763489823

Finished in 0.0004 seconds
1 example, 1 failure
</code></pre>
<p>The output describes which tests are running in a hierarchy tree (module, group and test),
whether the tests passed or failed, and if they failed, what was the output and what the expected output was.</p>
<p>We can fix our test by matching the expected output:</p>
<pre><code class="language-hs">      shouldBe
        (parse &quot;&quot;)
        []
</code></pre>
<p>Now, running the tests will produce:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty

Finished in 0.0001 seconds
1 example, 0 failures
</code></pre>
<p>We can add a few more tests:</p>
<pre><code class="language-hs">    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>And run the tests again:</p>
<pre><code class="language-sh">MarkupParsing
  Markup parsing tests
    Test empty
    paragraph
    heading 1
    code

Finished in 0.0003 seconds
4 examples, 0 failures
</code></pre>
<p>This is the gist of writing unit tests with <code>hspec</code>. It's important to note
that we can nest <code>Spec</code>s that are declared with <code>describe</code> to create trees,
and of course refactor and move things to different functions and modules
to make our test suite better organized.</p>
<p>For example, we can write our tests like this:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple

simple :: Spec
simple = do
  describe &quot;simple&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        []

    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>Also, there are other &quot;expectations&quot; like <code>shouldBe</code> that we can use when writing tests.
They are described in the <a href="https://hspec.github.io/expectations.html">hspec tutorial</a>
and can be found in the
<a href="https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html">haddock documentation</a> as well.</p>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>If we want to write multi-line strings, or avoid escaping strings like we did in the &quot;code&quot;
test, we can use a library called
<a href="https://hackage.haskell.org/package/raw-strings-qq">raw-strings-qq</a>
which uses a language extension called
<a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html#extension-QuasiQuotes"><code>QuasiQuotes</code></a>.
<code>QuasiQuotes</code> is a meta-programming extension that provides a mechanism for extending the
syntax of Haskell.</p>
<p>A quasi-quote has the form <code>[quoter| string |]</code>, where the quoter is the name
of the function providing the syntax we wish to use, and the string is our input.</p>
<p>In our case, we use the quoter <code>r</code>, which is defined in
<a href="https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html">raw-strings-qq</a>,
and write any string we want, with multi-lines and unescaped characters!
We could use this to write the tests
<a href="04-markup/01-data_type.html#exercises">we previously wrote</a>:</p>
<pre><code class="language-hs">{-# language QuasiQuotes #-}

...

import Text.RawString.QQ

...

example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]
</code></pre>
<p>And add multi-line tests:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple
    multiline


multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result


example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]

example3Result :: Document
example3Result =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
<p>Running the tests:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    simple
      Test empty
      paragraph
      heading 1
      code
    Multi-line tests
      example3

Finished in 0.0004 seconds
5 examples, 0 failures
</code></pre>
<hr />
<p><strong>Exercise</strong>: Add a test for the fourth example described in the
<a href="04-markup/01-data_type.html#exercises">previous exercises</a>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result

    it &quot;example4&quot; $
      shouldBe
        (parse example4)
        example4Result


example4 :: String
example4 = [r|
* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; â ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
|]

example4Result :: Document
example4Result =
  [ Heading 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;â ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main, or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<hr />
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>This chapter has been just the tip of the iceberg of the Haskell testing landscape.
We haven't talked about
<a href="https://www.scs.stanford.edu/16wi-cs240h/slides/testing.html">property testing</a> or
<a href="https://ro-che.info/articles/2017-12-04-golden-tests">golden testing</a>,
testing expected failures, testing IO code, inspection testing, benchmarking, and more.
There's just too much to cover!</p>
<p>My hope is that this chapter
provided you with the basics of how to start writing tests for your own projects.
Please consult the tutorial for your chosen testing framework, and read more about
this very important subject on your own.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/7c1f70a15b99b37d794615aa1852ffe335023af9">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/7c1f70a15b99b37d794615aa1852ffe335023af9">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-documentation"><a class="header" href="#generating-documentation">Generating documentation</a></h1>
<p>There are <a href="https://documentation.divio.com/">many ways</a>
to make it easier for others to get started with our projects and libraries.
For example, we can write tutorials, provide runnable examples,
describe the internals of the system, and create an API reference.</p>
<p>In this chapter we will focus on generating API reference pages (the kind that can be seen on Hackage)
from annotated Haskell source code using <a href="https://www.haskell.org/haddock">Haddock</a>.</p>
<h2 id="running-haddock"><a class="header" href="#running-haddock">Running Haddock</a></h2>
<p>We can generate API reference pages (a.k.a. haddocks in the Haskell world) for our project
using our favorite package manager:</p>
<h3 id="cabal"><a class="header" href="#cabal">Cabal</a></h3>
<p>We can run <code>cabal v2-haddock</code> to generate haddocks:</p>
<pre><code class="language-sh">â cabal v2-haddock
Resolving dependencies...
Build profile: -w ghc-9.0.1 -O1
In order, the following will be built (use -v for more details):
 - hs-blog-0.1.0.0 (lib) (first run)
Configuring library for hs-blog-0.1.0.0..
Preprocessing library for hs-blog-0.1.0.0..
Running Haddock on library for hs-blog-0.1.0.0..
Haddock coverage:
   0% (  0 /  3) in 'HsBlog.Env'
  Missing documentation for:
    Module header
    Env (src/HsBlog/Env.hs:3)
    defaultEnv (src/HsBlog/Env.hs:10)
  21% (  7 / 33) in 'HsBlog.Html.Internal'
  Missing documentation for:
    Module header
    Html (src/HsBlog/Html/Internal.hs:8)
...
Documentation created:
/tmp/learn-haskell-blog-generator/dist-newstyle/build/x86_64-linux/ghc-9.0.1/hs-blog-0.1.0.0/doc/html/hs-blog/index.html
</code></pre>
<p>Cabal and Haddock will build our project and generate HTML pages for us at:</p>
<pre><code class="language-html">./dist-newstyle/build/&lt;platform&gt;/&lt;compiler&gt;/&lt;package&gt;-&lt;version&gt;/doc/html/&lt;package&gt;/
</code></pre>
<p>We can then open the <code>index.html</code> file from that directory in a web browser and view our package documentation.</p>
<h3 id="stack"><a class="header" href="#stack">Stack</a></h3>
<p>We can run <code>stack haddock</code> to generate haddocks:</p>
<pre><code class="language-sh">â stack haddock
...
hs-blog&gt; build (lib + exe)
Preprocessing library for hs-blog-0.1.0.0..
Building library for hs-blog-0.1.0.0..
[1 of 7] Compiling HsBlog.Env
[2 of 7] Compiling HsBlog.Html.Internal
...
hs-blog&gt; haddock
Preprocessing library for hs-blog-0.1.0.0..
Running Haddock on library for hs-blog-0.1.0.0..
Haddock coverage:
   0% (  0 /  3) in 'HsBlog.Env'
  Missing documentation for:
    Module header
    Env (src/HsBlog/Env.hs:3)
    defaultEnv (src/HsBlog/Env.hs:10)
  21% (  7 / 33) in 'HsBlog.Html.Internal'
  Missing documentation for:
    Module header
    Html (src/HsBlog/Html/Internal.hs:8)
...
Documentation created:
.stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/index.html,
.stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/hs-blog.txt
Preprocessing executable 'hs-blog-gen' for hs-blog-0.1.0.0..
...
</code></pre>
<p>Stack and Haddock will build our project and generate HTML pages for us at:</p>
<pre><code class="language-html">./.stack-work/dist/&lt;platform&gt;/Cabal-&lt;version&gt;/doc/html/&lt;package&gt;/
</code></pre>
<p>We can then open the <code>index.html</code> file from that directory in a web browser and view our package documentation.</p>
<h3 id="haddock-coverage"><a class="header" href="#haddock-coverage">Haddock coverage</a></h3>
<p>Haddock will also output a coverage report when run, and will mention user-exposed constructs which are missing
documentation. These constructs could be module headers, types, data constructors, type classes, functions, values, etc.</p>
<p>For example:</p>
<pre><code class="language-hs">Haddock coverage:
...
   0% (  0 /  3) in 'HsBlog.Convert'
  Missing documentation for:
    Module header
    convert (src/HsBlog/Convert.hs:8)
    convertStructure (src/HsBlog/Convert.hs:23)
  67% (  2 /  3) in 'HsBlog.Directory'
  Missing documentation for:
    buildIndex (src/HsBlog/Directory.hs:80)
...
</code></pre>
<p>We can see that we did not document the <code>HsBlog.Convert</code> at all, and we are missing
documentation for the module header, the <code>convert</code> function and the <code>convertStructure</code> function.</p>
<p>On the other hand, it seems that we do currently have some documentation written for the <code>HsBlog.Directory</code>
module! We'll see why, but first - try to generate haddocks, see the module hierarchy, browse around
the different modules, follow the links of the types, imagine what this API reference could look like,
and let's see how we can improve it.</p>
<h2 id="haddock-markup"><a class="header" href="#haddock-markup">Haddock markup</a></h2>
<p>Haddock builds the API reference pages by building our project, examining the exported modules
and their exported definitions, and grabbing source code comments written in special markup format.</p>
<p>Let's take a quick look at this markup format. We will go over a few important bits,
but if you'd like to learn more, a complete guide for Haddock markup can be found in the
<a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html">Haddock documentation</a>.</p>
<h3 id="documenting-definitions"><a class="header" href="#documenting-definitions">Documenting definitions</a></h3>
<p>All haddock annotations appear as part of regular Haskell comments.
They can be used with both single line form (<code>--</code>) and multi-line form (<code>{-</code> and <code>-}</code>).
The placement of a comment block and the haddock marker determine to which Haskell
definition the haddock string is attached.</p>
<p>We can annotate a Haskell definition by writing a comment block prefixed with <code>|</code> <em>before</em>
the definition, or by writing a comment block prefixed with <code>^</code> <em>after</em> the definition.</p>
<p>For example:</p>
<pre><code class="language-hs">-- | Construct an HTML page from a `Head`
--   and a `Structure`.
html_
  :: Head -- ^ Represents the @\&lt;head\&gt;@ section in an HTML file
  -&gt; Structure -- ^ Represents the @\&lt;body\&gt;@ section in an HTML file
  -&gt; Html
html_ = ...
...
</code></pre>
<p>Here's another example:</p>
<pre><code class="language-hs">{- | Represents a single markup structure. Such as:

- A paragraph
- An unordered list
- A code block
-}
data Structure
  = Heading Natural String
  -- ^ A section heading with a level
  | Paragraph String
  -- ^ A paragraph
  | UnorderedList [String]
  -- ^ An unordered list of strings
  | OrderedList [String]
  -- ^ An ordered list of strings
  | CodeBlock [String]
  -- ^ A code block
</code></pre>
<p>And another:</p>
<pre><code class="language-hs">{- | Markup to HTML conversion module.

This module handles converting documents written in our custom
Markup language into HTML pages.
-}
module HsBlog.Convert where
</code></pre>
<p>As you can see, <code>|</code> and <code>^</code> can be used to document functions, function arguments,
types, data constructors, modules, and more. They are probably the most important
Haddock annotations to remember (and even then, <code>|</code> alone will suffice).</p>
<blockquote>
<p><strong>Tip</strong>: Annotate the modules, types, and the top-level definitions
which are exported from your project
with some high-level description of what they are used for (at the very least).</p>
<p>Your users and collaborators will thank you!</p>
</blockquote>
<h3 id="section-headings"><a class="header" href="#section-headings">Section headings</a></h3>
<p>We can separate our module into sections by adding headings.
Headings are comments which are prefixed with a number of <code>*</code> (just like in our markup language).</p>
<p>For example:</p>
<pre><code class="language-hs">-- * HTML EDSL

html_ :: Head -&gt; Structure -&gt; Html
html_ = ...

-- ** Structure

p_ :: Content -&gt; Structure
p_ = ..

h_ :: Content -&gt; Structure
h_ = ..

...

-- ** Content

txt_ :: String -&gt; Content
txt_ = ...

link_ :: FilePath -&gt; Content -&gt; Content
link_ = ...
</code></pre>
<p>It is also possible to add headings to the export list instead:</p>
<pre><code class="language-hs">module HsBlog.Html
  ( -- * HTML EDSL
    Html
  , html_

    -- ** Combinators used to construct the @\&lt;head\&gt;@ section
  , Head
  , title_
  , stylesheet_
  , meta_

    -- ** Combinators used to construct the @\&lt;body\&gt;@ section
  , Structure
  , p_
  , h_
  , ul_
  , ol_
  , code_

    -- ** Combinators used to construct content inside structures
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_

    -- ** Render HTML to String
  , render
  )
  where
</code></pre>
<p>Separating parts of the module into sections helps keeping the important things together
and Haddock will create a table-of-contents at the top of a module page for us as well.</p>
<p>Sometimes it's also easier to figure out whether a module should be split into multiple
modules or not after splitting it into sections using headings.</p>
<hr />
<p><strong>Exercise</strong>: Try to re-arrange the modules in our project to your liking and add headings to sections.</p>
<hr />
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<p>As we saw earlier, we can also add formatting in the content of our comments.
For example, we can:</p>
<ul>
<li>
<p>Hyperlink identifiers by surrounding them with <code>`</code>.</p>
<p>For example: <code>`Heading`</code></p>
</li>
<li>
<p>Write <code>monospaced text</code> by surrounding it with <code>@</code>.</p>
<p>For example: <code>@Paragraph &quot;Hello&quot;@</code></p>
</li>
<li>
<p>Add <em>emphasis</em> to text by surrounding it with <code>/</code>.</p>
<p>For example: <code>/this is emphasised/</code></p>
</li>
<li>
<p>Add <strong>bold</strong> to text by surrounding it with <code>__</code>.</p>
<p>For example: <code>__this is bold__</code></p>
</li>
</ul>
<h3 id="more"><a class="header" href="#more">More</a></h3>
<p>In this chapter we've covered the basics of the Haddock markup language.
If you'd like to know more, the <a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html">Haddock markup guide</a>
contains information on how to create even more interesting documentation structures, such as
code blocks, grid tables, images and examples.</p>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>We've briefly covered one aspect of documenting Haskell programs:
using Haddock to generate informative API reference pages created from source code
comments which are annotated with Haddock markup.</p>
<p>While API references are incredibly valuable, remember that there are other forms of
documentation that can help your users get started quickly, such as examples and tutorials.</p>
<hr />
<p><strong>Exercise</strong>: Add haddock annotation to the top-level definitions in our project and test your understanding
of the program and the various parts - sometimes the best way to learn something is to try explaining it!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recap"><a class="header" href="#recap">Recap</a></h1>
<p>In this book we've implemented a very simple static blog generator while learning Haskell as we go.</p>
<ul>
<li>We've learned about basic Haskell building blocks, such as definitions, functions,
types, modules, recursion, pattern matching, type classes, IO and exceptions.</li>
<li>We've learned about <a href="./03-html/03-edsls.html">EDSLs</a> and used the <em>combinator pattern</em> to implement
a composable html generation library.</li>
<li>We've learned how to leverage types, modules and smart constructors
to <a href="./03-html/04-safer_construction.html">make invalid states unrepresentable</a>.</li>
<li>We've learned how to represent complex data using <a href="./04-markup/01-data_type.html">ADTs</a>.</li>
<li>We've learned how to use <a href="./04-markup/04-parsing_02.html#pattern-matching">pattern matching</a> to transform ADTs,
and how to use <a href="./04-markup/02-parsing_01.html#recursion-and-accumulating-information">recursion</a> to solve problems.</li>
<li>We've used the <em>functional core, imperative shell</em> approach to build a program that handles IO and applies
our domain logic to user inputs.</li>
<li>We've learned about abstractions such as <a href="./05-glue/01-markup_to_html.html#monoids">monoids</a>,
<a href="./05-glue/04-optparse.html#functor">functors</a> and <a href="./06-errors_and_files/01-either.html#monadic-interface">monads</a>, 
and how they can help us reuse code and convey information about shared interfaces.</li>
<li>We've learned how to create fancy <a href="./05-glue/04-optparse.html">command-line interfaces</a>, <a href="./08-testing.html">write tests</a>,
and <a href="./09-documentation.html">generate documentation</a>.</li>
</ul>
<p>While Haskell is a very big and complex language, and there's always more to be learned, 
I think we've reached an important milestone where
you can start building your own Haskell projects and be productive with Haskell!</p>
<p>This is a good time to celebrate and pat yourself on the back for getting this far! Great job, you!</p>
<p>If you'd like to learn even more about Haskell and continue your Haskell journey
beyond this book, check out the appendix sections <a href="./11-next.html">Where to go next</a> and the <a href="./12-faq.html">FAQ</a>.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">Thank you!</a></h2>
<p>Thank you for reading this book. I hope you enjoyed it and found Haskell interesting.</p>
<p>I would very much like to hear your feedback. If you'd like, you could leave your
feedback at this book's
<a href="https://github.com/soupi/learn-haskell-blog-generator/issues">GitHub issue board</a>,
or you could reach me directly on <a href="https://twitter.com/_gilmi">Twitter</a> or via email.
You can find my contact information <a href="https://gilmi.me">on my website</a>.</p>
<p>If you liked this book, do let me know - your kind words mean a lot.</p>
<blockquote>
<p>Finally, if you <em>really</em> liked this book and would like to support future passion projects
like it, you can <a href="https://ko-fi.com/gilmi">support me directly via Ko-fi</a>.</p>
</blockquote>
<p>Thank you and good luck with your next Haskell project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next</a></h1>
<p>Haskell is an incredibly rich and deep programming language.
New cutting-edge techniques, concepts and features are still being discovered
and sometimes integrated into GHC. This sometimes makes it seem impossible
to catch up to.</p>
<p>This phenomena is sometimes dubbed
<a href="https://patrickmn.com/software/the-haskell-pyramid/">The Haskell pyramid</a>.
My hope is that by reading this book and following the exercises,
you readers have reached the bar of productivity, and you can now go and start
working on your own projects with Haskell. I highly encourage you to do so.
In my opinion, writing useful Haskell projects is the best method to solidify
what you currently know, and identify what you still need to learn.</p>
<h2 id="extending-this-project"><a class="header" href="#extending-this-project">Extending this project</a></h2>
<p>If you'd like to extend this project, here are a few ideas for you:</p>
<ol>
<li><strong>Serve over HTTP</strong> - You can use a web library such as
<a href="https://www.youtube.com/watch?v=mz5_HmLGRXc">wai</a> or
<a href="https://gilmi.me/blog/post/2020/12/05/scotty-bulletin-board">scotty</a>
to serve this blog over HTTP instead of generating it statically</li>
<li><strong>Rewrite it with libraries</strong> - you could rewrite it and use a real-world
<a href="https://hackage.haskell.org/package/blaze-html">HTML package</a>
and <a href="https://hackage.haskell.org/package/cheapskate">markdown parser</a></li>
<li><strong>Add features</strong>
<ol>
<li>You could add a metadata block at the top of each article
which would include the title, publish date and tags of a blog post,
and use them when generating HTML, index page and even tags pages</li>
<li>You could add HTML pages templating using
<a href="https://hackage.haskell.org/package/mustache">mustache</a> or similar,
and use that to generate a nice and customizable structure to the page</li>
<li>You could add support for links and images in our markup language parser</li>
<li>Add support for configuration via files which would include things like
the blog title, description, or other meta information for things like
<a href="https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards">twitter cards</a></li>
</ol>
</li>
</ol>
<p>Or anything else you can think about, consider this project your playground and
do whatever you like with it!</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>At some point you are likely to run into new concepts, techniques,
or even just a feeling of &quot;I feel like this could be done better&quot;.
I'd like to point you in the right direction so you can find additional information
and learn new Haskell things when you need to or want to.</p>
<p>I've compiled a list of resources for learning Haskell called
<a href="https://github.com/soupi/haskell-study-plan">Haskell study plan</a>,
it should include links to very useful articles, community hubs and news aggregators,
project suggestions, and even cool open-source Haskell projects.
You will also find alternative explanations to thing we've covered
and even links to other Haskell tutorials, guides and books in case you need
a different view on things.</p>
<p>Also, the <a href="http://downloads.haskell.org/%7Eghc/latest/docs/html/users_guide/index.html">GHC User Guide</a>
is a fantastic resource with loads of articles and information about the language and GHC tooling around it.
It is often the best place to learn about Haskell the language.</p>
<p>However, don't feel pressured to learn everything Haskell
has to offer right away, mastering Haskell is a journey that can take a lot of time.
Most of us are definitely not there yet, but we can still be very productive with Haskell,
build real-world projects, and even discover new techniques and concepts ourselves.</p>
<p>Remember that in a lazy language we evaluate things only when we need them.
Maybe we can do that too with Haskell concepts!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<blockquote>
<p>Got a question? You can ask in the <a href="https://github.com/soupi/learn-haskell-blog-generator/issues">book's issue tracker</a>!</p>
</blockquote>
<h2 id="general-questions"><a class="header" href="#general-questions">General questions</a></h2>
<h3 id="how-to-install-editor-tools"><a class="header" href="#how-to-install-editor-tools">How to install editor tools</a></h3>
<p>As far as I know, the most recommended setup today for Haskell development is using
VSCode or <a href="https://vscodium.com/">VSCodium</a> together with the
marketplace <a href="https://marketplace.visualstudio.com/items?itemName=haskell.haskell">Haskell extension</a>.</p>
<p>The Haskell extension uses <a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a>
which can be install via <a href="https://www.haskell.org/ghcup/">GHCup</a> or even via the Haskell extension itself.</p>
<p>There are <a href="https://github.com/soupi/haskell-study-plan#tools">other options</a>
of course if this setup isn't your jam.</p>
<h3 id="how-to-learn-new-things"><a class="header" href="#how-to-learn-new-things">How to learn new things</a></h3>
<p>The Haskell community keeps marching forward, developing new libraries, tools and techniques
as well as creating new material for older concepts.
The <a href="https://haskell.pl-a.net">Haskell planetarium</a> aggregates feeds from several communities into
one page, as well as a <a href="https://haskellweekly.news/">Haskell Weekly newsletter</a>.
You might also find the quite a bit of Haskell presence on
<a href="https://twitter.com/search?q=%23Haskell&amp;src=typeahead_click">Twitter</a>!</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="how-to-debug-haskell-code"><a class="header" href="#how-to-debug-haskell-code">How to debug Haskell code</a></h3>
<p>Most imperative languages provide a step debugger. While the
<a href="http://downloads.haskell.org/%7Eghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger">GHCi debugger</a>,
exists it is not particularly easy to use, especially because of Haskell's lazy evaluation where things
might not evaluated at the order we might intuitively expect. Because of that,
Haskellers tend to use
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Debug-Trace.html#g:1">trace debugging</a> and
equational reasoning. With trace debugging, we try to <em>verify our assumptions</em> about the code -
we use the various <code>trace</code> functions as a &quot;hack&quot; to print variables, functions inputs, functions output
or even just say &quot;got here&quot;, from anywhere at the code.</p>
<p>After finding something that does not match our assumptions, such as unexpected input or output
of a function, we try to think what piece of code could be responsible for the discrepancy, or even use
trace debugging again to pinpoint the exact location, and try to use &quot;equational reasoning&quot; to
evaluate the offending code that betrayed our expectations. If it's easy to do, we try running
the function in <code>ghci</code> with different inputs to check our assumptions as well.</p>
<p>Because Haskell focuses on immutability, composibility and using types to eliminate many
classes of possible errors, &quot;local reasoning&quot; becomes possible, and trace debugging
becomes a viable strategy for debugging Haskell programs.</p>
<h3 id="how-to-understand-type-errors"><a class="header" href="#how-to-understand-type-errors">How to understand type errors</a></h3>
<p>GHC type errors are often not the most friendly errors messages, but they mean well! They are just
trying to help us find inconsistencies in our code - often with regards to type usage, they help us
avoid making errors.</p>
<p>When you run into error messages, start by reading the messages themselves carefully
until you get used to them, and then the offending code hinted by the error message.
As you gain experience, it is likely that the most important part of an error will be the location
of the offending code, and by reading the code we can find the error without the actual error message.</p>
<p>Adding type signatures and annotations to test your understanding of the types also helps greatly.
We can even ask GHC for the expected type in a certain place by using
<a href="http://downloads.haskell.org/%7Eghc/latest/docs/html/users_guide/exts/typed_holes.html">typed holes</a>.</p>
<h3 id="my-program-is-slow-why"><a class="header" href="#my-program-is-slow-why">My program is slow. Why?</a></h3>
<p>There could be various reasons. From using inefficient algorithms or using an
<a href="https://github.com/soupi/haskell-study-plan#data-structures">unsuited data structure</a> for the task
in terms of time complexity of the common operations, to less efficient memory representations
(this is another reminder to use <code>Text</code> over <code>String</code> in most cases),
and laziness issues (again, the evaluation strategy!).</p>
<p>The <a href="https://github.com/soupi/haskell-study-plan#performance">performance section</a> in my Haskell
study plan links to various resources on Haskell evaluation, profiling and case studies.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="how-to-structure-programs"><a class="header" href="#how-to-structure-programs">How to structure programs</a></h3>
<p>Start with the imperative shell functional core approach, define EDSLs with the combinator
pattern for logic if needed, use monadic capabilities such as State locally if needed,
maybe add an environment configuration with ReaderT, see how it goes.</p>
<p>If that approach fails you, look at why it failed and examine other solutions according to your needs.</p>
<h3 id="how-to-model-data"><a class="header" href="#how-to-model-data">How to model data</a></h3>
<p>Modeling data using ADTs are usually the way to go. Often programmers coming from object oriented
background tend to look at type classes as a way to define methods similar to inheritance,
but this often isn't the right approach and ADTs with different constructors for different alternatives
go a long way. Remember that even OOP people often preach for composition over inheritance.</p>
<p>Use functions to define behavior on data rather than trying to couple the two together.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
