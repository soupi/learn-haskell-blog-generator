<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn Haskell by building a blog generator</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-book"><a class="header" href="#about-this-book">About this book</a></h1>
<blockquote>
<p style="text-align: center;"><img src="book-logo-transparent.png" alt="book logo" style="max-height: 1.5em; vertical-align: top"> This book is actively maintained. If you find errors, <a href="https://github.com/soupi/learn-haskell-blog-generator/issues">please let me know</a>.</p>
</blockquote>
<!--
<div style="text-align: center">
  <img src="book-logo-transparent.png" alt="book logo" style="max-width: 40%">
</div>
-->
<p>In this book, we will implement a simple static blog generator in Haskell,
converting documents written in our own custom markup language to HTML.</p>
<p>We will:</p>
<ol>
<li>Implement a tiny HTML printer library</li>
<li>Define and parse our own custom markup language</li>
<li>Read files and glue things together</li>
<li>Add command line arguments parsing</li>
<li>Write tests and documentation</li>
</ol>
<p>In each chapter of the book, we will focus on a particular task we wish to achieve,
and throughout the chapter, learn just enough Haskell to complete the task.</p>
<h2 id="other-ways-to-read-this-book"><a class="header" href="#other-ways-to-read-this-book">Other ways to read this book</a></h2>
<div style="display: flex; flex-wrap: wrap; align-items: center; justify-content: center;">
<div style="text-align: center; margin: 5px">
  <a href="https://www.youtube.com/watch?v=ZL0qExCnO8g&list=PLxn_Aq3QlOQcXoHWdzxnnuGlGWNXJg43R&index=1" title="Learn Haskell by building a blog video series by Impure Pics">
    <img style="max-height: 140px;" src="https://i.ytimg.com/vi/ZL0qExCnO8g/hqdefault.jpg?sqp=-oaymwEXCNACELwBSFryq4qpAwkIARUAAIhCGAE=&rs=AOn4CLDQbKeP3DE3OL0JN1oL8FYWyQ85JA" border=1>
  </a>
  <p style="width: 260px; margin: 0px;">Do you prefer watching videos?<br>
  <a href="https://impurepics.com">Impure Pics</a> made a video series based on this book!
  </p>
</div>
<div style="text-align: center; margin: 5px">
  <a href="lhbg-v0.pdf" title="Experimental v0 PDF version of this book">
    <img style="max-height: 140px;" src="pdf.png" border=1>
  </a>
  <p style="width: 260px; margin: 0px;">Do you prefer reading PDFs?<br>
  An experimental PDF version is now available.</p>
</div>
</div>
<h2 id="why-should-you-read-this-book"><a class="header" href="#why-should-you-read-this-book">Why should you read this book?</a></h2>
<blockquote>
<p style="text-align: center;"> Looking for reviews and mentions? <a href="https://github.com/soupi/learn-haskell-blog-generator/discussions/67">Click here</a>.</p>
</blockquote>
<p>There are many Haskell tutorials, guides, and books out there. Why read this one?</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<p>There are probably more, but here are a few possible pros:</p>
<ul>
<li>It is <strong>relatively short</strong> - most Haskell books are hundreds of pages long.
This book (when exported to PDF) is roughly 150 pages long.</li>
<li>It is <strong>project oriented</strong>. Many Haskell books teach Haskell by teaching the underlying
concepts and features in a neat progression. In this book, we <strong>build a Haskell program</strong>
and learn Haskell on the way. This will be a pro to some and a con to others.<br>
There are other tutorials like this. The most notable ones are
<a href="https://www.apress.com/gp/book/9781430262510#otherversion=9781430262503">Beginning Haskell</a>
and <a href="https://haskell-via-sokoban.nomeata.de/">Haskell via Sokoban</a>.</li>
<li>It touches on <strong>important topics</strong> such as design patterns, testing, and documentation.</li>
<li>It has <strong>many exercises</strong> as well as <strong>solutions</strong> to those exercises.</li>
<li>It's <strong>online</strong>, which means corrections are easy to make.</li>
<li>It's <strong>free</strong>.</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<p>There are probably more, but here are a few possible cons:</p>
<ul>
<li>It <strong>may lack depth</strong> - many, much longer Haskell tutorials are long because they go
deeper into the nuts and bolts of each feature, and I tried to keep this book relatively short.</li>
<li>It <strong>may not cover as many features or techniques</strong> as other tutorials -
we try to cover features as they pop up in our implementation, but we will
probably miss features that aren't as important for our tasks,
while other resources may try to cover many different use cases.</li>
<li>It <strong>does not have a technical editor</strong>, though it has seen quite a bit of editing.</li>
</ul>
<h3 id="other-learning-resources"><a class="header" href="#other-learning-resources">Other learning resources</a></h3>
<p>The <a href="https://www.haskell.org/documentation/">haskell.org/documentation</a> page lists
many tutorials, books, guides, and courses. You can find a few alternatives that I can
recommend <a href="https://github.com/soupi/haskell-study-plan#about-this-guide">in this list</a>.</p>
<h3 id="who-am-i"><a class="header" href="#who-am-i">Who am I?</a></h3>
<p>I'm
<a href="https://gilmi.me"><img src="https://avatars.githubusercontent.com/u/8547573" alt="🐨" style="border-radius: 100px; max-height: 1.5em; vertical-align: top">
gilmi</a>.</p>
<h2 id="discussions"><a class="header" href="#discussions">Discussions</a></h2>
<p>Do you want to discuss the book? Maybe ask a question?
Try the <a href="https://github.com/soupi/learn-haskell-blog-generator/discussions">discussion board</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h1>
<p>In this chapter, we will create a simple HTML &quot;hello world&quot; program and use the Haskell toolchain
to compile and run it.</p>
<blockquote>
<p>If you haven't installed a Haskell toolchain yet, visit
<a href="https://haskell.org/downloads">haskell.org/downloads</a> for instructions on how to download
and install a Haskell toolchain.</p>
</blockquote>
<h2 id="a-haskell-source-file"><a class="header" href="#a-haskell-source-file">A Haskell source file</a></h2>
<p>A Haskell source file is composed of definitions.</p>
<p>The most common type of definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; = &lt;expression&gt;
</code></pre>
<p>Note that:</p>
<ol>
<li>Names must start with a lowercase letter</li>
<li>We cannot use the same name more than once in a file</li>
</ol>
<p>A source file containing a definition of the name <code>main</code> can be treated as an executable,
and the expression <code>main</code> is bound to is the entry point to the program.</p>
<p>Let's create a new Haskell source file called <code>hello.hs</code> and write the following line there:</p>
<pre><code class="language-hs">main = putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>We've defined a new name, <code>main</code>, and bound it to the expression <code>putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>.</p>
<p>the body of <code>main</code> means calling the function <code>putStrLn</code> with the string <code>&quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>
as input. <code>putStrLn</code> takes a single string as input and prints that string to the standard output.</p>
<p><strong>Note</strong>: we don't need parenthesis to pass arguments to functions in Haskell.</p>
<p>Running this program will result in the following text printed on the screen:</p>
<pre><code>&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>Note that we cannot just write <code>putStrLn &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;</code>
without the <code>main =</code> part, because it is not a definition. This is something that is allowed
in languages such as Python and OCaml, but not in Haskell or, for example, C.</p>
<h2 id="compiling-programs"><a class="header" href="#compiling-programs">Compiling programs</a></h2>
<p>To run this little program, we can compile it using the command line program <code>ghc</code>:</p>
<pre><code class="language-sh">&gt; ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
</code></pre>
<p>Invoking <code>ghc</code> with <code>hello.hs</code> will create the following artifact files:</p>
<ol>
<li><code>hello.o</code> - Object file</li>
<li><code>hello.hi</code> - Haskell interface file</li>
<li><code>hello</code> - A native executable file</li>
</ol>
<p>And after the compilation, we can run the <code>hello</code> executable:</p>
<pre><code class="language-sh">&gt; ./hello
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<h2 id="interpreting-programs"><a class="header" href="#interpreting-programs">Interpreting programs</a></h2>
<p>Alternatively, we can skip the compilation and creation of artifact files phase and run the source file directly
using the command line program <code>runghc</code>:</p>
<pre><code class="language-sh">&gt; runghc hello.hs
&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>We can also redirect the output of the program to a file and then open it in Firefox.</p>
<pre><code class="language-sh">&gt; runghc hello.hs &gt; hello.html
&gt; firefox hello.html
</code></pre>
<p>This command should open Firefox and display a web page with <code>Hello, world!</code> written in it.</p>
<p>I recommend using <code>runghc</code> with this tutorial. While compiling produces significantly faster programs,
interpreting programs provides us with faster feedback while we are developing and making frequent changes.</p>
<blockquote>
<p>If you want to learn more about the core Haskell tools, you can read
<a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools">this article</a>,
but what's described above is enough for our usage at the moment.</p>
</blockquote>
<h2 id="more-bindings"><a class="header" href="#more-bindings">More bindings</a></h2>
<p>We can define the HTML string passed to <code>putStrLn</code> in a new name instead of passing
it directly to <code>putStrLn</code>. Change the content of the <code>hello.hs</code> file we defined above to:</p>
<pre><code class="language-hs">main = putStrLn myhtml

myhtml = &quot;&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p><strong>Note</strong>: the order in which we declare the bindings does not matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-an-html-printer-library"><a class="header" href="#building-an-html-printer-library">Building an HTML printer library</a></h1>
<p>In this part, we'll explore a few basic building blocks in Haskell,
including functions, types, and modules, while building a small HTML printer library
with which we will later construct HTML pages from our markup blog posts.</p>
<p>If you're not familiar with HTML and would like a quick tutorial before diving in, MDN's
<a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started">Getting started with HTML</a>
is a good overview of the subject.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flexible-html-content-functions"><a class="header" href="#flexible-html-content-functions">Flexible HTML content (functions)</a></h1>
<p>We'd like to be able to write different HTML pages without having to write the whole
structure of HTML and body tags over and over again. We can do that with functions.</p>
<p>To define a function, we create a definition as we saw previously and add the argument
names after the name and before the equals sign (<code>=</code>).
So a function definition has the following form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; = &lt;expression&gt;
</code></pre>
<p>The argument names will be available in scope on the right side of the equals sign
(in the <code>&lt;expression&gt;</code>), and the function name will be <code>&lt;name&gt;</code>.</p>
<p>We'll define a function that takes a string, which is the content of the page, and wraps it in
the relevant <code>html</code> and <code>body</code> tags by concatenating them before and after the content.
We use the operator <code>&lt;&gt;</code> to concatenate two strings.</p>
<pre><code class="language-hs">wrapHtml content = &quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>This function, <code>wrapHtml</code>, takes one argument named <code>content</code> and returns a string
that prefixes <code>&lt;html&gt;&lt;body&gt;</code> before the content and appends <code>&lt;/body&gt;&lt;/html&gt;</code> after it.
Note that it is common to use camelCase in Haskell for names.</p>
<p>Now we can adjust our <code>myhtml</code> definition from the previous chapter:</p>
<pre><code class="language-hs">myhtml = wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>Again, notice that we don't need parenthesis when calling functions. Function calls have the form:</p>
<pre><code class="language-hs">&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt;
</code></pre>
<p>However, if we wanted to substitute <code>myhtml</code> with the expression <code>myhtml</code> is bound
to in <code>main = putStrLn myhtml</code>, we would have to wrap the expression in parenthesis:</p>
<pre><code class="language-hs">main = putStrLn (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p>If we accidentally write this instead:</p>
<pre><code class="language-hs">main = putStrLn wrapHtml &quot;Hello, world!&quot;
</code></pre>
<p>we'll get an error from GHC stating that <code>putStrLn</code> is applied to two arguments,
but it only takes one. This is because the above is of the form <code>&lt;name&gt; &lt;arg1&gt; &lt;arg2&gt;</code>
in which, as we defined earlier, <code>&lt;arg1&gt;</code> and <code>&lt;arg2&gt;</code> are arguments to <code>&lt;name&gt;</code>.</p>
<p>Using parenthesis, we can group the expressions together in the correct order.</p>
<blockquote>
<h4 id="an-aside-about-operator-precedence-and-fixity"><a class="header" href="#an-aside-about-operator-precedence-and-fixity">An aside about operator precedence and fixity</a></h4>
<p>operators (like <code>&lt;&gt;</code>) are infix functions that take two arguments - one from each side.</p>
<p>When there are multiple operators in the same expression without parenthesis, the operator
<em>fixity</em> (left or right) and <em>precedence</em> (a number between 0 and 10) determine which
operator binds more tightly.</p>
<p>In our case, <code>&lt;&gt;</code> has <em>right</em> fixity, so Haskell adds an invisible parenthesis on the right side
of <code>&lt;&gt;</code>. So, for example:</p>
<pre><code class="language-hs">&quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<p>is viewed by Haskell as:</p>
<pre><code class="language-hs">&quot;&lt;html&gt;&lt;body&gt;&quot; &lt;&gt; (content &lt;&gt; &quot;&lt;/body&gt;&lt;/html&gt;&quot;)
</code></pre>
<p>For an example of precedence, in the expression <code>1 + 2 * 3</code>,
the operator <code>+</code> has precedence 6, and the operator <code>*</code> has precedence 7,
so we give precedence to <code>*</code> over <code>+</code>. Haskell will view this expression as:</p>
<pre><code class="language-hs">1 + (2 * 3)
</code></pre>
<p>You might run into errors when mixing different operators with the <em>same precedence</em>
but <em>different fixity</em>, because Haskell won't understand how to group these expressions.
In that case, we can solve the problem by adding parenthesis explicitly.</p>
</blockquote>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Separate the functionality of <code>wrapHtml</code> into two functions:</p>
<ol>
<li>One that wraps content in <code>html</code> tag</li>
<li>one that wraps content in a <code>body</code> tag</li>
</ol>
<p>Name the new functions <code>html_</code> and <code>body_</code>.</p>
</li>
<li>
<p>Change <code>myhtml</code> to use these two functions.</p>
</li>
<li>
<p>Add another two similar functions for the tags <code>&lt;head&gt;</code> and <code>&lt;title&gt;</code>
and name them <code>head_</code> and <code>title_</code>.</p>
</li>
<li>
<p>Create a new function, <code>makeHtml</code>, which takes two strings as input:</p>
<ol>
<li>One string for the title</li>
<li>One string for the body content</li>
</ol>
<p>And construct an HTML string using the functions implemented in the previous exercises.</p>
<p>The output for:</p>
<pre><code class="language-hs">makeHtml &quot;My page title&quot; &quot;My page content&quot;
</code></pre>
<p>should be:</p>
<pre><code class="language-html">&lt;html&gt;&lt;head&gt;&lt;title&gt;My page title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My page content&lt;/body&gt;&lt;/html&gt;
</code></pre>
</li>
<li>
<p>Use <code>makeHtml</code> in <code>myhtml</code> instead of using <code>html_</code> and <code>body_</code> directly</p>
</li>
</ol>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">myhtml = html_ (body_ &quot;Hello, world!&quot;)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)
</code></pre>
</details>
<details>
  <summary>Solution for exercise #5</summary>
<pre><code class="language-hs">myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;
</code></pre>
</details>
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main = putStrLn myhtml

myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;
   
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
<p>We can now run our <code>hello.hs</code> program, pipeline the output into a file,
and open it in our browser:</p>
<pre><code class="language-sh">runghc hello.hs &gt; hello.html
firefox hello.html
</code></pre>
<p>It should display <code>Hello, world!</code> on the page and <code>Hello title</code> on the page's title.</p>
</details>
<hr />
<h2 id="indentation"><a class="header" href="#indentation">Indentation</a></h2>
<p>You might ask how does Haskell know a definition is complete?
The answer is: Haskell uses indentation to know when things should be grouped together.</p>
<p>Indentation in Haskell can be a bit tricky, but in general: code that is supposed to be
part of some expression should be indented further than the beginning of that expression.</p>
<p>We know the two definitions are separate because the second one is not indented further than the first one.</p>
<h3 id="indentation-tips"><a class="header" href="#indentation-tips">Indentation tips</a></h3>
<ol>
<li>Choose a specific amount of spaces for indentation (2 spaces, 4 spaces, etc.) and stick to it.
Always use spaces over tabs.</li>
<li>Do not indent more than once at any given time.</li>
<li>When in doubt, drop the line as needed and indent once.</li>
</ol>
<p>Here are a few examples:</p>
<pre><code class="language-hs">main =
    putStrLn &quot;Hello, world!&quot;
</code></pre>
<p>or:</p>
<pre><code class="language-hs">main =
    putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<p><strong>Avoid the following styles</strong>, which use more than one indentation step, or completely disregard
indentation steps:</p>
<pre><code class="language-hs">main = putStrLn
        (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<pre><code class="language-hs">main = putStrLn
                (wrapHtml &quot;Hello, world!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-type-signatures"><a class="header" href="#adding-type-signatures">Adding type signatures</a></h1>
<p>Haskell is a <strong>statically typed</strong> programming language. That means that every
expression has a type, and we check that the types are valid with
regard to each other before running the program. If we discover that
they are not valid, an error message will be printed, and the program
will not run.</p>
<p>An example of a type error would be if we'd pass 3 arguments to a function
that takes only 2, or pass a number instead of a string.</p>
<p>Haskell is also <strong>type inferred</strong>, so we don't <em>need</em> to specify the type
of expressions - Haskell can <em>infer</em> from the context of the expression
what its type should be, and that's what we have done until now. However, <strong>specifying
types is useful</strong> - it adds a layer of documentation for you or others
that will look at the code later, and it helps verify to some degree
that what was intended (with the type signature) is what was
written (with the expression). It is generally recommended to annotate all <em>top-level</em>
definitions with type signatures.</p>
<p>We use a double-colon (<code>::</code>) to specify the type of names. We usually
write it right above the definition of the name itself.</p>
<p>Here are a few examples of types we can write:</p>
<ul>
<li><code>Int</code> - The type of integer numbers</li>
<li><code>String</code> - The type of strings</li>
<li><code>Bool</code> - The type of booleans</li>
<li><code>()</code> - The type of the expression <code>()</code>, also called unit</li>
<li><code>a -&gt; b</code> - The type of a function from an expression of type <code>a</code> to an expression of type <code>b</code></li>
<li><code>IO ()</code> - The type of an expression that represents an IO subroutine that returns <code>()</code></li>
</ul>
<p>Let's specify the type of <code>title_</code>:</p>
<pre><code class="language-hs">title_ :: String -&gt; String
</code></pre>
<p>We can see in the code that the type of <code>title_</code> is a function that takes
a <code>String</code> and returns a <code>String</code>.</p>
<p>Let's also specify the type of <code>makeHtml</code>:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Previously, we thought about <code>makeHtml</code> as a function that takes
two strings and returns a string.</p>
<p>But actually, all functions in Haskell take <strong>exactly one argument</strong> as input
and return <strong>exactly one value</strong> as output. It's just convenient to refer
to functions like <code>makeHtml</code> as functions with multiple inputs.</p>
<p>In our case, <code>makeHtml</code> is a function that takes <strong>one</strong> string argument
and returns a <strong>function</strong>. <em>The function it returns</em> takes a string argument
as well and finally returns a string.</p>
<p>The magic here is that <code>-&gt;</code> is right-associative. This means that when we write:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; String -&gt; String
</code></pre>
<p>Haskell parses it as:</p>
<pre><code class="language-hs">makeHtml :: String -&gt; (String -&gt; String)
</code></pre>
<p>Consequently, the expression <code>makeHtml &quot;My title&quot;</code> is also a function!
One that takes a string (the content, the second argument of <code>makeHtml</code>)
and returns the expected HTML string with &quot;My title&quot; in the title.</p>
<p>This is called <strong>partial application</strong>.</p>
<p>To illustrate, let's define <code>html_</code> and <code>body_</code> in a different way by
defining a new function, <code>el</code>.</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>el is a function that takes a tag and content, and wraps the content
with the tag.</p>
<p>We can now implement <code>html_</code> and <code>body_</code> by partially applying <code>el</code> and
only provide the tag.</p>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;
</code></pre>
<p>Note that we didn't need to add the argument on the left side of
equals sign because Haskell functions are &quot;<strong>first class</strong>&quot; - they behave
exactly like values of primitive types like <code>Int</code> or <code>String</code>.
We can name a function like any other value,
put it in data structures, pass it to functions, and so on!</p>
<p>The way Haskell treats names is very similar to copy-paste. Anywhere
you see <code>html_</code> in the code, you can replace it with <code>el &quot;html&quot;</code>. They are
the same (this is what the equals signs say, right? That the two sides
are the same). This property of being able to <em>substitute</em> the two sides of the
equals sign with one another is called <strong>referential transparency</strong>. And
it is pretty unique to Haskell (and a few similar languages such as PureScript and Elm)!
We'll talk more about referential transparency in a later chapter.</p>
<h3 id="anonymouslambda-functions"><a class="header" href="#anonymouslambda-functions">Anonymous/lambda functions</a></h3>
<p>To further drive the point that Haskell functions are first class and
all functions take exactly one argument,
I'll mention that the syntax we've been using up until
now to define function is just syntactic sugar! We can also define
<strong>anonymous functions</strong> - functions without a name, anywhere we'd like.
Anonymous functions are also known as <strong>lambda functions</strong>
as a tribute to the formal mathematical system
which is at the heart of all functional programming
languages - the lambda calculus.</p>
<p>We can create an anonymous function anywhere we'd expect an expression,
such as <code>&quot;hello&quot;</code>, using the following syntax:</p>
<pre><code class="language-hs">\&lt;argument&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>This little <code>\</code> (which bears some resemblance to the lowercase Greek letter lambda 'λ')
marks the head of the lambda function,
and the arrow (<code>-&gt;</code>) marks the beginning of the function's body.
We can even chain lambda functions, making them &quot;multiple argument functions&quot; by
defining another lambda in the body of another, like this:</p>
<pre><code class="language-hs">three = (\num1 -&gt; \num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>As before, we evaluate functions by substituting the function argument with
the applied value. In the example above, we substitute <code>num1</code> with <code>1</code> and get
<code>(\num2 -&gt; 1 + num2) 2</code>. Then substitute <code>num2</code> with <code>2</code> and get <code>1 + 2</code>.
We'll talk more about substitution later.</p>
<p>So, when we write:</p>
<pre><code class="language-hs">el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Haskell actually translates this under the hood to:</p>
<pre><code class="language-hs">el :: String -&gt; (String -&gt; String)
el = \tag -&gt; \content -&gt;
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
<p>Hopefully, this form makes it a bit clearer why Haskell functions
always take one argument, even when we have syntactic sugar that
might suggest otherwise.</p>
<p>I'll mention one more syntactic sugar for anonymous functions:
We don't actually have to write multiple argument anonymous functions
this way, we can write:</p>
<pre><code class="language-hs">\&lt;arg1&gt; &lt;arg2&gt; ... &lt;argN&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>to save us some trouble. For example:</p>
<pre><code class="language-hs">three = (\num1 num2 -&gt; num1 + num2) 1 2
</code></pre>
<p>But it's worth remembering what they are under the hood.</p>
<p>We won't be needing anonymous/lambda functions at this point,
but we'll discuss them later and see where they can be useful.</p>
<hr />
<p>Exercises:</p>
<ol>
<li>
<p>Add types for all of the functions we created until now</p>
</li>
<li>
<p>Change the implementation of the HTML functions we built to use <code>el</code> instead</p>
</li>
<li>
<p>Add a couple more functions for defining paragraphs and headings:</p>
<ol>
<li><code>p_</code> which uses the tag <code>&lt;p&gt;</code> for paragraphs</li>
<li><code>h1_</code> which uses the tag <code>&lt;h1&gt;</code> for headings</li>
</ol>
</li>
<li>
<p>Replace our <code>Hello, world!</code> string with richer content, use <code>h1_</code> and <code>p_</code>.
We can append HTML strings created by <code>h1_</code> and <code>p_</code> using the append operator <code>&lt;&gt;</code>.</p>
</li>
</ol>
<p>Bonus: rewrite a couple of functions using lambda functions, just for fun!</p>
<hr />
<p>Solutions:</p>
<details>
  <summary>Solution for exercise #1</summary>
<pre><code class="language-hs">myhtml :: String
myhtml = makeHtml &quot;Hello title&quot; &quot;Hello, world!&quot;

makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ content = &quot;&lt;html&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/html&gt;&quot;

body_ :: String -&gt; String
body_ content = &quot;&lt;body&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/body&gt;&quot;

head_ :: String -&gt; String
head_ content = &quot;&lt;head&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/head&gt;&quot;

title_ :: String -&gt; String
title_ content = &quot;&lt;title&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/title&gt;&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #2</summary>
<pre><code class="language-hs">html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #3</summary>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;
</code></pre>
</details>
<details>
  <summary>Solution for exercise #4</summary>
<pre><code class="language-hs">myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)
</code></pre>
</details>
<hr />
<details>
  <summary>Our final program</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn myhtml

myhtml :: String
myhtml =
  makeHtml
    &quot;Hello title&quot;
    (h1_ &quot;Hello, world!&quot; &lt;&gt; p_ &quot;Let's learn about Haskell!&quot;)


makeHtml :: String -&gt; String -&gt; String
makeHtml title content = html_ (head_ (title_ title) &lt;&gt; body_ content)

html_ :: String -&gt; String
html_ = el &quot;html&quot;

body_ :: String -&gt; String
body_ = el &quot;body&quot;

head_ :: String -&gt; String
head_ = el &quot;head&quot;

title_ :: String -&gt; String
title_ = el &quot;title&quot;

p_ :: String -&gt; String
p_ = el &quot;p&quot;

h1_ :: String -&gt; String
h1_ = el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-domain-specific-languages"><a class="header" href="#embedded-domain-specific-languages">Embedded Domain-Specific Languages</a></h1>
<p>Right off the bat, we run into a common pattern in Haskell: creating
Embedded Domain-Specific Languages (EDSLs for short).</p>
<p>Domain-specific languages (DSLs) are specialized programming languages that are
tailored to specific domains, in contrast to general-purpose languages,
which try to work well in many domains.</p>
<p>A few examples of DSLs are:</p>
<ul>
<li>make - for defining build systems</li>
<li>DOT - for defining graphs</li>
<li>Sed - for defining text transformations</li>
<li>CSS - for defining styling</li>
<li>HTML - for defining web pages</li>
</ul>
<p>An <em>embedded</em> domain-specific language is a little language that is
embedded inside another programming language, making a program written in
the EDSL a valid program in the language it was written in.</p>
<p>The little HTML library we've been writing can be considered an EDSL.
It is used specifically for building web pages (by returning HTML strings),
and is valid Haskell code!</p>
<p>In Haskell, we frequently create and use EDSLs to express domain-specific
logic. We have EDSLs for concurrency, command-line options parsing, JSON and HTML,
creating build systems, writing tests, and many more.</p>
<p>Specialized languages are useful because they can solve specific problems in
a concise (and often safe) way, and by embedding, we get to use the full power of
the host language for our domain logic, including syntax highlighting and
various tools available for the language.</p>
<p>The drawback of embedding domain-specific languages is that we have to adhere to
the rules of the programming language we embed in, such as syntactic and semantic rules.</p>
<p>Some languages alleviate this drawback by providing meta-programming capabilities
in the form of macros or other features to extend the language.
And while Haskell does provide such capabilities as well, it is also expressive and concise
enough that many EDSLs do not need them.</p>
<p>Instead, many Haskell EDSLs use a pattern called <em>the combinator pattern</em>:
They define <em>primitives</em> and <em>combinators</em> -
primitives are basic building blocks of the language,
and combinators are functions that combine primitives into more complex structures.</p>
<p>In our HTML EDSL, our primitives are functions such as <code>html_</code> and <code>title_</code>
that can be used to create a single HTML node, and we pass other
constructed nodes as input to these functions, and combine them into a more complex
structure with the append function <code>&lt;&gt;</code>.</p>
<p>There are still a few tricks we can use to make our HTML EDSL better:</p>
<ol>
<li>
<p>We can use Haskell's type system to make sure we only construct <em>valid</em>
HTML, so for example, we don't create a <code>&lt;title&gt;</code> node
without a <code>&lt;head&gt;</code> node or have user content that 
can include unescaped special characters,
and throw a type error when the user tries to do something invalid.</p>
</li>
<li>
<p>Our HTML EDSL can move to its own module so it can be reused in multiple modules</p>
</li>
</ol>
<p>In the next few sections, we'll take a look at how to define our own types and
how to work with modules to make it harder to make errors, and a little bit
about linked lists in Haskell.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safer-html-construction-with-types"><a class="header" href="#safer-html-construction-with-types">Safer HTML construction with types</a></h1>
<p>In this section, we'll learn how to create our own distinguished types
for HTML, and how they can help us avoid the invalid construction of HTML strings.</p>
<p>There are a few ways of defining new types in Haskell; in this section,
we are going to meet two ways: <code>newtype</code> and <code>type</code>.</p>
<h2 id="newtype"><a class="header" href="#newtype"><code>newtype</code></a></h2>
<p>A <code>newtype</code> declaration is a way to define a new, distinct type for an existing set of values.
This is useful when we want to reuse existing values but give them a different meaning
and ensure we can't mix the two.
For example, we can represent seconds, minutes, grams, and yens using integer values,
but we don't want to mix grams and seconds accidentally.</p>
<p>In our case, we want to represent structured HTML using textual values,
but distinguish them from everyday strings that are not valid HTML.</p>
<p>A <code>newtype</code> declaration looks like this:</p>
<pre><code>newtype &lt;type-name&gt; = &lt;constructor&gt; &lt;existing-type&gt;
</code></pre>
<p>For example, in our case, we can define a distinct type for <code>Html</code> like this:</p>
<pre><code class="language-hs">newtype Html = Html String
</code></pre>
<p>The first <code>Html</code>, to the left of the equals sign, lives in the <em>types</em>
name space, meaning that you will only see that name to the right of a
double-colon sign (<code>::</code>).</p>
<p>The second <code>Html</code> lives in the <em>expressions</em> (or terms/values) namespace,
meaning that you will see it where you expect expressions (we'll touch where
exactly that can be in a moment).</p>
<p>The two names, <code>&lt;type-name&gt;</code> and <code>&lt;constructor&gt;</code>, do not have to be the
same, but they often are. And note that both have to start with a
capital letter.</p>
<p>The right-hand side of the newtype declaration describes the shape of a
value of that type. In our case, we expect a value of
type <code>Html</code> to have the constructor <code>Html</code> and then an expression of
type string, for example: <code>Html &quot;hello&quot;</code> or <code>Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)</code>.</p>
<p>You can think of the constructor as a function that takes the argument
and returns something of our new type:</p>
<pre><code class="language-hs">Html :: String -&gt; Html
</code></pre>
<p><strong>Note</strong>: We cannot use an expression of type <code>Html</code> the same way we'd
use a <code>String</code>. So <code>&quot;hello &quot; &lt;&gt; Html &quot;world&quot;</code> would fail at type
checking.</p>
<p>This is useful when we want <em>encapsulation</em>. We can define and use
existing representation and functions for our underlying type, but not
mix them with other unrelated (to our domain) types. Similar as
meters and feet can both be numbers, but we don't want to accidentally
add feet to meters without any conversion.</p>
<hr />
<p>For now, let's create a couple of types for our use case.
We want two separate types to represent:</p>
<ol>
<li>A complete Html document</li>
<li>A type for html structures such as headings and paragraphs that can go inside the <body> tag</li>
</ol>
<p>We want them to be distinct because we don't want to mix them.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">newtype Html = Html String

newtype Structure = Structure String
</code></pre>
</details>
<hr />
<h2 id="using-newtypes"><a class="header" href="#using-newtypes">Using <code>newtype</code>s</a></h2>
<p>To use the underlying type that the newtype wraps, we first
need to extract it out of the type. We do this using pattern matching.</p>
<p>Pattern matching can be used in two ways, in case-expressions and in
function definitions.</p>
<ol>
<li>
<p>case expressions are kind of beefed up switch expressions and look like this:</p>
<pre><code>case &lt;expression&gt; of
  &lt;pattern&gt; -&gt; &lt;expression&gt;
  ...
  &lt;pattern&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>The <code>&lt;expression&gt;</code> is the thing we want to unpack, and the <code>pattern</code>
is its concrete shape. For example, if we wanted to extract the <code>String</code>
out of the type <code>Structure</code> we defined in the exercise above, we do:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString struct =
  case struct of
    Structure str -&gt; str
</code></pre>
<p>This way, we can extract the <code>String</code> out of <code>Structure</code> and return
it.</p>
<blockquote>
<p>In later chapters we'll introduce <code>data</code> declarations (which are kind of
a struct + enum chimera), where we can define multiple constructors to
a type. Then the multiple patterns of a case expression will make more
sense.</p>
</blockquote>
</li>
<li>
<p>Alternatively, when declaring a function, we can also use pattern matching on the
arguments:</p>
<pre><code>func &lt;pattern&gt; = &lt;expression&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString (Structure str) = str
</code></pre>
<p>Using the types we created, we can change the HTML functions we've defined before,
namely <code>html_</code>, <code>body_</code>, <code>p_</code>, etc., to operate on these types instead of <code>String</code>s.</p>
<p>But first, let's meet another operator that will make our code more concise.</p>
</li>
</ol>
<p>One very cool thing about <code>newtype</code> is that wrapping and extracting expressions doesn't actually
have a performance cost! The compiler knows how to remove any wrapping and extraction
of the <code>newtype</code> constructor and use the underlying type.</p>
<p>The new type and the constructor we defined are only there to help us <em>distinguish</em> between
the type we created and the underlying type when <em>we write our code</em>, they are not
needed <em>when the code is running</em>.</p>
<p><code>newtype</code>s provide us with type safety with no performance penalty!</p>
<h2 id="chaining-functions"><a class="header" href="#chaining-functions">Chaining functions</a></h2>
<p>Another interesting and extremely common operator
(which is a regular library function in Haskell) is <code>.</code> (pronounced compose).
This operator was made to look like the composition operator
you may know from math (<code>∘</code>).</p>
<p>Let's look at its type and implementation:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) f g x = f (g x)
</code></pre>
<p>Compose takes 3 arguments: two functions (named <code>f</code> and <code>g</code> here) and
a third argument named <code>x</code>. It then passes the argument <code>x</code> to the second
function <code>g</code> and calls the first function <code>f</code> with the result of <code>g x</code>.</p>
<p>Note that <code>g</code> takes as input something of the type
<code>a</code> and returns something of the type <code>b</code>, and <code>f</code> takes
something of the type <code>b</code> and returns something of the type <code>c</code>.</p>
<p>Another important thing to note is that types that start with
a <em>lowercase letter</em> are <strong>type variables</strong>.
Think of them as similar to regular variables. Just like
<code>content</code> could be any string, like <code>&quot;hello&quot;</code> or <code>&quot;world&quot;</code>, a type variable
can be any type: <code>Bool</code>, <code>String</code>, <code>String -&gt; String</code>, etc.
This ability is called <em>parametric polymorphism</em> (other languages often call this generics).</p>
<p>The catch is that type variables must match in a signature, so if for
example, we write a function with the type signature <code>a -&gt; a</code>, the
input type and the return type <strong>must</strong> match, but it could be
any type - we cannot know what it is. So the only way to implement a
function with that signature is:</p>
<pre><code class="language-hs">id :: a -&gt; a
id x = x
</code></pre>
<p><code>id</code>, short for the identity function, returns the exact value it received.
If we tried any other way, for example, returning some made-up value
like <code>&quot;hello&quot;</code>, or trying to use <code>x</code> as a value of a type we know, like
writing <code>x + x</code>, the type checker will complain.</p>
<p>Also, remember that <code>-&gt;</code> is right-associative? This signature is equivalent to:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Doesn't it look like a function that takes two functions and returns a
third function that is the composition of the two?</p>
<p>We can now use this operator to change our HTML functions. Let's start
with one example: <code>p_</code>.</p>
<p>Before, we had:</p>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;
</code></pre>
<p>And now, we can write:</p>
<pre><code class="language-hs">p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;
</code></pre>
<p>The function <code>p_</code> will take an arbitrary <code>String</code>, which is the content
of the paragraph we wish to create, wrap it in <code>&lt;p&gt;</code> and <code>&lt;/p&gt;</code> tags,
and then wrap it in the <code>Structure</code> constructor to produce the
output type <code>Structure</code> (remember: newtype constructors can be used as functions!).</p>
<p>Let's take a deeper look at the types:</p>
<ul>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
<li><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></li>
<li><code>Structure . el &quot;p&quot; :: String -&gt; Structure</code></li>
</ul>
<p>Let's see why the expression <code>Structure . el &quot;p&quot;</code> type checks,
and why its type is <code>String -&gt; Structure</code>.</p>
<h3 id="type-checking-with-pen-and-paper"><a class="header" href="#type-checking-with-pen-and-paper">Type checking with pen and paper</a></h3>
<p>If we want to figure out if and how exactly an expression type-checks,
we can do that rather systematically. Let's look at an example
where we try and type-check this expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>First, we write down the type of the outer-most function. In
our case, this is the operator <code>.</code> which has the type:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>After that, we can try to <strong>match</strong> the type of the arguments we
apply to this function with the type of the arguments from the type signature.</p>
<p>In this case, we try to apply two arguments to <code>.</code>:</p>
<ol>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
</ol>
<p>And luckily, <code>.</code> expects two arguments with the types:</p>
<ol>
<li><code>b -&gt; c</code></li>
<li><code>a -&gt; b</code></li>
</ol>
<blockquote>
<p>Note: Applying a function with more arguments than it expects is a type error.</p>
</blockquote>
<p>Since the <code>.</code> operator takes at least the number of arguments we supply, we continue
to the next phase of type-checking: matching the types of the inputs with the types
of the expected inputs (from the type signature of the operator).</p>
<p>When we match two types, we check for <em>equivalence</em> between them. There are a few
possible scenarios here:</p>
<ol>
<li>When the two types are <strong>concrete</strong> (as opposed to type variables)
and <strong>simple</strong>, like <code>Int</code> and <code>Bool</code>,
we check if they are the same. If they are, they type check, and we continue.
If they aren't, they don't type check, and we throw an error.</li>
<li>When the two types we match are more <strong>complex</strong> (for example, both are functions),
we try to match their inputs and outputs (in the case of functions). If the inputs and outputs
match, then the two types match.</li>
<li>There is a special case when one of the types is a <strong>type variable</strong> -
in this case, we treat the matching process like an equation and write it down somewhere.
The next time we see this type variable, we <em>replace it with its match in the equation</em>.
Think about this like <em>assigning</em> a type <em>variable</em> with a <em>value</em>.</li>
</ol>
<p>In our case, we want to match (or check the equivalence of) these types:</p>
<ol>
<li><code>String -&gt; Structure</code> with <code>b -&gt; c</code></li>
<li><code>String -&gt; String</code> with <code>a -&gt; b</code></li>
</ol>
<p>Let's do this one by one, starting with (1) - matching <code>String -&gt; Structure</code> and <code>b -&gt; c</code>:</p>
<ol>
<li>Because the two types are complex, we check that they are both functions, match their
inputs and outputs: <code>String</code> with <code>b</code>, and <code>Structure</code> with <code>c</code>.</li>
<li>Because <code>b</code> is a <em>type variable</em>, we mark down somewhere that <code>b</code> should
be equivalent to <code>String</code>.
We write <code>b ~ String</code> (we use <code>~</code> to denote equivalence).</li>
<li>We match <code>Structure</code> and <code>c</code>, same as before, we write down that <code>c ~ Structure</code>.</li>
</ol>
<p>No problem so far; let's try matching <code>String -&gt; String</code> with <code>a -&gt; b</code>:</p>
<ol>
<li>The two types are complex; we see that both are functions, so we match
their inputs and outputs.</li>
<li>Matching <code>String</code> with <code>a</code> - we write down that <code>a ~ String</code>.</li>
<li>Matching <code>String</code> with <code>b</code> - we remember that we have already written
about <code>b</code> - looking back, we see that we already noted that <code>b ~ String</code>.
We need to replace <code>b</code> with the type that we wrote down before and
check it against this type, so we match <code>String</code> with <code>String</code> 
which, fortunately, type-check because they are the same.</li>
</ol>
<p>So far, so good. We've type-checked the expression and discovered the following equivalences 
about the type variables in it:</p>
<ol>
<li><code>a ~ String</code></li>
<li><code>b ~ String</code></li>
<li><code>c ~ Structure</code></li>
</ol>
<p>Now, when asking what is the type of the expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>We say that it is the type of <code>.</code> after <em>replacing</em> the type variables using the equations, we found
and <em>removing</em> the inputs we applied to it, so we started with:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Then we replaced the type variables:</p>
<pre><code class="language-hs">(.) :: (String -&gt; Structure) -&gt; (String -&gt; String) -&gt; (String -&gt; Structure)
</code></pre>
<p>And removed the two arguments when we applied the function:</p>
<pre><code class="language-hs">Structure . el &quot;p&quot; :: String -&gt; Structure
</code></pre>
<p>And we got the type of expression!</p>
<p>Fortunately, Haskell can do this process for us. But when Haskell complains
that our types fail to type-check, and we don't understand exactly why, going through this process
can help us understand where the types do not match, and then we can figure out how to solve it.</p>
<blockquote>
<p><strong>Note</strong>: If we use a <em>parametrically polymorphic</em> function more than once,
or use different functions that have similar type variable names,
the type variables don't have to match in all instances simply because they share a name.
Each instance has its own unique set of type variables. For example:</p>
<pre><code class="language-hs">id :: a -&gt; a
ord :: Char -&gt; Int
chr :: Int -&gt; Char

incrementChar :: Char -&gt; Char
incrementChar c = chr (ord (id c) + id 1)
</code></pre>
<p>In the snippet above, we use <code>id</code> twice (for no good reason other than for demonstration purposes).
The first <code>id</code> takes a <code>Char</code> as argument, and its <code>a</code> is equivalent to <code>Char</code>.
The second <code>id</code> takes an <code>Int</code> as argument, and its <em>distinct</em> <code>a</code> is equivalent to <code>Int</code>.</p>
<p>This, unfortunately, only applies to functions defined at the top-level. If we'd define a local function
to be passed as an argument to <code>incrementChar</code> with the same type signature as <code>id</code>,
the types must match in all uses. So this code:</p>
<pre><code class="language-hs">incrementChar :: (a -&gt; a) -&gt; Char -&gt; Char
incrementChar func c = chr (ord (func c) + func 1)
</code></pre>
<p>Will not type check. Try it!</p>
</blockquote>
<h2 id="appending-structure"><a class="header" href="#appending-structure">Appending Structure</a></h2>
<p>Before, when we wanted to create richer HTML content and appended
nodes to one another, we used the append (<code>&lt;&gt;</code>) operator.
Since we are now not using <code>String</code> anymore, we need another way
to do it.</p>
<p>While it is possible to overload <code>&lt;&gt;</code> using a feature in
Haskell called type classes, we will instead create a new function
and call it <code>append_</code>, and cover type classes later.</p>
<p><code>append_</code> should take two <code>Structure</code>s, and return a third <code>Structure</code>,
appending the inner <code>String</code> in the first <code>Structure</code> to the second and wrapping the result back in <code>Structure</code>.</p>
<hr />
<p>Try implementing <code>append_</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ (Structure a) (Structure b) =
  Structure (a &lt;&gt; b)
</code></pre>
</details>
<hr />
<h2 id="converting-back-html-to-string"><a class="header" href="#converting-back-html-to-string">Converting back <code>Html</code> to <code>String</code></a></h2>
<p>After constructing a valid <code>Html</code> value, we want to be able to
print it to the output so we can display it in our browser.
For that, we need a function that takes an <code>Html</code> and converts it to a <code>String</code>, which we can then pass to <code>putStrLn</code>.</p>
<hr />
<p>Implement the <code>render</code> function.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p>Let's look at one more way to give new names to types.</p>
<p>A <code>type</code> definition looks really similar to a <code>newtype</code> definition - the only
difference is that we reference the type name directly without a constructor:</p>
<pre><code>type &lt;type-name&gt; = &lt;existing-type&gt;
</code></pre>
<p>For example, in our case, we can write:</p>
<pre><code class="language-hs">type Title = String
</code></pre>
<p><code>type</code>, in contrast with <code>newtype</code>, is just a type name alias.
When we declare <code>Title</code> as a <em>type alias</em> of <code>String</code>,
we mean that <code>Title</code> and <code>String</code> are interchangeable,
and we can use one or the other whenever we want:</p>
<pre><code class="language-hs">&quot;hello&quot; :: Title

&quot;hello&quot; :: String
</code></pre>
<p>Both are valid in this case.</p>
<p>We can sometimes use <code>type</code>s to give a bit more clarity to our code,
but they are much less useful than <code>newtype</code>s which allow us to
<em>distinguish</em> two types with the same type representation.</p>
<h2 id="the-rest-of-the-owl"><a class="header" href="#the-rest-of-the-owl">The rest of the owl</a></h2>
<hr />
<p>Try changing the code we wrote in previous chapters to use the new types we created.</p>
<blockquote>
<p><strong>Tips</strong></p>
<p>We can combine <code>makeHtml</code> and <code>html_</code>, and remove <code>body_</code> <code>head_</code> and <code>title_</code>
by calling <code>el</code> directly in <code>html_</code>, which can now have the type
<code>Title -&gt; Structure -&gt; Html</code>.
This will make our HTML EDSL less flexible but more compact.</p>
<p>Alternatively, we could create <code>newtype</code>s for <code>HtmlHead</code> and <code>HtmlBody</code> and
pass those to <code>html_</code>, and we might do that in later chapters, but I've chosen
to keep the API a bit simple for now, we can always refactor later!</p>
</blockquote>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="are-we-safe-yet"><a class="header" href="#are-we-safe-yet">Are we safe yet?</a></h2>
<p>We have made some progress - now we can't write <code>&quot;Hello&quot;</code>
where we'd expect either a paragraph or a heading, but we can still
write <code>Structure &quot;hello&quot;</code> and get something that isn't a
paragraph or a heading. So while we made it harder for the user
to make mistakes by accident, we haven't really been able to <strong>enforce
the invariants</strong> we wanted to enforce in our library.</p>
<p>Next, we'll see how we can make expressions such as <code>Structure &quot;hello&quot;</code> illegal
as well using <em>modules</em> and <em>smart constructors</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preventing-incorrect-use-with-modules"><a class="header" href="#preventing-incorrect-use-with-modules">Preventing incorrect use with modules</a></h1>
<p>In this section, we will move the HTML generation library to its own module.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Each Haskell source file is a module. The module name should have the
same name as the source file and start with a capital
letter. Sub-directories should also be part of the name, and we use <code>.</code>
to denote a sub-directory. We'll see that in the next section.</p>
<p>The only exception to the rule are entry points to the program -
modules with the name 'Main' that define <code>main</code> in them. Their source
file names could have any name they want.</p>
<p>A module declaration looks like this:</p>
<pre><code class="language-hs">module &lt;module-name&gt;
  ( &lt;export-list&gt;
  )
  where
</code></pre>
<p>The export list can be omitted if you want to export everything
defined in the module, but we don't. We will list exactly the
functions and types we want to export. This will give us control
over how people can use our tiny library.</p>
<p>We will create a new source file named <code>Html.hs</code> and add the following
module declaration code at the top of the file:</p>
<pre><code class="language-hs">module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where
</code></pre>
<p>Note that we do not export:</p>
<ol>
<li>
<p>The constructors for our new types, only the types themselves.
If we wanted to export the constructors as well, we would've written
<code>Html(Html)</code> or <code>Html(..)</code>. This way the user cannot create their own
<code>Structure</code> by writing <code>Structure &quot;Hello&quot;</code>.</p>
</li>
<li>
<p>Internal functions used by the library, such as <code>el</code> and <code>getStructureString</code>.</p>
</li>
</ol>
<p>And we will also move the HTML related functions from our <code>hello.hs</code> file
to this new <code>Html.hs</code> file:</p>
<pre><code class="language-hs">newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<p>Now, anyone importing our module (using the <code>import</code> statement
below module declarations but above any other
declaration), will only be able to import what we export.</p>
<p>Add the following code at the top of the <code>hello.hs</code> file:</p>
<pre><code class="language-hs">import Html
</code></pre>
<p>The <code>hello.hs</code> file should now look like this:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<p>And the <code>Html.hs</code> file should look like this:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
<blockquote>
<p>As an aside, you might have noticed that I've decided to suffix the functions used to
construct HTML values with an underscore (<code>_</code>). This is mostly an aesthetic decision which,
in my opinion, makes the EDSL easier to recognize,
but it is also useful to avoid name clashes with
functions defined in the Haskell standard library, such as <code>head</code>.
I took this idea from a Haskell HTML library named <code>lucid</code>!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escaping-characters"><a class="header" href="#escaping-characters">Escaping characters</a></h1>
<p>Now that <code>Html</code> has its own source file and module, and creating
HTML code can be done only via the functions we exported,
we can also handle user input that may contain characters
that may conflict with our meta language, HTML,
such as <code>&lt;</code> and <code>&gt;</code>, which are used for creating HTML tags.</p>
<p>We can convert these characters into different strings that HTML can handle.</p>
<p>See <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html">Stack overflow question</a>
for a list of characters, we need to escape.</p>
<p>Let's create a new function called <code>escape</code>:</p>
<pre><code class="language-hs">escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<p>In <code>escape</code> we see a few new things:</p>
<ol>
<li>
<p>Let expressions: we can define local names using this syntax:</p>
<pre><code class="language-hs">let
  &lt;name&gt; = &lt;expression&gt;
in
  &lt;expression&gt;
</code></pre>
<p>This will make <code>&lt;name&gt;</code> available as a variable <code>in</code> the second <code>&lt;expression&gt;</code>.</p>
</li>
<li>
<p>Pattern matching with multiple patterns: we match on different
characters and convert them to a string. Note that <code>_</code> is a &quot;catch
all&quot; pattern that will always succeed.</p>
</li>
<li>
<p>Two new functions: <code>map</code> and <code>concat</code>; we'll talk about these in more in-depth</p>
</li>
<li>
<p>The syntax highlighting broke a bit for this snippet for some reason. Don't worry about it.</p>
</li>
</ol>
<h2 id="linked-lists-briefly"><a class="header" href="#linked-lists-briefly">Linked lists briefly</a></h2>
<p>Linked lists are very common data structures in Haskell, so common that
they have their own special syntax:</p>
<ol>
<li>The list types are denoted with brackets, and inside them is the type of the element. For example:
<ul>
<li><code>[Int]</code> - a list of integers</li>
<li><code>[Char]</code> - a list of characters</li>
<li><code>[String]</code> - a list of strings</li>
<li><code>[[String]]</code> - a list of a list of strings</li>
<li><code>[a]</code> - a list of any single type (all elements must be of the same type)</li>
</ul>
</li>
<li>An empty list is written like this: <code>[]</code></li>
<li>Prepending an element to a list is done with the operator <code>:</code> (pronounced cons), which is right-associative (like <code>-&gt;</code>).
For example: <code>1 : []</code>, or <code>1 : 2 : 3 : []</code>.</li>
<li>The above lists can also be written like <code>[1]</code> and <code>[1, 2, 3]</code>.</li>
</ol>
<p>Also, Strings are linked lists of characters - String is defined as:
<code>type String = [Char]</code>, so we can use them the same way we use lists.</p>
<blockquote>
<p>Do note, however, that linked lists, despite their convenience, are often
not the right tool for the job. They are not particularly space efficient
and are slow for appending, random access, and more. That also makes <code>String</code>
a lot less efficient than what it could be. And I generally recommend using a
different string type, <code>Text</code>, instead, which is available in an external package.
We will talk about lists, <code>Text</code>, and other data structures in the future!</p>
</blockquote>
<p>We can implement our own operations on lists by using pattern matching and recursion.
And we'll touch on this subject later when talking about ADTs.</p>
<p>For now, we will use the various functions found in the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html">Data.List</a> module.
Specifically, <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:map">map</a>
and <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List.html#v:concat">concat</a>.</p>
<h3 id="map"><a class="header" href="#map"><code>map</code></a></h3>
<p>Using <code>map</code>, we can apply a function to each element in a list. Its type signature is:</p>
<pre><code class="language-hs">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">map not [False, True, False] == [True, False, True]
</code></pre>
<p>Or as can be seen in our <code>escape</code> function, this can help us escape each character:</p>
<pre><code class="language-hs">map escapeChar ['&lt;','h','1','&gt;'] == [&quot;&amp;lt;&quot;,&quot;h&quot;,&quot;1&quot;,&quot;&amp;gt;&quot;]
</code></pre>
<p>However, note that the <code>escapeChar</code> has the type <code>Char -&gt; String</code>,
so the result type of <code>map escapeChar ['&lt;','h','1','&gt;']</code> is <code>[String]</code>,
and what we really want is a <code>String</code> and not <code>[String]</code>.</p>
<p>This is where <code>concat</code> enters the picture to help us flatten the list.</p>
<h3 id="concat"><a class="header" href="#concat"><code>concat</code></a></h3>
<p><code>concat</code> has the type:</p>
<pre><code class="language-hs">concat :: [[a]] -&gt; [a]
</code></pre>
<p>It flattens a list of list of something into a list of something.
In our case it will flatten <code>[String]</code> into <code>String</code>, remember that
<code>String</code> is a <strong>type alias</strong> for <code>[Char]</code>, so we actually have
<code>[[Char]] -&gt; [Char]</code>.</p>
<h2 id="ghci"><a class="header" href="#ghci">GHCi</a></h2>
<p>One way we can quickly see our code in action is by using the interactive development environment <strong>GHCi</strong>.
Running <code>ghci</code> will open an interactive prompt where Haskell expressions can be written and
evaluated. This is called a &quot;Read-Evaluate-Print Loop&quot; (for short - REPL).</p>
<p>For example:</p>
<pre><code>ghci&gt; 1 + 1
2
ghci&gt; putStrLn &quot;Hello, world!&quot;
Hello, world!
</code></pre>
<p>We can define new names:</p>
<pre><code>ghci&gt; double x = x + x
ghci&gt; double 2
4
</code></pre>
<p>We can write multi-line code by surrounding it with <code>:{</code> and <code>:}</code>:</p>
<pre><code>ghci&gt; :{
| escape :: String -&gt; String
| escape =
|   let
|     escapeChar c =
|       case c of
|         '&lt;' -&gt; &quot;&amp;lt;&quot;
|         '&gt;' -&gt; &quot;&amp;gt;&quot;
|         '&amp;' -&gt; &quot;&amp;amp;&quot;
|         '&quot;' -&gt; &quot;&amp;quot;&quot;
|         '\'' -&gt; &quot;&amp;#39;&quot;
|         _ -&gt; [c]
|   in
|     concat . map escapeChar
| :}

ghci&gt; escape &quot;&lt;html&gt;&quot;
&quot;&amp;lt;html&amp;gt;&quot;

</code></pre>
<p>We can import Haskell source files using the <code>:load</code> command (<code>:l</code> for short):</p>
<pre><code>ghci&gt; :load Html.hs
[1 of 1] Compiling Html    ( Html.hs, interpreted )
Ok, one module loaded.
ghci&gt; render (html_ &quot;&lt;title&gt;&quot; (p_ &quot;&lt;body&gt;&quot;))
&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;title&gt;&lt;/title&gt;&lt;body&gt;&lt;p&gt;&lt;body&lt;/p&gt;&lt;/body&gt;&lt;/head&gt;&lt;/html&gt;&quot;
</code></pre>
<p>As well as import library modules:</p>
<pre><code>ghci&gt; import Data.Bits
ghci&gt; shiftL 32 1
64
ghci&gt; clearBit 33 0
32
</code></pre>
<p>We can even ask the type of an expression using the <code>:type</code> command
(<code>:t</code> for short):</p>
<pre><code>λ&gt; :type escape
escape :: String -&gt; String
</code></pre>
<p>To exit <code>ghci</code>, use the <code>:quit</code> command (or <code>:q</code> for short)</p>
<pre><code>ghci&gt; :quit
Leaving GHCi.
</code></pre>
<p>GHCi is a very useful tool for quick experiments and exploration.
We've seen a couple of examples of that above - passing the string <code>&quot;&lt;html&gt;&quot;</code> to our
<code>escape</code> function returns the string <code>&quot;&amp;lt;html&amp;gt;&quot;</code>, which can be rendered by
a browser as <code>&lt;html&gt;</code> instead of an HTML tag.</p>
<p>If you are having a hard time figuring out what a particular function does, consider
testing it in GHCi - pass it different inputs and see if it matches your expectations.
Concrete examples of running code can aid a lot in understanding it!</p>
<blockquote>
<p>If you'd like to learn more about GHCi, you can find a more thorough introduction in the
<a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html">GHC user guide</a>.</p>
</blockquote>
<h2 id="escaping"><a class="header" href="#escaping">Escaping</a></h2>
<hr />
<p>The user of our library can currently only supply strings in a few places:</p>
<ol>
<li>Page title</li>
<li>Paragraphs</li>
<li>Headings</li>
</ol>
<p>We can apply our escape function at these places before doing anything else with it.
That way, all HTML constructions are safe.</p>
<p>Try adding the escaping function in those places.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape
</code></pre>
</details>
<hr />
<details>
  <summary><b>Our revised Html.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<p>Try constructing an invalid HTML in <code>hello.hs</code> to see if this works or not!</p>
<p>Now we can use our tiny HTML library safely. But what if the user
wants to use our library with a valid use case we didn't think about, for
example, adding unordered lists? We are completely blocking them from
extending our library. We'll talk about this next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exposing-internal-functionality-internal-modules"><a class="header" href="#exposing-internal-functionality-internal-modules">Exposing internal functionality (Internal modules)</a></h1>
<p>We have now built a very small but convenient and safe way to write
HTML code in Haskell. This is something that we could (potentially)
publish as a <em>library</em> and share with the world by uploading it
to a package repository such as <a href="https://hackage.haskell.org/">Hackage</a>.
Users interested in our library could use a package manager
to include it in their project and build their own HTML pages.</p>
<p>It is important to note that users are building their projects against
the API that we expose to them, and the package manager doesn't generally
provide access to the source code, so they can't, for example,
modify the <code>Html</code> module (that we expose) in their project directly
without jumping through some hoops.</p>
<p>Because we wanted our <code>Html</code> EDSL to be safe, we <strong>hid the internal
implementation from the user</strong>, and the only way to interact with the
library is via the API we provide.</p>
<p>This provides the safety we wanted to provide, but in this case, it also
<em>blocks</em> the user from extending our library <em>in their own project</em> with
things we haven't implemented yet, such as lists or code blocks.</p>
<p>When a user runs into trouble with a library (such as missing features)
the best course of action usually is to open an issue in the repository or
submit a pull request, but sometimes the user needs things to work <em>now</em>.</p>
<p>We admit that we are not perfect and can't think of all use cases for our
library. Sometimes the restrictions we add are too great and may limit
the usage of advanced users who know how things work under the hood and
need certain functionality to use our library.</p>
<h3 id="internal-modules"><a class="header" href="#internal-modules">Internal modules</a></h3>
<p>For that, we can expose internal modules to provide some flexibility for
advanced users. Internal modules are not a language concept but
rather a (fairly common) design pattern (or idiom) in Haskell.</p>
<p>Internal modules are simply modules named <code>&lt;something&gt;.Internal</code>,
which export all of the functionality and implementation details in that module.</p>
<p>Instead of writing the implementation in (for example) the <code>Html</code> module,
we write it in the <code>Html.Internal</code> module, which will export everything.
Then we will import that module in the <code>Html</code> module and write an explicit export list
to only export the API we'd like to export (as before).</p>
<p><code>Internal</code> modules are considered unstable and risky to use by convention.
If you end up using one yourself when using an external Haskell library,
make sure to open a ticket in the library's repository after the storm has passed!</p>
<h3 id="lets-make-the-changes"><a class="header" href="#lets-make-the-changes">Let's make the changes</a></h3>
<p>We will create a new directory named <code>Html</code> and inside it a new file
named <code>Internal.hs</code>. The name of this module should be <code>Html.Internal</code>.</p>
<p>This module will contain all of the code we previously had in the <code>Html</code>
module, but <strong>we will change the module declaration in <code>Html.Internal</code>
and <em>omit</em> the export list</strong>:</p>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

...
</code></pre>
<p>And now in <code>Html.hs</code>, we will remove the code that we moved to <code>Html/Internal.hs</code>
and in its stead we'll import the internal module:</p>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<p>Now, users of our library can still import <code>Html</code> and safely use our library,
but if they run into trouble and have a dire need to implement unordered lists
to work with our library, they could always work with <code>Html.Internal</code> instead.</p>
<details>
  <summary><b>Our revised Html.hs and Html/Internal.hs</b></summary>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h1_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
</details>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>For our particular project, <code>Internal</code> modules aren't necessary.
Because our project and the source code for the HTML EDSL are
part of the same project, and we have access to the <code>Html</code>
module directly, we can always go and edit it if we want
(and we are going to do that throughout the book).</p>
<p>However, if we were planning to release our HTML EDSL as a <em>library</em>
for other developers to use, it would be nice
to also expose the internal implementation as an <code>Internal</code>
module. Just so we can save some trouble for potential users!</p>
<p>In a later chapter, we will see how to create a package from our source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>We need a few more features for our HTML library to be useful for
our blog software. Add the following features to our <code>Html.Internal</code> module
and expose them from <code>Html</code>.</p>
<h2 id="1-unordered-lists"><a class="header" href="#1-unordered-lists">1. Unordered lists</a></h2>
<p>These lists have the form:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;item 1&lt;/li&gt;
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>We want in our library a new function:</p>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
</code></pre>
<p>So that users can write this:</p>
<pre><code class="language-hs">ul_
  [ p_ &quot;item 1&quot;
  , p_ &quot;item 2&quot;
  , p_ &quot;item 3&quot;
  ]
</code></pre>
<p>and get this:</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;item 1&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 2&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;item 3&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h2 id="2-ordered-lists"><a class="header" href="#2-ordered-lists">2. Ordered lists</a></h2>
<p>Very similar to unordered lists, but instead of <code>&lt;ul&gt;</code> we use <code>&lt;ol&gt;</code></p>
<h2 id="3-code-blocks"><a class="header" href="#3-code-blocks">3. Code blocks</a></h2>
<p>Very similar to <code>&lt;p&gt;</code>, but use the <code>&lt;pre&gt;</code> tag. Call this function <code>code_</code>.</p>
<h2 id="solutions"><a class="header" href="#solutions">Solutions</a></h2>
<details>
  <summary>Unordered lists</summary>
<pre><code class="language-hs">ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
</details>
<details>
  <summary>Ordered lists</summary>
<pre><code class="language-hs">ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)
</code></pre>
<p>Note: the two functions above could be unified.</p>
</details>
<details>
  <summary>Code blocks</summary>
<pre><code class="language-hs">code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<p>In this chapter, we built a very minimal HTML EDSL.
We will later use this library to convert our custom markup formatted text to HTML.</p>
<p>We've also learned about:</p>
<ul>
<li>Defining and using functions</li>
<li>Types and type signatures</li>
<li>Embedded domain-specific languages</li>
<li>Chaining functions using the <code>.</code> operator</li>
<li>Preventing incorrect use with <code>newtype</code>s</li>
<li>Defining modules and the <code>Internal</code> module pattern</li>
<li>Encapsulation using <code>newtype</code>s and modules</li>
</ul>
<p>Here's our complete program up to this point:</p>
<pre><code class="language-hs">-- hello.hs

import Html

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )
</code></pre>
<pre><code class="language-hs">-- Html.hs

module Html
  ( Html
  , Title
  , Structure
  , html_
  , h1_
  , p_
  , ul_
  , ol_
  , code_
  , append_
  , render
  )
  where

import Html.Internal
</code></pre>
<pre><code class="language-hs">-- Html/Internal.hs

module Html.Internal where

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot; . escape

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot; . escape

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar
</code></pre>
<blockquote>
<p>You can also <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/2a4691de627bcb280e92f3d02a88d5404179dc86">browse the code as a tree</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-markup-language"><a class="header" href="#custom-markup-language">Custom markup language</a></h1>
<p>In this chapter, we will define our own simple markup language
and parse documents written in this language into Haskell data structures.</p>
<p>Our markup language will contain the following features:</p>
<ul>
<li>Headings: prefix by a number of <code>*</code> characters</li>
<li>Paragraphs: a group of lines without empty lines in between</li>
<li>Unordered lists: a group of lines, each prefixed with <code>- </code></li>
<li>Ordered lists: a group of lines, each prefixed with <code># </code></li>
<li>Code blocks: a group of lines, each prefixed with <code>&gt; </code></li>
</ul>
<p>Here's a sample document:</p>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
<p>which we will eventually convert into this (modulo formatting) HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Compiling programs with ghc&lt;/h1&gt;

&lt;p&gt;Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.
&lt;/p&gt;

&lt;p&gt;Create a new Haskell source file named hello.hs, and write
the following code in it:
&lt;/p&gt;

&lt;pre&gt;main = putStrLn &quot;Hello, Haskell!&quot;
&lt;/pre&gt;

&lt;p&gt;Now, we can compile the program by invoking ghc with the file name:&lt;/p&gt;

&lt;pre&gt;
➜ ghc hello.hs
[1 of 1] Compiling Main             ( hello.hs, hello.o )
Linking hello ...
&lt;/pre&gt;

&lt;p&gt;GHC created the following files:
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hello.hi - Haskell interface file&lt;/li&gt;
  &lt;li&gt;hello.o - Object file, the output of the compiler before linking&lt;/li&gt;
  &lt;li&gt;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GHC will produce an executable when the source file satisfies both conditions:
&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Defines the main function in the source file&lt;/li&gt;
  &lt;li&gt;Defines the module name to be Main, or does not have a module declaration&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Otherwise, it will only produce the .o and .hi files.
&lt;/p&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-the-markup-language-as-a-haskell-data-type"><a class="header" href="#representing-the-markup-language-as-a-haskell-data-type">Representing the markup language as a Haskell data type</a></h1>
<p>One of the clear differentiators between Haskell (also other ML-family of languages)
and most mainstream languages is the ability to represent data precisely and succinctly.</p>
<p>So how do we represent our markup language using Haskell?</p>
<p>Previously, in our HTML builder library, we used <code>newtype</code>s to differentiate
between HTML documents, structures, and titles, but we didn't really need to
differentiate between different kinds of structures, such as paragraphs and headings,
not without parsing the data, at least.</p>
<p>In this case, we have a list of structures, and each structure could be
one of a few specific options (a paragraph, a heading, a list, etc.),
and we want to be able to know which structure is which so we can easily
convert it into the equivalent HTML representation.</p>
<p>For that, we have <code>data</code> definitions. Using <code>data</code> we can
create custom types by grouping multiple types together and having
alternative structures. Think of them as a combination of both structs and enums.</p>
<p><code>data</code> declarations look like this:</p>
<pre><code class="language-hs">data &lt;Type-name&gt; &lt;type-args&gt;
  = &lt;Data-constructor1&gt; &lt;types&gt;
  | &lt;Data-constructor2&gt; &lt;types&gt;
  | ...
</code></pre>
<p>It looks really similar to <code>newtype</code>, but there are two important
differences:</p>
<ol>
<li>In the <code>&lt;types&gt;</code> part, we can write many types (Like <code>Int</code>, <code>String</code>, or <code>Bool</code>).
For <code>newtype</code>s, we can only write one.</li>
<li>We can have alternative structures using <code>|</code>, <code>newtype</code>s have no
alternatives.</li>
</ol>
<p>This is because <code>newtype</code> is used to provide a type-safe <strong>alias</strong>, and <code>data</code>
is used to build a new <strong>composite</strong> type that can potentially have <em>alternatives</em>.</p>
<p>Let's see a few examples of data types:</p>
<ol>
<li>
<p>Bool</p>
<pre><code class="language-hs">data Bool
  = True
  | False
</code></pre>
<p>We created a new data type named <code>Bool</code> with the possible values <code>True</code> or <code>False</code>.
In this case, we only have <em>constructor</em> alternatives, and none of the constructors
carry additional values. This is similar to enums in other languages.</p>
</li>
<li>
<p>Person</p>
<pre><code class="language-hs">data Person
  = Person String Int -- where the first is the name and the second is
                      -- the age
</code></pre>
<p>We created a new data type named <code>Person</code>. Values of the type <code>Person</code>
look like this:</p>
<pre><code>Person &lt;some-string&gt; &lt;some-int&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>In this case, we create a <em>composite</em> of multiple types without alternatives.
This is similar to structs in other languages, but structs give each field
a name, and here we distinguish them by position.</p>
<p>Alternatively, Haskell has <em>syntactic sugar</em> for naming fields called <strong>records</strong>.
The above definition can also be written like this:</p>
<pre><code class="language-hs">data Person
  = Person
    { name :: String
    , age :: Int
    }
</code></pre>
<p>Values of this type can be written exactly as before,</p>
<pre><code class="language-hs">Person &quot;Gil&quot; 32
</code></pre>
<p>Or with this syntax:</p>
<pre><code class="language-hs">Person { name = &quot;Gil&quot;, age = 32 }
</code></pre>
<p>Haskell will also generate functions that can be used to extract the fields from the composite type:</p>
<pre><code class="language-hs">name :: Person -&gt; String
age :: Person -&gt; Int
</code></pre>
<p>Which can be used like this:</p>
<pre><code class="language-hs">ghci&gt; age (Person { name = &quot;Gil&quot;, age = 32 })
32
</code></pre>
<p>We even have a special syntax for updating specific fields in a record. Of course,
we do not update records in place - we generate a new value instead.</p>
<pre><code class="language-hs">ghci&gt; gil = Person { name = &quot;Gil&quot;, age = 32 }
ghci&gt; age (gil { age = 33 })
33
ghci&gt; age gil
32
</code></pre>
<p>Unfortunately, having specialized functions for each field also means that if we
defined a different data type with the field <code>age</code>, the functions which GHC needs
to generate will clash.</p>
<p>The easiest way to solve this is to give fields unique names, for example
by adding a prefix:</p>
<pre><code class="language-hs">data Person
  = Person
    { pName :: String
    , pAge :: Int
    }
</code></pre>
<p>Another way is by using extensions to the Haskell language, which we will cover
in later chapters.</p>
</li>
<li>
<p>Tuple</p>
<pre><code class="language-hs">data Tuple a b
  = Tuple a b
</code></pre>
<p>This is pretty similar to <code>Person</code>, but we can plug any type we want
for this definition. For example:</p>
<pre><code class="language-hs">Tuple &quot;Clicked&quot; True :: Tuple String Bool

Tuple 'a' 'z' :: Tuple Char Char
</code></pre>
<p>This type has special syntax in Haskell:</p>
<pre><code class="language-hs">(&quot;Clicked&quot;, True) :: (String, Bool)

('a', 'z') :: (Char, Char)
</code></pre>
<p>This <code>Tuple</code> definition is polymorphic; we define the structure but are able to
plug different types into the structure to get concrete types. You can think of <code>Tuple</code>
as a <em>template</em> for a data type waiting to be filled or as a <strong>function</strong> waiting
for types as input in order to return a data type. We can even take a look at the &quot;type&quot;
signature of <code>Tuple</code> in <code>ghci</code> using the <code>:kind</code> command.</p>
<pre><code class="language-hs">ghci&gt; data Tuple a b = Tuple a b
ghci&gt; :kind Tuple
Tuple :: * -&gt; * -&gt; *
</code></pre>
<blockquote>
<h4 id="quick-detour-kinds"><a class="header" href="#quick-detour-kinds">Quick detour: Kinds</a></h4>
<p>The <code>:kind</code> command is called as such because the &quot;type&quot; of a type is called a <strong>kind</strong>.
Kinds can be one of two things, either a <code>*</code>, which means a saturated (or concrete) type,
such as <code>Int</code> or <code>Person</code>, or an <code>-&gt;</code> of two kinds, which is, as you might have guessed,
a type function, taking kind and returning a kind.</p>
<p>Note that only types that have the kind <code>*</code> can have values. So, for example, while <code>Tuple Int</code>
is a valid Haskell concept that has the <em>kind</em> <code>* -&gt; *</code>, and we can write code that will
work &quot;generically&quot; for all types that have a certain kind (e.g. <code>* -&gt; *</code>), we cannot
construct a value that has the kind <code>* -&gt; *</code>. All values have types and all
types that have values have the kind <code>*</code>.</p>
<p>We will talk more about kinds later; let's focus on types for now!</p>
</blockquote>
</li>
<li>
<p>Either</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Similar to Tuple, but instead of having only one constructor, we have
two. This means that we can choose which side we want. Here are a
couple of values of type <code>Either String Int</code>:</p>
<pre><code class="language-hs">Left &quot;Hello&quot;

Right 17
</code></pre>
<p>This type is useful for modeling errors. Either we succeeded and got
what we wanted (The <code>Right</code> constructor with the value), or we didn't
and got an error instead (The <code>Left</code> constructor with a string or a
custom error type).</p>
</li>
</ol>
<p>In our program, we use <code>data</code> types to model the different kinds of content types
in our markup language. We tag each structure using the data constructor
and provide the rest of the information (the paragraph text, the list items, etc.)
in the <code>&lt;types&gt;</code> section of the data declaration for each constructor:</p>
<pre><code class="language-hs">type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
<p>Note: <code>Natural</code> is defined in the <code>base</code> package but not exported from <code>Prelude</code>.
Find out which module to import <code>Natural</code> by using <a href="https://hoogle.haskell.org">Hoogle</a>.</p>
<hr />
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<p>Represent the following markup documents as values of <code>Document</code>:</p>
<ol>
<li>
<pre><code class="language-org">Hello, world!
</code></pre>
</li>
<li>
<pre><code class="language-org">* Welcome

To this tutorial about Haskell.
</code></pre>
</li>
<li>
<pre><code class="language-org">Remember that multiple lines with no separation
are grouped together into a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
</code></pre>
</li>
<li>
<pre><code class="language-org">* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
</code></pre>
</li>
</ol>
<p>Solutions:</p>
<details>
  <summary>Solution 1</summary>
<pre><code class="language-hs">example1 :: Document
example1 =
  [ Paragraph &quot;Hello, world!&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 2</summary>
<pre><code class="language-hs">example2 :: Document
example2 =
  [ Heading 1 &quot;Welcome&quot;
  , Paragraph &quot;To this tutorial about Haskell.&quot;
  ]
</code></pre>
</details>
<details>
  <summary>Solution 3</summary>
<pre><code class="language-hs">example3 :: Document
example3 =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together into a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
</details>
<details>
  <summary>Solution 4</summary>
<pre><code class="language-hs">example4 :: Document
example4 =
  [ Heading 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;➜ ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<p>Add a new module named <code>Markup</code> and add the data type definition to it.
Note that in this case, we <em>do</em> want to export the constructors of <code>Structure</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  )
where

import Numeric.Natural

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
</code></pre>
</details>
<hr />
<h2 id="translating-directly"><a class="header" href="#translating-directly">Translating directly?</a></h2>
<p>You might ask, &quot;Why do we even need to represent the markup as a type?
Why don't we convert it into HTML as soon as we parse it
instead?&quot;. That's a good question and a valid strategy. The reason we
first represent it as a Haskell type is for flexibility and modularity.</p>
<p>If the parsing code is coupled with HTML generation, we lose the
ability to pre-process the markup document. For example, we might want
to take only a small part of the document (for a summary) and present
it, or create a table of content from headings. Or maybe we'd like to
add other targets and not just HTML - maybe markdown format or a GUI reader?</p>
<p>Parsing to an &quot;abstract data type&quot; (ADT) representation (one that does
not contain the details of the language, for example, '#' for
ordered lists) gives us the freedom to do so much more than just
conversion to HTML that it's usually worth it, in my opinion, unless you
really need to optimize the process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-01-recursion"><a class="header" href="#parsing-markup-part-01-recursion">Parsing markup part 01 (Recursion)</a></h1>
<p>Let's have a look at how to parse a multi-lined string of markup text
written by a user and convert it to the <code>Document</code> type we defined
in the previous chapter.</p>
<p>Our strategy is to take the string of markup text and:</p>
<ol>
<li>Split it into a list where each element represents a separate line, and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>So the first thing we want to do is to process the string line by line.
We can do that by converting the string to a list of string.
Fortunately, the Haskell
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"><code>Prelude</code></a>
module from the Haskell standard library
<a href="https://hackage.haskell.org/package/base"><code>base</code></a> exposes the function
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"><code>lines</code></a>
that does exactly what we want. The <code>Prelude</code> module is exposed in every
Haskell file by default, so we don't need to import it.</p>
<p>For the line processing part, let's start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter.</p>
<p>A common solution in imperative programs would be to iterate over the lines
using some <em>loop</em> construct and accumulate lines that should be grouped together
into some intermediate mutable variable. When we reach an empty line, we insert
the content of that variable into another mutable variable that accumulates the
results.</p>
<p>Our approach in Haskell isn't so different, except that we do not use loops
or mutable variables. Instead, we use <strong>recursion</strong>.</p>
<h2 id="recursion-and-accumulating-information"><a class="header" href="#recursion-and-accumulating-information">Recursion and accumulating information</a></h2>
<p>Instead of loops, in Haskell, we use recursion to model iteration.</p>
<p>Consider the following contrived example: let's say that
we want to write an algorithm for adding two natural numbers together,
and we don't have a standard operation to do that (+), but we do
have two operations we could use on each number: <code>increment</code>
and <code>decrement</code>.</p>
<p>A solution we could come up with is to slowly &quot;pass&quot; one number
to the other number iteratively by incrementing one and decrementing the other.
And we do that until the number we decrement reaches 0.</p>
<p>For example, for <code>3</code> and <code>2</code>:</p>
<ul>
<li>We start with <code>3</code> and <code>2</code>, and we increment <code>3</code> and decrement <code>2</code></li>
<li>In the next step, we now have <code>4</code> and <code>1</code>, we increment <code>4</code> and decrement <code>1</code></li>
<li>In the next step, we now have <code>5</code> and <code>0</code>, since the second number is <code>0</code> we declare <code>5</code> as the result.</li>
</ul>
<p>This can be written imperatively using a loop:</p>
<pre><code class="language-js">function add(n, m) {
  while (m /= 0) {
    n = increment(n);
    m = decrement(m);
  }
  return n;
}
</code></pre>
<p>We can write the same algorithm in Haskell without mutation using recursion:</p>
<pre><code class="language-hs">add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n
</code></pre>
<p>In Haskell, to <em>emulate iteration with a mutable state</em>, we call the function again
with the values we want the variables to have in the next iteration.</p>
<h3 id="evaluation-of-recursion"><a class="header" href="#evaluation-of-recursion">Evaluation of recursion</a></h3>
<p>Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.
This is because, in imperative languages, calling a function often requires creating
a new call stack.</p>
<p>However, functional languages (and Haskell in particular) play by different
rules and implement a feature called tail call elimination - when the result of a function call
is the result of the function (this is called tail position), we can just drop the current
stack frame and then allocate one for the function we call, so we don't require <code>N</code> stack frames
for <code>N</code> iterations.</p>
<p>This is, of course, only one way to do tail call elimination and other
strategies exist, such as translating code like our recursive <code>add</code> above to the iteration version.</p>
<h4 id="laziness"><a class="header" href="#laziness">Laziness</a></h4>
<p>Haskell plays by slightly different rules because it uses a <em>lazy evaluation strategy</em>
instead of the much more common strict evaluation strategy. An <em>evaluation strategy</em>
refers to &quot;when do we evaluate a computation&quot;. In a strict language, the answer is simple:
<em>we evaluate the arguments of a function before entering a function</em>.</p>
<p>So, for example, the evaluation of <code>add (increment 3) (decrement 2)</code> using strict evaluation
will look like this:</p>
<ol>
<li>Evaluate <code>increment 3</code> to <code>4</code></li>
<li>Evaluate <code>decrement 2</code> to <code>1</code></li>
<li>Evaluate <code>add 4 1</code></li>
</ol>
<p>Or, alternatively (depending on the language), we reverse (1) and (2) and evaluate the arguments
from right-to-left instead of left-to-right.</p>
<p>On the other hand, with lazy evaluation, we <em>only evaluate computation when we need it</em>, which
is when it is part of a computation that will have some effect on the
outside world, for example, when writing a computation to standard output or sending it over the network.</p>
<p>So unless this computation is required, it won't be evaluated. For example:</p>
<pre><code class="language-hs">main =
  if add (increment 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>In the case above, we need the result of <code>add (increment 2) (decrement 3)</code>
in order to know which message to write,
so it will be evaluated. But:</p>
<pre><code class="language-hs">main =
  let
    five = add (increment 2) (decrement 3)
  in
    putStrLn &quot;Not required&quot;
</code></pre>
<p>In the case above, we don't actually need <code>five</code>, so we don't evaluate it!</p>
<p>But then, if we know we need <code>add (increment 2) (decrement 3)</code>,
do we use strict evaluation now? The answer is no - because we might not need
to evaluate the arguments to complete the computation. For example, in this case:</p>
<pre><code class="language-hs">const a b = a

main =
  if const (increment 2) (decrement 3) == 3
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p><code>const</code> ignores the second argument and returns the first, so we don't actually need
to calculate <code>decrement 3</code> to provide an answer to the computation and in
turn output an answer to the screen.</p>
<p>With the lazy evaluation strategy, we will evaluate expressions when we need to (when they are required
in order to do something for the user), and we evaluate from the outside in - first
we enter functions, and then we evaluate the arguments when we need to (usually when the thing
we want to evaluate appears in some control flow such as the condition of an <code>if</code> expression
or a pattern in pattern matching).</p>
<hr />
<p>I've written a more in-depth blog post about how this works in Haskell:
<a href="https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning">Substitution and Equational Reasoning</a>.</p>
<p>Please read it and try to evaluate the following program by hand:</p>
<pre><code class="language-hs">import Prelude hiding (const) -- feel free to ignore this line

increment n = n + 1

decrement n = n - 1

const a b = a

add n m =
  if m /= 0
    then add (increment n) (decrement m)
    else n

main =
  if const (add 3 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Remember that evaluation always begins from <code>main</code>.</p>
<details>
  <summary>Solution</summary>
<p>evaluating <code>main</code></p>
<pre><code class="language-hs">if const (add 3 2) (decrement 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>const</code></p>
<pre><code class="language-hs">if add 3 2 == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>add</code></p>
<pre><code class="language-hs">if (if 2 /= 0 then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>evaluating the control flow <code>2 /= 0</code></p>
<pre><code class="language-hs">if (if True then add (increment 3) (decrement 2) else 3) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if (add (increment 3) (decrement 2)) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>add</code></p>
<pre><code class="language-hs">if
  ( if decrement 2 /= 0
    then add
      (increment (increment 3))
      (decrement (decrement 2))
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating <code>decrement 2</code> in the control flow (notice how both places change!)</p>
<pre><code class="language-hs">if
  ( if 1 /= 0
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating the control flow <code>1 /= 0</code></p>
<pre><code class="language-hs">if
  ( if True
    then add
      (increment (increment 3))
      (decrement 1)
    else (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if
  ( add
    (increment (increment 3))
    (decrement 1)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Expanding <code>add</code></p>
<pre><code class="language-hs">if
  ( if decrement 1 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement (decrement 1))
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>decrement 1</code></p>
<pre><code class="language-hs">if
  ( if 0 /= 0
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>0 /= 0</code></p>
<pre><code class="language-hs">if
  ( if False
    then add
      (increment (increment (increment 3)))
      (decrement 0)
    else increment (increment 3)
  ) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>else</code> branch</p>
<pre><code class="language-hs">if
  (increment (increment 3)) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate control flow <code>increment (increment 3)</code></p>
<pre><code class="language-hs">if
  (increment 3 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>increment 3</code></p>
<pre><code class="language-hs">if
  (3 + 1 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>3 + 1</code></p>
<pre><code class="language-hs">if
  (4 + 1) == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>4 + 1</code></p>
<pre><code class="language-hs">if
  5 == 5
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>5 == 5</code></p>
<pre><code class="language-hs">if
  True
  then putStrLn &quot;Yes.&quot;
  else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">putStrLn &quot;Yes.&quot;
</code></pre>
<p>Which when run will print <code>Yes.</code> to the screen.</p>
</details>
<hr />
<h3 id="general-recursion"><a class="header" href="#general-recursion">General recursion</a></h3>
<p>In general, when trying to solve problems recursively, it is useful to think
about the problem in three parts:</p>
<ol>
<li>Finding the <strong>base case</strong> (the most simple cases - the ones we already know how to answer)</li>
<li>Figuring out how to <strong>reduce</strong> the problem to something simpler (so it gets closer to the base case)</li>
<li><strong>Mitigating the difference</strong> between the reduced version and the solution we need to provide</li>
</ol>
<p>The reduce and mitigate steps together are usually called the <em>recursive step</em>.</p>
<p>Let's take a look at another example problem: generating a list of a particular size
with a specific value in place of every element.</p>
<p>In Haskell, this function would have the following signature:</p>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
</code></pre>
<p>Here are a few usage examples of <code>replicate</code>:</p>
<pre><code class="language-hs">ghci&gt; replicate 4 True
[True,True,True,True]
ghci&gt; replicate 0 True
[]
ghci&gt; replicate (-13) True
[]
</code></pre>
<p>How would we implement this function recursively? How would we describe it in the three steps above?</p>
<ol>
<li><strong>Base case</strong>: the cases we already know how to generate are the cases where the length
of the list is zero (or less) - we just return an empty list.</li>
<li><strong>Reduce</strong>: while we might not know how to generate a list of size <code>N</code> (where <code>N</code> is positive),
if we knew the solution for <code>N-1</code>, we could:</li>
<li><strong>Mitigate</strong>: Add another element to the solution for <code>N-1</code> using the <code>:</code> (cons) operator.</li>
</ol>
<hr />
<p>Try to write this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
replicate n x =
  if n &lt;= 0    -- recognizing the base case
    then
      []       -- the solution for the base case
    else
        x : replicate (n - 1) x
  --   ---  -------------------
  --    ^           ^
  --    |           |
  --    |           +-------- reduction
  --    |
  --    +--- mitigation
</code></pre>
</details>
<hr />
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual recursion</a></h3>
<p>When solving functions recursively, we usually call the same function again,
but that doesn't have to be the case. It is possible to reduce our problem
to something simpler that requires an answer from a different function.
If, in turn, that function will (or another function in that call chain)
call our function again; we have a <strong>mutual recursive</strong> solution.</p>
<p>For example, let's write two functions, one that checks whether a natural number
is even or not, and one that checks whether a number is odd or not
only by decrementing it.</p>
<pre><code class="language-hs">even :: Int -&gt; Bool

odd :: Int -&gt; Bool
</code></pre>
<p>Let's start with <code>even</code>; how should we solve this recursively?</p>
<ol>
<li><strong>Base case</strong>: We know the answer for <code>0</code> - it is <code>True</code>.</li>
<li><strong>Reduction</strong>: We might not know the answer for a general <code>N</code>, but we could check whether <code>N - 1</code> is odd,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is odd, then <code>N</code> is even! if it isn't odd, then <code>N</code> isn't even.</li>
</ol>
<p>What about <code>odd</code>?</p>
<ol>
<li><strong>Base case</strong>: We know the answer for <code>0</code> - it is <code>False</code>.</li>
<li><strong>Reduction</strong>: We might not know the answer for a general <code>N</code>, but we could check whether <code>N - 1</code> is even,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is even, then <code>N</code> is odd! if it isn't even, then <code>N</code> isn't odd.</li>
</ol>
<hr />
<p>Try writing this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">even :: Int -&gt; Bool
even n =
  if n == 0
    then
      True
    else
      odd (n - 1)

odd :: Int -&gt; Bool
odd n =
  if n == 0
    then
      False
    else
      even (n - 1)

</code></pre>
</details>
<hr />
<h2 id="partial-functions"><a class="header" href="#partial-functions">Partial functions</a></h2>
<p>Because we didn't handle the negative numbers cases in the example above,
our functions will loop forever when a negative value is passed as input.
A function that does not return a result for some value
(either by not terminating or by throwing an error) is called <strong>a partial function</strong>
(because it only returns a result for a part of the possible inputs).</p>
<p>Partial functions are generally considered <strong>bad practice</strong> because they can have
undesired behaviour at runtime (a runtime exception or an infinite loop),
so we want to <strong>avoid using</strong> partial functions
as well as <strong>avoid writing</strong> partial functions.</p>
<p>The best way to avoid writing partial functions is by covering all inputs!
In the situation above, it is definitely possible to handle negative numbers
as well, so we should do that! Or, instead, we could require that our functions
accept a <code>Natural</code> instead of an <code>Int</code>, and then the type system would've stopped
us from using these functions with values we did not handle.</p>
<p>There are cases where we can't possibly cover all inputs; in these cases, it is important
to re-examine the code and see if we could further restrict the inputs using types to
mitigate these issues.</p>
<p>For example, the <code>head :: [a] -&gt; a</code> function from <code>Prelude</code> promises
to return the first element (the head) of a list, but we know that lists
could possibly be empty, so how can this function deliver on its promise?</p>
<p>Unfortunately, it can't. But there exists a different function that can:
<code>head :: NonEmpty a -&gt; a</code> from the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-List-NonEmpty.html"><code>Data.List.NonEmpty</code></a>
module! The trick here is that this other <code>head</code> does not take a general list
as input, it takes a different type entirely, one that promises to have
at least one element and, therefore, can deliver on its promise!</p>
<p>We could also potentially use smart constructors with <code>newtype</code> and enforce some sort
of restrictions in the type system, as we saw in earlier chapters,
But this solution can sometimes be less ergonomic to use.</p>
<p>An alternative approach is to use <code>data</code> types to encode the absence of a proper result,
for example, using <code>Maybe</code>, as we'll see in a future chapter.</p>
<p>Make sure the functions you write return a result for every input,
either by constraining the input using types or by encoding the absence of a result using
types.</p>
<h2 id="parsing-markup"><a class="header" href="#parsing-markup">Parsing markup?</a></h2>
<p>Let's get back to the task at hand.</p>
<p>As stated previously, our strategy for parsing the markup text is:</p>
<ol>
<li>Split the string into a list where each element is a separate line
(which we can do with <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:lines"><code>lines</code></a>), and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>Remember that we want to start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
  in
    case txts of -- (4)
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest -- (5)
          else
            parseLines (currentLine : currentParagraph) rest -- (6)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Things to note:</p>
<ol>
<li>
<p>We pass a list that contains the currently grouped paragraph (paragraphs are separated by an empty line)</p>
</li>
<li>
<p>Because of laziness, <code>paragraph</code> is not computed until it's needed, so we don't have to worry about
the performance implications in the case that we are still grouping lines</p>
</li>
<li>
<p>Why do we reverse <code>currentParagraph</code>? (See point (6))</p>
</li>
<li>
<p>We saw case expressions used to deconstruct <code>newtype</code>s and <code>Char</code>s,
but we can also pattern match on lists and other ADTs as well!
In this case, we match against two patterns, an empty list (<code>[]</code>),
and a &quot;cons cell&quot; - a list with at least one element (<code>currentLine : rest</code>).
In the body of the &quot;cons&quot; pattern, we bind the first element to the name <code>currentLine</code>,
and the rest of the elements to the name <code>rest</code>.</p>
<p>We will talk about how all of this works really soon!</p>
</li>
<li>
<p>When we run into an empty line, we add the accumulated paragraph to the resulting list (A <code>Document</code> is a list of structures) and start the function again with the rest of the input.</p>
</li>
<li>
<p>We pass the new lines to be grouped in a paragraph <strong>in reverse order</strong> because of
performance characteristics - because of the nature of singly-linked lists,
prepending an element is fast, and appending is slow. Prepending only requires
us to create a new cons (<code>:</code>) cell to hold a pointer to the value and a pointer to the list,
but appending requires us to traverse the list to its end and rebuild the cons cells -
the last one will contain the last value of the list and a pointer to the list to append,
the next will contain the value before the last value of the list and a pointer to the
list, which contains the last element and the appended list, and so on.</p>
</li>
</ol>
<p>This code above will group together paragraphs in a structure, but how do we view our result?
In the next chapter, we will take a short detour and talk about type classes, and how
they can help us in this scenario.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="displaying-the-parsing-results-type-classes"><a class="header" href="#displaying-the-parsing-results-type-classes">Displaying the parsing results (type classes)</a></h1>
<p>We want to be able to print a textual representation of values
of our <code>Document</code> type. There are a few ways to do that:</p>
<ol>
<li>Write our own function of type <code>Document -&gt; String</code>, which we could then print, or</li>
<li>Have Haskell write one for us</li>
</ol>
<p>Haskell provides us with a mechanism that can automatically generate the implementation of a
<em>type class</em> function called <code>show</code>, that will convert our type to <code>String</code>.</p>
<p>The type of the function <code>show</code> looks like this:</p>
<pre><code class="language-hs">show :: Show a =&gt; a -&gt; String
</code></pre>
<p>This is something new we haven't seen before. Between <code>::</code> and <code>=&gt;</code>
you see what is called a <strong>type class constraint</strong> on the type <code>a</code>. What
we say in this signature is that the function <code>show</code> can work on any
type that is a member of the type class <code>Show</code>.</p>
<p>Type classes is a feature in Haskell that allows us to declare a common
interface for different types. In our case, Haskell's standard library
defines the type class <code>Show</code> in the following way (this is a simplified
version but good enough for our purposes):</p>
<pre><code class="language-hs">class Show a where
  show :: a -&gt; String
</code></pre>
<p>A type class declaration describes a common interface for Haskell types.
<code>show</code> is an overloaded function that will work for any type that is an <em>instance</em>
of the type class <code>Show</code>.
We can define an instance of a type class manually like this:</p>
<pre><code class="language-hs">instance Show Bool where
  show x =
    case x of
      True -&gt; &quot;True&quot;
      False -&gt; &quot;False&quot;
</code></pre>
<p>Defining an instance means providing an implementation for the interface of a specific type.
When we call the function <code>show</code> on a data type, the compiler will search the type's <code>Show</code> instance,
and use the implementation provided in the instance declaration.</p>
<pre><code class="language-hs">ghci&gt; show True
&quot;True&quot;
ghci&gt; show 187
&quot;187&quot;
ghci&gt; show &quot;Hello&quot;
&quot;\&quot;Hello\&quot;&quot;
</code></pre>
<p>As seen above, the <code>show</code> function converts a value to its textual representation.
That is why <code>&quot;Hello&quot;</code> includes the quotes as well. The <code>Show</code> type class is usually
used for debugging purposes.</p>
<h2 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving instances</a></h2>
<p>It is also possible to automatically generate implementations of a few selected
type classes. Fortunately, <code>Show</code> is one of them.</p>
<p>If all the types in the definition of our data type already implement
an instance of <code>Show</code>, we can <em>automatically derive</em> it by adding <code>deriving Show</code> at the
end of the data definition.</p>
<pre><code class="language-hs">data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving Show
</code></pre>
<p>Now we can use the function <code>show :: Show a =&gt; a -&gt; String</code> for any
type that implements an instance of the <code>Show</code> type class. For example, with <code>print</code>:</p>
<pre><code class="language-hs">print :: Show a =&gt; a -&gt; IO ()
print = putStrLn . show
</code></pre>
<p>We can first convert our type to <code>String</code> and then write it to the
standard output.</p>
<p>And because lists also implement <code>Show</code> for any element type that has
a <code>Show</code> instance, we can now print <code>Document</code>s, because they are just
aliases for <code>[Structure]</code>. Try it!</p>
<p>There are many type classes Haskellers use everyday. A couple more are
<code>Eq</code> for equality and <code>Ord</code> for ordering. These are also special type classes
that can be derived automatically.</p>
<h2 id="laws"><a class="header" href="#laws">Laws</a></h2>
<p>Type classes often come with &quot;rules&quot; or &quot;laws&quot; that instances should satisfy,
the purpose of these laws is to provide <em>predictable behaviour</em> across
instances, so that when we run into a new instance we can be confident
that it will behave in an expected way, and we can write code
that works generically for all instances of a type class while expecting
them to adhere to these rules.</p>
<p>As an example, let's look at the <code>Semigroup</code> type class:</p>
<pre><code class="language-hs">class Semigroup a where
  (&lt;&gt;) :: a -&gt; a -&gt; a
</code></pre>
<p>This type class provides a common interface for types with an operation <code>&lt;&gt;</code>
that can combine two values into one in some way.</p>
<p>This type class also mentions that this <code>&lt;&gt;</code> operation should be associative,
meaning that these two sides should evaluate to the same result:</p>
<pre><code>x &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z
</code></pre>
<p>An example of a lawful instance of <code>Semigroup</code> is lists with the append operation (<code>++</code>):</p>
<pre><code class="language-hs">instance Semigroup [a] where
  (&lt;&gt;) = (++)
</code></pre>
<p>Unfortunately, the Haskell type system cannot &quot;prove&quot; that instances
satisfy these laws, but as a community, we often shun unlawful instances.</p>
<p>Many data types (together with their respective operations) can
form a <code>Semigroup</code>, and instances
don't even have to look similar or have a common analogy/metaphor
(and this is true for many other type classes as well).</p>
<p><strong>Type classes are often just <em>interfaces</em> with <em>laws</em></strong> (or expected behaviours if you will).
Approaching them with this mindset can be very liberating!</p>
<p>To put it differently, <strong>type classes can be used to create abstractions</strong> -
interfaces with laws/expected behaviours where we don't actually care about the
concrete details of the underlying type, just that it <em>implements a certain
API and behaves in a certain way</em>.</p>
<p>Regarding <code>Semigroup</code>, we have <a href="04-markup/../03-html/04-safer_construction.html#appending-htmlstructure">previously</a>
created a function that looks like <code>&lt;&gt;</code> for our <code>Html</code> EDSL!
We can add a <code>Semigroup</code> instance for our <code>Structure</code> data type
and have a nicer API!</p>
<hr />
<p>Exercise: Please do this and remove the <code>append_</code> function from the API.</p>
<details>
  <summary>Solution</summary>
<p>Replace this:</p>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>With this:</p>
<pre><code class="language-hs">instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)
</code></pre>
<p>And remove the export of <code>append_</code> in <code>Html.hs</code>. You won't need to further export anything
as type class instances are exported automatically.</p>
<p>You will also need to replace the usage of <code>append_</code> with <code>&lt;&gt;</code> in <code>hello.hs</code>.</p>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="parsing-markup-part-02-pattern-matching"><a class="header" href="#parsing-markup-part-02-pattern-matching">Parsing markup part 02 (Pattern matching)</a></h1>
<h2 id="maybe"><a class="header" href="#maybe">Maybe</a></h2>
<p>Previously on partial functions, we mentioned that one way to avoid
writing partial functions is to encode the absence of a result using <code>Maybe</code>:</p>
<pre><code class="language-hs">data Maybe a
  = Nothing
  | Just a
</code></pre>
<p><code>Maybe</code> is a data type from the standard library (named <a href="https://hackage.haskell.org/package/base">base</a>)
for adding an additional value to a type: the absence of a value.
For example, <code>Maybe Bool</code> has three values,
two with the <code>Just</code> constructor to represent regular boolean values
(<code>Just True</code> and <code>Just False</code>) and another value, <code>Nothing</code> to represent
the absence of a boolean value.</p>
<p>We can use this to encode the result of <code>head</code>, a function that promises to return
the first element of a list, without creating a partial function:</p>
<pre><code class="language-hs">safeHead :: [a] -&gt; Maybe a
</code></pre>
<p>This way, when the list is empty, we can return <code>Nothing</code>, and when it has at least
one element, we can return <code>Just &lt;first element&gt;</code>. This function can be found in
the <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html">Data.Maybe</a>
module under the name
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Maybe.html#v:listToMaybe">listToMaybe</a>.</p>
<p>In order to <em>consume</em> values of type <code>Maybe &lt;something&gt;</code>, and other types created with
<code>data</code>, we can use pattern matching.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>We've already seen pattern matching a few times.
It is an incredibly versatile feature of Haskell; we can use it to do two main things:</p>
<ol>
<li>Deconstruct complex values</li>
<li>Control flow</li>
</ol>
<p>As we've seen when discussing
<a href="04-markup/../03-html/04-safer_construction.html#using-newtypes">newtypes</a>,
we can use <strong>case expressions</strong> and <strong>function definitions</strong> to deconstruct a <code>newtype</code>.
Same for <code>data</code> types as well:</p>
<pre><code class="language-hs">import Data.Word (Word8) -- Word8 is an 8-bit unsigned integer type

-- | A data type representing colors
data Color
  = RGB Word8 Word8 Word8

getBluePart :: Color -&gt; Word8
getBluePart color =
  case color of
    RGB _ _ blue -&gt; blue
</code></pre>
<p>In <code>getBluePart</code> we deconstruct a composite value into its part and extract the third component
representing the blue value in a color represented by red, green, and blue components (RGB).</p>
<p>Note that <code>blue</code> is the name we give to the third component, so it will be bound
to the right of the arrow that comes after the pattern. This is similar to
a function argument. Also, note that <code>_</code> matches any value <em>without</em> binding it to a name.</p>
<p>We can also try to match a value with more than one pattern:</p>
<pre><code class="language-hs">data Brightness
  = Dark
  | Bright

data EightColor
  = Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White

data AnsiColor
  = AnsiColor Brightness EightColor

ansiColorToVGA :: AnsiColor -&gt; Color
ansiColorToVGA ansicolor =
  case ansicolor of
    AnsiColor Dark Black -&gt;
      RGB 0 0 0
    AnsiColor Bright Black -&gt;
      RGB 85 85 85
    AnsiColor Dark Red -&gt;
      RGB 170 0 0
    AnsiColor Bright Red -&gt;
      RGB 255 85 85
    -- and so on
</code></pre>
<p>It's important to notice a few things here:</p>
<ol>
<li>Patterns can be nested; notice how we deconstructed <code>ansicolor</code> on multiple levels</li>
<li>We try to match patterns from the top down; it is possible for patterns to overlap with one another, and the top one will win</li>
<li>If the value we try to match does not match any of the patterns listed, an error will be thrown at runtime</li>
</ol>
<p>We can ask GHC to notify us when we accidentally write overlapping patterns,
or when we haven't listed enough patterns to match all possible values,
by passing the flag <code>-Wall</code> to <code>ghc</code> or <code>runghc</code>.</p>
<p><strong>My recommendation is to always use <code>-Wall</code></strong>!</p>
<blockquote>
<p>As an aside, while it is possible to use pattern matching in function definitions by defining a function
multiple times, <a href="https://fosstodon.org/@suppi/110360105149103689">I personally don't like that feature very much</a>
and I would encourage you to avoid it,
but if you want to use it instead of case expressions, it is possible.</p>
</blockquote>
<h3 id="pattern-matching-on-linked-lists"><a class="header" href="#pattern-matching-on-linked-lists">Pattern matching on linked lists</a></h3>
<p>Because linked lists have their own <a href="04-markup//03-html/06-escaping_characters.html#linked-lists-briefly">special syntax</a>,
we also have special syntax for their pattern match.
We can use the same special syntax for creating lists when we pattern match on lists,
replacing the <em>elements</em> of the list with patterns. For example:</p>
<pre><code class="language-hs">safeHead :: [a] -&gt; Maybe a
safeHead list =
  case list of
    -- Empty list
    [] -&gt; Nothing

    -- Cons cell pattern, will match any list with at least one element
	x : _ -&gt; Just x
</code></pre>
<pre><code class="language-hs">exactlyTwo :: [a] -&gt; Maybe (a, a)
exactlyTwo list =
  case list of
    -- Will match a list with exactly two elements
	[x, y] -&gt; Just (x, y)

    -- Will match any other pattern
	_ -&gt; Nothing
</code></pre>
<pre><code class="language-hs">-- This will also work
exactlyTwoVersion2 :: [a] -&gt; Maybe (a, a)
exactlyTwoVersion2 list =
  case list of
    -- Will match a list with exactly two elements
	x : y : [] -&gt; Just (x, y)

    -- Will match any other pattern
	_ -&gt; Nothing
</code></pre>
<hr />
<p>Exercises:</p>
<ol>
<li>Create a function <code>isBright :: AnsiColor -&gt; Bool</code> that checks whether a color is bright</li>
<li>Use <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#3-bit_and_4-bit">this table</a> to write <code>ansiToUbuntu</code></li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that uses <code>listToMaybe</code> to check whether a list is empty</li>
<li>Create a function <code>isEmpty :: [a] -&gt; Bool</code> that <em>doesn't</em> use <code>listToMaybe</code> to check whether a list is empty</li>
</ol>
<p>Solutions:</p>
<details><summary>Solution for (1)</summary>
<pre><code class="language-hs">isBright :: AnsiColor -&gt; Bool
isBright ansiColor =
  case ansiColor of
    AnsiColor Bright _ -&gt; True
    AnsiColor Dark _ -&gt; False
</code></pre>
</details>
<details><summary>Solution for (2)</summary>
<pre><code class="language-hs">ansiToUbuntu :: AnsiColor -&gt; Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor brightness color -&gt;
      case brightness of
        Dark -&gt;
          case color of
            Black -&gt; RGB 1 1 1
            Red -&gt; RGB 22 56 43
            Green -&gt; RGB 57 181 74
            Yellow -&gt; RGB 255 199 6
            Blue -&gt; RGB 0 111 184
            Magenta -&gt; RGB 118 38 113
            Cyan -&gt; RGB 44 181 233
            White -&gt; RGB 204 204 204

        Bright -&gt;
          case color of
            Black -&gt; RGB 128 128 128
            Red -&gt; RGB 255 0 0
            Green -&gt; RGB 0 255 0
            Yellow -&gt; RGB 255 255 0
            Blue -&gt; RGB 0 0 255
            Magenta -&gt; RGB 255 0 255
            Cyan -&gt; RGB 0 255 255
            White -&gt; RGB 255 255 255
</code></pre>
<p>Since pattern matching goes arbitrarily deep, as we saw before, we could instead
pattern match all the way through in one case expression:</p>
<pre><code class="language-hs">ansiToUbuntu :: AnsiColor -&gt; Color
ansiToUbuntu ansiColor =
  case ansiColor of
    AnsiColor Dark Black -&gt; RGB 1 1 1
    AnsiColor Dark Red -&gt; RGB 22 56 43
    AnsiColor Dark Green -&gt; RGB 57 181 74
    AnsiColor Dark Yellow -&gt; RGB 255 199 6
    AnsiColor Dark Blue -&gt; RGB 0 111 184
    AnsiColor Dark Magenta -&gt; RGB 118 38 113
    AnsiColor Dark Cyan -&gt; RGB 44 181 233
    AnsiColor Dark White -&gt; RGB 204 204 204
    AnsiColor Bright Black -&gt; RGB 128 128 128
    AnsiColor Bright Red -&gt; RGB 255 0 0
    AnsiColor Bright Green -&gt; RGB 0 255 0
    AnsiColor Bright Yellow -&gt; RGB 255 255 0
    AnsiColor Bright Blue -&gt; RGB 0 0 255
    AnsiColor Bright Magenta -&gt; RGB 255 0 255
    AnsiColor Bright Cyan -&gt; RGB 0 255 255
    AnsiColor Bright White -&gt; RGB 255 255 255
</code></pre>
<p>But this is a bit too much repetition of <code>AnsiColor</code>, <code>Dark</code>, and <code>Bright</code>
to my taste in this case.</p>
</details>
<details><summary>Solution for (3)</summary>
<pre><code class="language-hs">isEmpty :: [a] -&gt; Bool
isEmpty list =
  case listToMaybe list of
    Nothing -&gt; True
    Just _ -&gt; False
</code></pre>
</details>
<details><summary>Solution for (4)</summary>
<pre><code class="language-hs">isEmpty :: [a] -&gt; Bool
isEmpty list =
  case list of
    [] -&gt; True
    _ : _ -&gt; False
</code></pre>
</details>
<hr />
<h2 id="parsing-with-rich-context"><a class="header" href="#parsing-with-rich-context">Parsing with rich context</a></h2>
<p>Previously we wrote a parser that separates documents into different paragraphs.
With new features under our belt, we can now remember the exact context we are in
(whether it is a text paragraph, a list, or a code block) and act accordingly!</p>
<p>Let's look again at the parsing code we wrote previously:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
  let
    paragraph = Paragraph (unlines (reverse currentParagraph))
  in
    case txts of
      [] -&gt; [paragraph]
      currentLine : rest -&gt;
        if trim currentLine == &quot;&quot;
          then
            paragraph : parseLines [] rest
          else
            parseLines (currentLine : currentParagraph) rest

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Previously our context, <code>currentParagraph</code>, was used to group adjacent lines in an accumulative list.</p>
<p>Next, instead of using a <code>[String]</code> type to denote adjacent lines, we can instead use a <code>Structure</code> to denote the context.</p>
<p>One issue we might have, though, with representing context with the <code>Structure</code> type,
is that when we start parsing, we don't have any context.
But we have learned of a way to represent the absence of a value with <code>Maybe</code>! So our new context type can be <code>Maybe Structure</code> instead.</p>
<p>Let's rewrite our code above with our new context type:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines -- (1)

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    [] -&gt; maybeToList context -- (2)
    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest) -- (3)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest -- (4)
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<ol>
<li>
<p>We can now pass <code>Nothing</code> when we don't have a context</p>
</li>
<li>
<p>Unsure what <code>maybeToList</code> does? <a href="https://hoogle.haskell.org">Hoogle</a> it!</p>
</li>
<li>
<p>We can split this line into two important parts:</p>
<ol>
<li><code>maybe id (:) context</code> - prepending the context to the rest of the document</li>
<li><code>parseLines Nothing rest</code> - parsing the rest of the document</li>
</ol>
<p>Let's focus on the first part.
We want to prepend <code>context</code> to the rest of the document, but we can't write
<code>context : parseLines Nothing rest</code> because <code>context</code> has the type <code>Maybe Structure</code>
and not <code>Structure</code>, meaning that we <em>might</em> have a <code>Structure</code> but maybe not.
If we do have a <code>Structure</code> to prepend, we wish to prepend it. If not, we want to return
the result of <code>parseLines Nothing rest</code> as is. Try writing this using pattern matching!</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">case context of
  Nothing -&gt; parseLines Nothing rest
  Just structure -&gt; structure : parseLines Nothing rest
</code></pre>
</details>
<p>The <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#v:maybe">maybe</a>
function lets us do the same thing more compactly. It is a function
that works similarly to pattern matching on a <code>Maybe</code>:
the third argument to <code>maybe</code> is the value on which we pattern match,
the second argument is a function to apply to the value found in a <code>Just</code> case,
and the first argument is the value to return in case the value
we pattern match on is <code>Nothing</code>. A more faithful translation of
<code>maybe id (:) context (parseLines Nothing rest)</code>
to pattern matching would look like this:</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">( case context of
    Nothing -&gt; id
    Just structure -&gt; (:) structure
) (parseLines Nothing rest)
</code></pre>
<p>Note how the result of this case expression is a function of type <code>Document -&gt; Document</code>,
how we partially apply <code>(:)</code> with <code>structure</code> to create a function that prepends <code>structure</code>,
and how we apply <code>parseLines Nothing rest</code> to the case expression.</p>
</details>
<p>This way of encoding pattern matching using functions is fairly common.</p>
<p>Check out the types of <code>id</code>, <code>(:)</code>, and <code>maybe id (:)</code> in GHCi!</p>
</li>
<li>
<p>Hey! Didn't we say that appending <code>String</code>s/lists is slow (which is what <code>unwords</code> does)? Yes, it is.
Because in our <code>Structure</code> data type, a paragraph is defined as <code>Paragraph String</code> and not <code>Paragraph [String]</code>,
we can't use our trick of building a list of lines and then reverse it in the end.</p>
<p>So what do we do?
There are many ways to handle that; one simple way is to create a different type with the right shape:</p>
<pre><code class="language-hs">data Context
  = CtxHeading Natural String
  | CtxParagraph [String]
  | CtxUnorderedList [String]
  | CtxOrderedList [String]
  | CtxCodeBlock [String]
</code></pre>
<p>Since creating new types in Haskell is cheap, this is a very viable solution.</p>
<p>In this case, I'm going with the approach of not worrying about it too much,
because it's a very local piece of code that can easily be fixed later if needed.</p>
</li>
</ol>
<p>Let's cover more parsing cases; we want to handle headings and lists as well.
We can do that by examining the first characters of a line:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context

    -- Heading 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<hr />
<p>Exercise: Add the <code>CodeBlock</code> and <code>OrderedList</code> cases.</p>
<details>
  <summary>Final module</summary>
<pre><code class="language-hs">-- Markup.hs

module Markup
  ( Document
  , Structure(..)
  , parse
  )
where

import Numeric.Natural
import Data.Maybe (maybeToList)

type Document
  = [Structure]

data Structure
  = Heading Natural String
  | Paragraph String
  | UnorderedList [String]
  | OrderedList [String]
  | CodeBlock [String]
  deriving (Eq, Show)    -- (1)


parse :: String -&gt; Document
parse = parseLines Nothing . lines

parseLines :: Maybe Structure -&gt; [String] -&gt; Document
parseLines context txts =
  case txts of
    -- done case
    [] -&gt; maybeToList context

    -- Heading 1 case
    ('*' : ' ' : line) : rest -&gt;
      maybe id (:) context (Heading 1 (trim line) : parseLines Nothing rest)

    -- Unordered list case
    ('-' : ' ' : line) : rest -&gt;
      case context of
        Just (UnorderedList list) -&gt;
          parseLines (Just (UnorderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (UnorderedList [trim line])) rest)

    -- Ordered list case
    ('#' : ' ' : line) : rest -&gt;
      case context of
        Just (OrderedList list) -&gt;
          parseLines (Just (OrderedList (list &lt;&gt; [trim line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (OrderedList [trim line])) rest)

    -- Code block case
    ('&gt;' : ' ' : line) : rest -&gt;
      case context of
        Just (CodeBlock code) -&gt;
          parseLines (Just (CodeBlock (code &lt;&gt; [line]))) rest

        _ -&gt;
          maybe id (:) context (parseLines (Just (CodeBlock [line])) rest)

    -- Paragraph case
    currentLine : rest -&gt;
      let
        line = trim currentLine
      in
        if line == &quot;&quot;
          then
            maybe id (:) context (parseLines Nothing rest)
          else
            case context of
              Just (Paragraph paragraph) -&gt;
                parseLines (Just (Paragraph (unwords [paragraph, line]))) rest
              _ -&gt;
                maybe id (:) context (parseLines (Just (Paragraph line)) rest)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
</details>
<hr />
<h3 id="how-do-we-know-our-parser-works-correctly"><a class="header" href="#how-do-we-know-our-parser-works-correctly">How do we know our parser works correctly?</a></h3>
<p>In an earlier chapter, we parsed a few examples of our markup language <a href="04-markup/01-data_type.html#exercises">by hand</a>.
Now, we can try to test our parser by comparing our solutions to our parser.
By deriving <code>Eq</code> for our <code>Structure</code> data type
(marked with (1) in &quot;final module&quot; above),
we can compare solutions with the <code>==</code> (equals) operator.</p>
<p>Try it in GHCi! You can read a text file in GHCi using the following syntax:</p>
<pre><code class="language-hs">ghci&gt; txt &lt;- readFile &quot;/tmp/sample.txt&quot;
</code></pre>
<p>And then compare with the handwritten example values from the solutions
(after adding them to the module and loading them in GHCi):</p>
<pre><code class="language-hs">ghci&gt; parse txt == example4
</code></pre>
<p>In a later chapter, we'll write automated tests for our parser using a testing framework.
But before that, I'd like to glue things together
so we'll be able to:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text</li>
<li>Convert the result to our HTML EDSL</li>
<li>Generate HTML code</li>
</ol>
<p>And also discuss how to work with IO in Haskell while we're at it.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/9f951a05d4f78cf59190ee4f3cd8de85e1c33bd1">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gluing-things-together"><a class="header" href="#gluing-things-together">Gluing things together</a></h1>
<p>In this chapter, we are going to glue the pieces we built together
and build an actual blog generator. We will:</p>
<ol>
<li>Read markup text from a file</li>
<li>Parse the text to a <code>Document</code></li>
<li>Convert the result to our <code>Html</code> EDSL</li>
<li>Generate HTML code</li>
<li>Write it to a file</li>
</ol>
<p>While doing so, we will learn:</p>
<ul>
<li>How to work with IO</li>
<li>How to import external libraries to process whole directories and create a simple command-line interface</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-markup-to-html"><a class="header" href="#converting-markup-to-html">Converting Markup to HTML</a></h1>
<p>One key part is missing before we can glue everything together, and that is
to convert our <code>Markup</code> data types to <code>Html</code>.</p>
<p>We'll start by creating a new module and importing both the <code>Markup</code> and the <code>Html</code> modules.</p>
<pre><code class="language-hs">module Convert where

import qualified Markup
import qualified Html
</code></pre>
<h2 id="qualified-imports"><a class="header" href="#qualified-imports">Qualified Imports</a></h2>
<p>This time, we've imported the modules qualified. Qualified imports mean that
instead of exposing the names that we've defined in the imported module to
the general module namespace, they now have to be prefixed with the module name.</p>
<p>For example, <code>parse</code> becomes <code>Markup.parse</code>.
If we would've imported <code>Html.Internal</code> qualified, we'd have to write
<code>Html.Internal.el</code>, which is a bit long.</p>
<p>We can also give the module a new name with the <code>as</code> keyword:</p>
<pre><code class="language-hs">import qualified Html.Internal as HI
</code></pre>
<p>And write <code>HI.el</code> instead.</p>
<p>I like using qualified imports because readers do not have to guess where a
name comes from. Some modules are even designed to be imported qualified.
For example, the APIs of many container types, such as maps, sets, and vectors, are very similar.
If we want to use multiple containers in a single module, we pretty much have
to use qualified imports so that when we write a function such as <code>singleton</code>,
which creates a container with a single value, GHC will know which <code>singleton</code>
function we are referring to.</p>
<p>Some people prefer to use import lists instead of qualified imports,
because qualified names can be a bit verbose and noisy.
I will often prefer qualified imports to import lists, but feel free to
try both solutions and see which fits you better.
For more information about imports,
see this <a href="https://wiki.haskell.org/Import">wiki article</a>.</p>
<h2 id="converting-markupstructure-to-htmlstructure"><a class="header" href="#converting-markupstructure-to-htmlstructure">Converting <code>Markup.Structure</code> to <code>Html.Structure</code></a></h2>
<p>Converting a markup structure to an HTML structure is mostly straightforward
at this point, we need to pattern match on the markup structure and use
the relevant HTML API.</p>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading 1 txt -&gt;
      Html.h1_ txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<p>Notice that running this code with <code>-Wall</code> will reveal that the pattern matching
is <em>non-exhaustive</em>. This is because we don't currently have a way to build
headings that are not <code>h1</code>. There are a few ways to handle this:</p>
<ul>
<li>Ignore the warning - this will likely fail at runtime one day, and the user will be sad</li>
<li>Pattern match other cases and add a nice error with the <code>error</code> function - it has
the same disadvantage above, but will also no longer notify of the unhandled
cases at compile time</li>
<li>Pattern match and do the wrong thing - user is still sad</li>
<li>Encode errors in the type system using <code>Either</code>, we'll see how to do this in later
chapters</li>
<li>Restrict the input - change <code>Markup.Heading</code> to not include a number but rather
specific supported headings. This is a reasonable approach</li>
<li>Implement an HTML function supporting arbitrary headings. Should be straightforward
to do</li>
</ul>
<blockquote>
<h4 id="what-are-these-"><a class="header" href="#what-are-these-">What are these <code>$</code>?</a></h4>
<p>The dollar sign (<code>$</code>) is an operator that we can use to group expressions, like we do with parenthesis.
we can replace the <code>$</code> with invisible parenthesis around the expressions to the left of it,
and around the expression to the right of it. So that:</p>
<pre><code class="language-hs">Html.ul_ $ map Html.p_ list
</code></pre>
<p>is understood as:</p>
<pre><code class="language-hs">(Html.ul_) (map Html.p_ list)
</code></pre>
<p>It is a function application operator, it applies the argument on the right of the dollar
to the function on the left of the dollar.</p>
<p><code>$</code> is right-associative and has very low precedence, which means that:
it groups to the right, and other operators bind more tightly.
For example the following expression:</p>
<pre><code class="language-hs">filter (2&lt;) $ map abs $ [-1, -2, -3] &lt;&gt; [4, 5, 6]
</code></pre>
<p>is understood as:</p>
<pre><code class="language-hs">(filter (2&lt;) ((map abs) ([1, -2, 3] &lt;&gt; [-4, 5, 6]))
</code></pre>
<p>Which is also equivalent to the following code with less parenthesis:</p>
<pre><code class="language-hs">filter (2&lt;) (map abs ([1, -2, 3] &lt;&gt; [-4, 5, 6]))
</code></pre>
<p>See how information flows from right to left and that <code>&lt;&gt;</code> binds more tightly?</p>
<p>This operator is fairly common in Haskell code and it helps us reduce some clutter,
but feel free to avoid it in favor of parenthesis if you'd like, it's not
like we're even saving keystrokes with <code>$</code>!</p>
</blockquote>
<hr />
<p>Exercise: Implement <code>h_ :: Natural -&gt; String -&gt; Structure</code>
which we'll use to define arbitrary headings (such as <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, and so on).</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">import Numeric.Natural

h_ :: Natural -&gt; String -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . escape
</code></pre>
<p>Don't forget to export it from <code>Html.hs</code>!</p>
</details>
<p>Exercise: Fix <code>convertStructure</code> using <code>h_</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
<hr />
<h2 id="document---html"><a class="header" href="#document---html">Document -&gt; Html</a></h2>
<p>To create an <code>Html</code> document, we need to use the <code>html_</code> function.
This function expects two things: a <code>Title</code> and a <code>Structure</code>.</p>
<p>For a title, we could just supply it from outside using the file name.</p>
<p>To convert our markup <code>Document</code> (which is a list of markup <code>Structure</code>)
to an HTML <code>Structure</code>, we need to convert each markup <code>Structure</code> and then
concatenate them together.</p>
<p>We already know how to convert each markup <code>Structure</code>; we can use the
<code>convertStructure</code> function we wrote and <code>map</code>. This will provide
us with the following function:</p>
<pre><code>map convertStructure :: Markup.Document -&gt; [Html.Structure]
</code></pre>
<p>To concatenate all of the <code>Html.Structure</code>, we could try to write a recursive
function. However, we will quickly run into an issue
with the base case: what to do when the list is empty?</p>
<p>We could just provide a dummy <code>Html.Structure</code> that represents an empty
HTML structure.</p>
<p>Let's add this to <code>Html.Internal</code>:</p>
<pre><code class="language-hs">empty_ :: Structure
empty_ = Structure &quot;&quot;
</code></pre>
<hr />
<p>Now we can write our recursive function. Try it!</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">concatStructure :: [Structure] -&gt; Structure
concatStructure list =
  case list of
    [] -&gt; empty_
    x : xs -&gt; x &lt;&gt; concatStructure xs
</code></pre>
</details>
<hr />
<p>Remember the <code>&lt;&gt;</code> function we implemented as an instance of the <code>Semigroup</code>
type class? We mentioned that <code>Semigroup</code> is an <strong>abstraction</strong> for things
that implements <code>(&lt;&gt;) :: a -&gt; a -&gt; a</code>, where  <code>&lt;&gt;</code> is associative
(<code>a &lt;&gt; (b &lt;&gt; c) = (a &lt;&gt; b) &lt;&gt; c</code>).</p>
<p>It turns out that having an instance of <code>Semigroup</code> and also having a value that represents
an &quot;empty&quot; value is a fairly common pattern. For example, a string can be concatenated,
and the empty string can serve as an &quot;empty&quot; value.
And this is actually a well known <strong>abstraction</strong> called <strong>monoid</strong>.</p>
<h2 id="monoids"><a class="header" href="#monoids">Monoids</a></h2>
<p>Actually, &quot;empty&quot; isn't a very good description of what we want,
and isn't very useful as an abstraction. Instead, we can describe it as
an &quot;identity&quot; element that satisfies the following laws:</p>
<ul>
<li><code>x &lt;&gt; &lt;identity&gt; = x</code></li>
<li><code>&lt;identity&gt; &lt;&gt; x = x</code></li>
</ul>
<p>In other words, if we try to use this &quot;empty&quot; - this identity value,
as one argument to <code>&lt;&gt;</code>, we will always get the other argument back.</p>
<p>For <code>String</code>, the empty string, <code>&quot;&quot;</code>, satisfies this:</p>
<pre><code class="language-hs">&quot;&quot; &lt;&gt; &quot;world&quot; = &quot;world&quot;
&quot;hello&quot; &lt;&gt; &quot;&quot; = &quot;hello&quot;
</code></pre>
<p>This is, of course, true for any value we'd write and not just &quot;world&quot; and &quot;hello&quot;.</p>
<p>Actually, if we move out of the Haskell world for a second, even integers
with <code>+</code> as the associative binary operations <code>+</code> (in place of <code>&lt;&gt;</code>)
and <code>0</code> in place of the identity member form a monoid:</p>
<pre><code class="language-hs">17 + 0 = 17
0 + 99 = 99
</code></pre>
<p>So integers together with the <code>+</code> operation form a semigroup, and
together with <code>0</code> form a monoid.</p>
<p>We learn new things from this:</p>
<ol>
<li>A monoid is a more specific abstraction over semigroup; it builds on it
by adding a new condition (the existence of an identity member)</li>
<li>This abstraction can be useful! We can write a general <code>concatStructure</code>
that could work for any monoid</li>
</ol>
<p>And indeed, there exists a type class in <code>base</code> called <code>Monoid</code>, which has
<code>Semigroup</code> as a <strong>super class</strong>.</p>
<pre><code class="language-hs">class Semigroup a =&gt; Monoid a where
  mempty :: a
</code></pre>
<blockquote>
<p>Note: this is a simplified version. The
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Prelude.html#t:Monoid">actual</a>
is a bit more complicated because of backward compatibility and performance reasons.
<code>Semigroup</code> was actually introduced in Haskell after <code>Monoid</code>!</p>
</blockquote>
<p>We could add an instance of <code>Monoid</code> for our HTML <code>Structure</code> data type:</p>
<pre><code class="language-hs">instance Monoid Structure where
  mempty = empty_
</code></pre>
<p>And now, instead of using our own <code>concatStructure</code>, we can use the library function:</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
</code></pre>
<p>Which could theoretically be implemented as:</p>
<pre><code class="language-hs">mconcat :: Monoid a =&gt; [a] -&gt; a
mconcat list =
  case list of
    [] -&gt; mempty
    x : xs -&gt; x &lt;&gt; mconcat xs
</code></pre>
<p>Notice that because <code>Semigroup</code> is a <em>super class</em> of <code>Monoid</code>,
we can still use the <code>&lt;&gt;</code> function from the <code>Semigroup</code> class
without adding the <code>Semigroup a</code> constraint to the left side of <code>=&gt;</code>.
By adding the <code>Monoid a</code> constraint, we implicitly add a <code>Semigroup a</code>
constraint as well!</p>
<p>This <code>mconcat</code> function is very similar to the <code>concatStructure</code> function,
but this one works for any <code>Monoid</code>, including <code>Structure</code>!
Abstractions help us identify common patterns and <strong>reuse</strong> code!</p>
<blockquote>
<p>Side note: integers with <code>+</code> and <code>0</code> aren't actually an instance of <code>Monoid</code> in Haskell.
This is because integers can also form a monoid with <code>*</code> and <code>1</code>! But <strong>there can only
be one instance per type</strong>. Instead, two other <code>newtype</code>s exist that provide that
functionality, <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Monoid.html#t:Sum">Sum</a>
and <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Monoid.html#t:Product">Product</a>.
See how they can be used in <code>ghci</code>:</p>
<pre><code class="language-hs">ghci&gt; import Data.Monoid
ghci&gt; Product 2 &lt;&gt; Product 3 -- note, Product is a data constructor
Product {getProduct = 6}
ghci&gt; getProduct (Product 2 &lt;&gt; Product 3)
6
ghci&gt; getProduct $ mconcat $ map Product [1..5]
120
</code></pre>
</blockquote>
<h2 id="another-abstraction"><a class="header" href="#another-abstraction">Another abstraction?</a></h2>
<p>We've used <code>map</code> and then <code>mconcat</code> twice now. Surely there has to be a function
that unifies this pattern. And indeed, it is called
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Foldable.html#v:foldMap"><code>foldMap</code></a>,
and it works not only for lists but also for any data structure that can be &quot;folded&quot;,
or &quot;reduced&quot;, into a summary value. This abstraction and type class is called <strong>Foldable</strong>.</p>
<p>For a simpler understanding of <code>Foldable</code>, we can look at <code>fold</code>:</p>
<pre><code class="language-hs">fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m

-- compare with
mconcat :: Monoid m            =&gt; [m] -&gt; m
</code></pre>
<p><code>mconcat</code> is just a specialized version of <code>fold</code> for lists.
And <code>fold</code> can be used for any pair of a data structure that implements
<code>Foldable</code> and a payload type that implements <code>Monoid</code>. This
could be <code>[]</code> with <code>Structure</code>, or <code>Maybe</code> with <code>Product Int</code>, or
your new shiny binary tree with <code>String</code> as the payload type. But note that
the <code>Foldable</code> type must be of <em>kind</em> <code>* -&gt; *</code>. So, for example <code>Html</code>
cannot be a <code>Foldable</code>.</p>
<p><code>foldMap</code> is a function that allows us to apply a function to the
payload type of the <code>Foldable</code> type right before combining them
with the <code>&lt;&gt;</code> function.</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m

-- compare to a specialized version with:
-- - t ~ []
-- - m ~ Html.Structure
-- - a ~ Markup.Structure
foldMap
  :: (Markup.Structure -&gt; Html.Structure)
  -&gt; [Markup.Structure]
  -&gt; Html.Structure
</code></pre>
<p>True to its name, it really &quot;maps&quot; before it &quot;folds&quot;. You might pause here
and think, &quot;this 'map' we are talking about isn't specific for lists; maybe
that's another abstraction?&quot; Yes. It is actually a very important and
fundamental abstraction called <code>Functor</code>.
But I think we had enough abstractions for this chapter.
We'll cover it in a later chapter!</p>
<h2 id="finishing-our-conversion-module"><a class="header" href="#finishing-our-conversion-module">Finishing our conversion module</a></h2>
<p>Let's finish our code by writing <code>convert</code>:</p>
<pre><code class="language-hs">convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure
</code></pre>
<p>Now we have a full implementation and can convert markup documents
to HTML:</p>
<pre><code class="language-hs">-- Convert.hs
module Convert where

import qualified Markup
import qualified Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n txt

    Markup.Paragraph p -&gt;
      Html.p_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map Html.p_ list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map Html.p_ list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>We learned about:</p>
<ul>
<li>Qualified imports</li>
<li>Ways to handle errors</li>
<li>The <code>Monoid</code> type class and abstraction</li>
<li>The <code>Foldable</code> type class and abstraction</li>
</ul>
<p>Next, we are going to glue our functionality together and learn about
I/O in Haskell!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/ad34f2264e9114f2d7436ff472c78da47055fcfe">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/ad34f2264e9114f2d7436ff472c78da47055fcfe">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-io"><a class="header" href="#working-with-io">Working with IO</a></h1>
<p>In previous chapters, we were able to build a parser from a text
string to a Haskell representation of our markup language,
and we built an EDSL for easy writing of HTML code.
However, our program is still not useful to other users because
we did not make this functionality accessible via some sort of
user interface.</p>
<p>In our program, we'd like to take user input and then convert it to HTML.
There are many ways to design this kind of interface, for example:</p>
<ul>
<li>Get text input via the <em>standard input</em> and output HTML
via the <em>standard output</em></li>
<li>Receive two file names as <em>command-line arguments</em>, read the contents
of the first one, and write the output to the second one</li>
<li>Ask for fancier command-line arguments parsing and prefix
the file names with flags indicating what they are</li>
<li>Some fancy GUI interface</li>
<li>Combination of all of the above</li>
</ul>
<p>To make this interesting, we will start with the following interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name, and the second one
will be the output file name</li>
<li>If the output file already exists, we'll ask the user if they want
to overwrite the file</li>
<li>On any other kind of input, we'll print a generic message explaining
the proper usage</li>
</ol>
<p>In a later chapter, we will add a fancier command-line interface
using a library, and also read whole directories in addition to single files.</p>
<p>But first, we need to learn about I/O in Haskell, what makes
it special, and why it's different from other programming languages.</p>
<h2 id="purely-functional"><a class="header" href="#purely-functional">Purely functional</a></h2>
<p>Originally, Haskell was designed as an <em>open standard</em>
functional programming language with <strong>non-strict semantics</strong>, to serve
as a unifying language for future research in functional language design.</p>
<p>In GHC Haskell, we use a <em>lazy evaluation strategy</em> to implement non-strict
semantics (We've talked about laziness
<a href="05-glue/../04-markup/02-parsing_01.html#laziness">before</a>).</p>
<p>The requirement for non-strict semantics raises interesting challenges:
How do we design a language that can do more than just evaluate expressions,
how do we model interaction with the outside world, how do we do I/O?</p>
<p>The challenge with doing I/O operations in a language with a lazy evaluation strategy
is that as programs grow larger, the order of evaluation becomes less trivial to
figure out. Consider this hypothetical code example
(which won't actually type-check in Haskell, we'll see why soon):</p>
<pre><code class="language-hs">addWithInput :: Int -&gt; Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
</code></pre>
<p>This hypothetical program will read 2 integers from the standard input,
and then will subtract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language,
we expect the order of operations to happen from the top down.</p>
<p>But in a lazy language, we don't evaluate an expression until
it is needed, and so neither <code>result1</code> nor <code>result2</code> are evaluated
until we wish to print the result of subtracting one from the other.
And then, when we try to evaluate <code>-</code>, it evaluates the two arguments
from left to right, so we first evaluate <code>result2</code>.</p>
<p>Evaluating <code>result2</code> with substitution means replacing occurrences of <code>n</code>
with the input <code>2</code>, and then evaluate the top-level function (<code>+</code>), which is a
primitive function. We then evaluate its arguments, <code>readIntFromStdin</code>
and then <code>n</code>; at this point <em>we are reading the first integer from the stdin</em>.</p>
<p>After calculating the result, we can move to evaluate <code>result1</code>, which
<em>will read the second integer from stdin</em>. This is the
complete opposite of what we wanted!</p>
<p>Issues like these make lazy evaluation hard to work within the presence of
<strong>side effects</strong> - when the evaluation of an expression <em>can affect or be affected
by the outside world</em>, this includes reading/writing from mutable memory
or performing I/O operations.</p>
<p>We call functions that have side-effects, such as <code>addWithInput</code>, <strong>impure functions</strong>.
And an unfortunate consequence of impure functions is that
<strong>they can return different results even when they take the same input</strong>.</p>
<p>The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use <strong>equational reasoning</strong> to understand programs.</p>
<p>Therefore, in Haskell, it was decided to only allow <strong>pure</strong> functions and expressions - ones that
have <strong>no side effects</strong>. Pure functions will <em>always</em> return the same output (given the same input)
and <strong>evaluating pure expressions is deterministic</strong>.</p>
<p>But now, how can we do I/O operations? There are many possible solutions.</p>
<p>For Haskell, it was decided to design an interface
with an accompanied type called <code>IO</code>. <code>IO</code>'s interface will force a distinction
from non-I/O expressions and will also require that in order to <em>combine</em>
multiple <code>IO</code> operations, we will have to <strong>specify the order of the operations</strong>.</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p><code>IO</code> is an opaque type, like our <code>Html</code> type, in which we hide its internal
representation from the user behind an interface. But in this case, <code>IO</code> is a
built-in type and its internals are hidden by the Haskell language rather than a module.</p>
<p>Similar to <code>Maybe</code>, <code>IO</code> has a payload type that represents the
result of an <code>IO</code> operation.
When there isn't a meaningful result, we use the unit type,
<code>()</code> (which only has one value: <code>()</code>) to represent that.</p>
<p>Here are a few <code>IO</code> operations and functions that return <code>IO</code> operations:</p>
<pre><code class="language-hs">putStrLn :: String -&gt; IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -&gt; IO (Maybe String)

writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html) module,
which is shipped with `base`. -->
<p>Notice that each function returns an <code>IO &lt;something&gt;</code>, but what does that mean?</p>
<p>The meaning behind <code>IO a</code> is that it is a <em>description of a program (or subroutine)
that, when executed, will produce some value of type <code>a</code>, and may do some I/O effects
during execution</em>.</p>
<p>Executing an <code>IO a</code> is different from evaluating it.
Evaluating an <code>IO a</code> expression is pure - the <strong>evaluation</strong> will always reduce to
the same <strong>description</strong> of a program. This helps us keep purity and equational reasoning!</p>
<p>The Haskell runtime will <em>execute</em> the entry point to the program
(the expression <code>main</code> that must have the type <code>IO ()</code>). For our IO operation
to also run - it has to be <em>combined into</em> the <code>main</code> expression - let's see what that means.</p>
<h2 id="combining-io-expressions"><a class="header" href="#combining-io-expressions">Combining IO expressions</a></h2>
<p>Like our <code>Html.Structure</code> type, the IO interface provides <strong>combinators</strong> for composing
small <code>IO</code> operations into bigger ones. This interface also ensures that the order
of operations is well-defined!</p>
<p>Note that, just like the <code>&lt;&gt;</code> we've defined for <code>Html.Structure</code>, the combinators for <code>IO</code>
are implemented as <strong>type-class instances</strong> rather than specialized variants
(for example our <code>append_</code> function was a specialized version of <code>&lt;&gt;</code> tailored only
for <code>Structure</code>).</p>
<p>In this section, I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.</p>
<h3 id=""><a class="header" href="#">&gt;&gt;=</a></h3>
<p>Our first combinator is <code>&gt;&gt;=</code> (pronounced bind), and is the most useful of the bunch:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>This combinator takes two arguments, the first is an IO operation, and the second is
a function that takes as input <em>the result of the first IO operation</em> and returns
a new <code>IO b</code>, which is the final result.</p>
<p>Here are a few examples using the functions we described above:</p>
<ol>
<li>
<p>Echo</p>
<pre><code>getLine &gt;&gt;= (\line -&gt; putStrLn line)
</code></pre>
<p>We are reading a line from the standard input on the left of <code>&gt;&gt;=</code>,
we receive the input to the right of <code>&gt;&gt;=</code> as an argument to the lambda function,
and then write it to the standard output in the body of the lambda function.
<code>&gt;&gt;=</code>'s role here is to <strong>pass the result of the IO operation
on the left to the function returning an IO operation on the right</strong>.</p>
<p>Notice how <code>&gt;&gt;=</code> <em>defines an order of operations - from left to right</em>.</p>
<p>The type of each sub-expression here is:</p>
<pre><code class="language-hs">getLine :: IO String

putStrLn :: String -&gt; IO ()

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO ()

line :: String
</code></pre>
<ul>
<li>Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details></li>
</ul>
<p>Also, note that this example can be written in a more concise manner
in point-free style <code>getLine &gt;&gt;= putStrLn</code>.</p>
</li>
<li>
<p>Appending two inputs</p>
<pre><code>getLine &gt;&gt;= (\honorific -&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)))
</code></pre>
<p>This subroutine combines multiple operations together; it reads two lines from
the standard input and prints a greeting.
Note that:</p>
<ul>
<li>Using <code>&gt;&gt;=</code> defines the order of operation from left to right</li>
<li>Because of the scoping rules in Haskell, <code>honorific</code> will be in scope
in the body of the function for which it is its input, including the most inner function</li>
</ul>
<p>This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read:</p>
<pre><code>getLine &gt;&gt;= \honorific -&gt;
  getLine &gt;&gt;= \name -&gt;
    putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)
</code></pre>
</li>
</ol>
<p>Let's see a few more combinators!</p>
<h3 id="-and"><a class="header" href="#-and">*&gt; and &gt;&gt;</a></h3>
<pre><code class="language-hs">(*&gt;) :: IO a -&gt; IO b -&gt; IO b
(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b
</code></pre>
<p><code>*&gt;</code> and <code>&gt;&gt;</code> have the same type signature for <code>IO</code> and mean the same thing.
In fact, <code>*&gt;</code> is a slightly more generalized version of <code>&gt;&gt;</code> and can always
be used instead of <code>&gt;&gt;</code>, which only still exists to avoid breaking backward
compatibility.</p>
<p><code>*&gt;</code> for <code>IO</code> means run the first IO operation, discard the result
then run the second operation. It can be implemented using <code>&gt;&gt;=</code>:</p>
<pre><code>a *&gt; b = a &gt;&gt;= \_ -&gt; b
</code></pre>
<p>This combinator is useful when we want to run several <code>IO</code> operations one after
the other that might not return anything meaningful, such as <code>putStrLn</code>:</p>
<pre><code>putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;
</code></pre>
<h3 id="pure-and-return"><a class="header" href="#pure-and-return">pure and return</a></h3>
<pre><code class="language-hs">pure :: a -&gt; IO a
</code></pre>
<p>like <code>*&gt;</code> and <code>&gt;&gt;</code>, <code>pure</code> is a more general version of <code>return</code>. <code>pure</code> also has the
advantage of not having a resemblance to an unrelated keyword in other languages.</p>
<p>Remember that we said <code>IO a</code> is a description of a program
that, when executed, will produce some value of type <code>a</code> and may do some I/O effects
during execution?</p>
<p>With <code>pure</code>, we can build an <code>IO a</code> that does no I/O and will produce a
specific value of type <code>a</code>, the one we supply to <code>pure</code>!</p>
<p>This function is useful when we want to do some uneffectful computation that depends on <code>IO</code>.</p>
<p>For example:</p>
<pre><code class="language-hs">confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt;
          putStrLn &quot;Invalid response. use y or n&quot; *&gt;
            confirm
</code></pre>
<p>Trying to return just <code>True</code> or <code>False</code> here wouldn't work because of the
type of <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>The right side of <code>&gt;&gt;=</code> in our code example (<code>\answer -&gt; case ...</code>) must
be of type <code>String -&gt; IO Bool</code>. This is because:</p>
<ol>
<li><code>getLine :: IO String</code>, so the <code>a</code> in the type signature of <code>&gt;&gt;=</code>
should be the same as <code>String</code> in this instance, and</li>
<li><code>confirm :: IO Bool</code>, so <code>b</code> should be <code>Bool</code></li>
</ol>
<h3 id="fmap-and-"><a class="header" href="#fmap-and-">fmap and &lt;$&gt;</a></h3>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>&lt;$&gt;</code> is the infix version of <code>fmap</code>. Use it at your discretion.</p>
<p>What if we want a function that reads a line from stdin
and returns it with <code>!</code> at the end? We could use a combination
of <code>&gt;&gt;=</code> and <code>pure</code>:</p>
<pre><code>getLine &gt;&gt;= \line -&gt; pure (line ++ &quot;!&quot;)
</code></pre>
<p>The pattern is unified to the <code>fmap</code> function:</p>
<pre><code>fmap (\line -&gt; line ++ &quot;!&quot;) getLine
</code></pre>
<p><code>fmap</code> applies a function to the value to be returned
from the <code>IO</code> operation, also known as &quot;mapping&quot; over it.</p>
<p>(By the way, Have you noticed the similarities between <code>fmap</code> and <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>?)</p>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<p>Here's a list of <code>IO</code> combinators we ran into:</p>
<pre><code class="language-hs">-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced &quot;bind&quot;.
(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b

-- sequence two IO operations, discarding the payload of the first.
(*&gt;) :: IO a -&gt; IO b -&gt; IO b

-- &quot;lift&quot; a value into IO context, does not add any I/O effects.
pure :: a -&gt; IO a

-- &quot;map&quot; (or apply a function) over the payload value of an IO operation.
fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<h2 id="io-is-first-class"><a class="header" href="#io-is-first-class">IO is first class</a></h2>
<p>The beauty of <code>IO</code> is that it's a completely first-class construct in the language,
and is not really different from <code>Maybe</code>, <code>Either</code>, or <code>Structure</code>. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without combining it into <code>main</code> in some way won't actually
<em>do</em> anything. It is just a value!</p>
<p>Here's an example of a function that takes IO actions as input:</p>
<pre><code class="language-hs">whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
<p>And how it can be used:</p>
<pre><code class="language-hs">main :: IO ()
main =
  putStrLn &quot;This program will tell you a secret&quot; *&gt;
    whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt;
      putStrLn &quot;Bye&quot;
</code></pre>
<p>Notice how <code>putStrLn &quot;IO is actually pretty awesome&quot;</code> isn't executed
right away, but only if it is what <code>whenIO</code> returns, and in turn, is <em>combined</em>
with <code>*&gt;</code> as part of the <code>main</code> expression.</p>
<h2 id="getting-out-of-io"><a class="header" href="#getting-out-of-io">Getting out of IO?</a></h2>
<p>What we've seen above has great consequences for the Haskell language.
In our <code>Html</code> type, we had a function <code>render :: Html -&gt; String</code>
that could turn an <code>Html</code> into a string value.</p>
<p>In Haskell, <strong>there is no way</strong> to implement a function such as <code>execute :: IO a -&gt; a</code>
that preserves purity and equational reasoning!</p>
<p>Also, <code>IO</code> is <em>opaque</em>. It does not let us examine it. So we are really bound
to what the Haskell API for <code>IO</code> allows us to do.</p>
<p>This means that <strong>we need to think about using IO differently</strong>!</p>
<p>In Haskell, once we get into <code>IO</code>, there is no getting out.
The only thing we can do is to build bigger IO computations by <em>combining</em>
it with more IO computations.</p>
<p>We also can't use <code>IO a</code> in place of an <code>a</code>. For example,
we can't write <code>getLine ++ &quot;!&quot;</code> because <code>++</code> expects both
sides to be <code>String</code>, but <code>getLine</code>'s type is <code>IO String</code>. The types do not match!
We have to use <code>fmap</code>, and the return type must be <code>IO String</code>, as we've seen before.</p>
<p>In Haskell, we like to keep <code>IO</code> usage minimal, and we like to push it to the edges
of the program. This pattern is often called <em>Functional core, imperative shell</em>.</p>
<h2 id="functional-core-imperative-shell"><a class="header" href="#functional-core-imperative-shell">Functional core, imperative shell</a></h2>
<p>In our blog generator program, we want to read a file, parse it, convert it to HTML,
and then print the result to the console.</p>
<p>In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the HTML conversion. But we don't mix these here.
Parsing operates on a <code>String</code> value rather than some file handle,
and <code>Html</code> is being converted to a <code>String</code> rather than being written to the screen directly.</p>
<p>This approach of separating <code>IO</code> and pushing it to the edge of the program gives us
a lot of flexibility. These functions without <code>IO</code> are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular and can work in many contexts (reading from stdin,
reading from a network socket, writing to an HTTP connection, and more).</p>
<p>This pattern is often a good approach for building Haskell programs, especially
batch programs.</p>
<h2 id="building-a-blog-generator"><a class="header" href="#building-a-blog-generator">Building a blog generator</a></h2>
<p>We'd like to start building a blog generator, and we want to have the following
interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name, and the second one
will be the output file name</li>
<li>If the output file already exists, we'll ask the user if they want
to overwrite the file</li>
<li>On any other kind of input, we'll print a generic message explaining
the proper usage</li>
</ol>
<p>We are going to need a few functions:</p>
<pre><code class="language-hs">getArgs :: IO [String] -- Get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -&gt; IO String -- Read all of the content from a file

writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file

doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists
</code></pre>
<p>And the following imports:</p>
<pre><code class="language-hs">import System.Directory (doesFileExist)
import System.Environment (getArgs)
</code></pre>
<p>We don't need to add the following import because <code>Prelude</code> already imports
these functions for us:</p>
<pre><code class="language-hs">-- imported by Prelude
import System.IO (getContents, readFile, writeFile)
</code></pre>
<hr />
<ol>
<li>
<p>Implement a function <code>process :: Title -&gt; String -&gt; String</code> which will parse
a document to markup, convert it to HTML, and then render the HTML to a string.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
</li>
<li>
<p>Try implementing the &quot;imperative shell&quot; for our blog generator program.
Start with <code>main</code>, pattern match on the result of <code>getArgs</code>, and decide what to
do. Look back at the examples above for inspiration.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main =
  getArgs &gt;&gt;= \args -&gt;
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] -&gt;
        getContents &gt;&gt;= \content -&gt;
          putStrLn (process &quot;Empty title&quot; content)

      -- With input and output file paths as program arguments
      [input, output] -&gt;
        readFile input &gt;&gt;= \content -&gt;
          doesFileExist output &gt;&gt;= \exists -&gt;
            let
              writeResult = writeFile output (process input content)
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ -&gt;
        putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="do-notation"><a class="header" href="#do-notation">Do notation</a></h2>
<p>While using <code>&gt;&gt;=</code> to chain <code>IO</code> actions is manageable, Haskell provides
an even more convenient syntactic sugar called <em>do notation</em>
which emulates imperative programming.</p>
<p>A <em>do block</em> starts with the <code>do</code> keyword and continues with one or more
&quot;statements&quot; which can be one of the following:</p>
<ol>
<li>An expression of type <code>IO ()</code>, such as:
<ul>
<li><code>putStrLn &quot;Hello&quot;</code></li>
<li><code>if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot;</code></li>
</ul>
</li>
<li>A let block, such as
<ul>
<li><code>let x = 1</code></li>
<li>or multiple let declarations:
<pre><code class="language-hs">let
  x = 1
  y = 2
</code></pre>
Note that we do not write the <code>in</code> here.</li>
</ul>
</li>
<li>A binding <code>&lt;variable&gt; &lt;- &lt;expresion&gt;</code>, such as
<pre><code class="language-hs">line &lt;- getLine
</code></pre>
</li>
</ol>
<p>And the last &quot;statement&quot; must be an expression of type <code>IO &lt;something&gt;</code> -
this will be the result type of the do block.</p>
<p>These constructs are desugared (translated) by the Haskell compiler to:</p>
<ol>
<li><code>&lt;expression&gt; *&gt;</code>,</li>
<li><code>let ... in</code> and</li>
<li><code>&lt;expression&gt; &gt;&gt;= \&lt;variable&gt;</code></li>
</ol>
<p>respectively.</p>
<p>For example:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting = do
  putStrLn &quot;Tell me your name.&quot;
  let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
  name &lt;- getLine
  putStrLn (greet name)
</code></pre>
<p>Is just syntactic sugar for:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting =
  putStrLn &quot;Tell me your name.&quot; *&gt;
    let
      greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
    in
      getLine &gt;&gt;= \name -&gt;
        putStrLn (greet name)
</code></pre>
<p>It's important to note the difference between <code>let</code> and <code>&lt;-</code> (bind).
<code>let</code> is used to give a new name to an expression that will be in scope
for subsequent lines, and <code>&lt;-</code> is used to bind the result <code>a</code> in an <code>IO a</code>
action to a new name that will be in scope for subsequent lines.</p>
<table>
  <tr>
    <th>code</th>
    <th>operator</th>
    <th>type of the left side</th>
    <th>type of the right side</th>
    <th>comment</th>
  </tr>
  <tr>
    <td><pre><pre>let greeting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>Both sides are interchangeable</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>We just create a new name for <code>getLine</code></td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>
  </tr>
</table>
<p>Do notation is very very common and is often preferable to using <code>&gt;&gt;=</code> directly.</p>
<hr />
<ol>
<li>
<p>Exercise: Translate the examples in this chapter to <em>do notation</em>.</p>
</li>
<li>
<p>Exercise: Translate our glue code for the blog generator to <em>do notation</em>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main = do
  args &lt;- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -&gt; do
      content &lt;- getContents
      putStrLn (process &quot;Empty title&quot; content)

    -- With input and output file paths as program arguments
    [input, output] -&gt; do
      content &lt;- readFile input
      exists &lt;- doesFileExist output
      let
        writeResult = writeFile output (process input content)
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ -&gt;
      putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm = do
  putStrLn &quot;Are you sure? (y/n)&quot;
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. use y or n&quot;
      confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>In this chapter, we discussed what &quot;purely functional&quot; means,
where the initial motivation for being purely functional comes from,
and how Haskell's I/O interface allows us to create descriptions of programs
without breaking purity.</p>
<p>We have also achieved a major milestone. With this chapter, we have implemented
enough pieces to finally run our program on a single document
and get an HTML-rendered result!</p>
<p>However, our command-line interface is still sub-par. We want to render a blog
with multiple articles, create an index page, and more. We still have more to do
to be able to call our program a blog generator.</p>
<p>Let's keep going!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/908e7173cf32de5ce8507e43a1fb9124fc5d63f4">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/908e7173cf32de5ce8507e43a1fb9124fc5d63f4">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-a-project-description"><a class="header" href="#defining-a-project-description">Defining a project description</a></h1>
<p>Up until now, we've only used <code>base</code> and the libraries
<a href="https://downloads.haskell.org/ghc/9.2.7/docs/html/users_guide/9.2.7-notes.html#included-libraries">included</a>
with GHC. Because of that, we didn't really need to do anything fancier
than <code>runghc</code> to run our program. However, we want to start using
external libraries not included with GHC in our programs.</p>
<p>External packages can be downloaded from <a href="https://hackage.haskell.org/">Hackage</a> -
Haskell's central package archive, <a href="https://www.stackage.org/">Stackage</a> -
a subset of Hackage packages known to work together or even
from remote git repositories. Usually, Haskellers use a <strong>package manager</strong> to
download and manage packages for different projects. The most popular package
managers for Haskell are <a href="https://cabal.readthedocs.io">cabal</a> and
<a href="https://haskellstack.org">stack</a>.</p>
<p>A major difference between the two is their philosophy.
<code>cabal</code> tries to be a more minimalist tool that handles building Haskell projects,
doing package management using the whole of Hackage, and uses complicated algorithms
to make sure packages work together.
<code>stack</code> tries to be a more maximalistic tool that handles installing the right GHC
for each project, provides integration with external tools like hoogle,
and lets the user choose which 'set' of packages (including their versions) they want to use.</p>
<p>If you've installed Haskell using GHCup, you most likely have <code>cabal</code> installed.
If you've installed Haskell using stack, well, you have <code>stack</code> installed.
Check the <a href="https://www.haskell.org/downloads/">haskell.org downloads page</a> if that's not the case.</p>
<h2 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h2>
<p>Using external packages can be done in multiple ways.
For quick experimentation, we can just
<a href="https://gilmi.me/blog/post/2021/08/14/hs-core-tools#using-external-packages-in-ghci">ask stack or cabal</a>
to build or even run our program with external packages.
But as programs get larger, use more dependencies, and require more functionality,
it is better to <strong>create a project description</strong> for our programs and libraries.</p>
<p>The project description is done in a <strong>cabal file</strong>. We can ask cabal or stack
to generate one for us using <code>cabal init --libandexe</code> or <code>stack new</code>,
along with many other files, but we will likely need to edit the file by hand
later. For now, let's just paste an initial example in <code>hs-blog.cabal</code> and edit it.</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                name should match with &lt;name&gt;.cabal
version:             version should use PvP
synopsis:            Synopsis will appear in the hackage package listing and search
description:         The description will appear at the top of a library
homepage:            Homepage url
bug-reports:         issue-tracker url
license:             License name
license-file:        License file
author:              Author name
maintainer:          Maintainer email
category:            Hackage categories, separated by commas
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , &lt;package-name&gt;
  ghc-options:
    -O
</code></pre>
<p>Let's break it down to a few parts, the
<a href="05-glue/03-project.html#package-metadata">package metadata</a>,
<a href="05-glue/03-project.html#common-settings">common settings</a>,
<a href="05-glue/03-project.html#library">library</a> and
<a href="05-glue/03-project.html#executable">executable</a>.</p>
<h3 id="package-metadata"><a class="header" href="#package-metadata">Package metadata</a></h3>
<p>The first part should be fairly straightforward from the comments, maybe except for:</p>
<ul>
<li><code>cabal-version</code>: Defines which cabal versions can build this project. We've specified 2.4 and above.
<a href="https://cabal.readthedocs.io/en/stable/file-format-changelog.html">More info on different versions</a>.</li>
<li><code>name</code>: The name of your library and package. Must match with the <code>.cabal</code> filename. Usually starts with a lowercase. <a href="https://hackage.haskell.org/packages/search?terms=name">Check if your package name is already taken on Hackage</a>.</li>
<li><code>version</code>: Some Haskell packages use <a href="https://semver.org/">semver</a>, most use <a href="https://pvp.haskell.org/">PvP</a>.</li>
<li><code>license</code>: Most Haskell packages use <a href="https://choosealicense.com/licenses/bsd-3-clause/">BSD-3-Clause</a>. <a href="https://neilmitchell.blogspot.com/2018/08/licensing-my-haskell-packages.html">Neil Mitchell blogged about this</a>. You can find more licenses if you'd like at <a href="https://choosealicense.com">choosealicense.com</a>.</li>
<li><code>extra-doc-files</code>: Include extra doc files here, such as <code>README</code> or <code>CHANGELOG</code>.</li>
</ul>
<p>Let's fill this with the metadata of our project:</p>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parser for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md
</code></pre>
<h3 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h3>
<p>Cabal package descriptions can include multiple &quot;targets&quot;: libraries, executables,
and test suites. Since Cabal 2.2, we can use
<a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#common-stanzas">common stanzas</a>
to group settings to be shared between different targets, so we don't have to repeat them for each target.</p>
<p>In our case, we've created a new common stanza (or block) called <code>common-settings</code> and
defined the default language (Haskell has two standards, 98 and 2010),
and instructed GHC to compile with <code>-Wall</code>.</p>
<pre><code class="language-cabal">common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall
</code></pre>
<p>Later, in our targets' descriptions, we can add <code>import: common-settings</code> ,
and all of these settings will be automatically added.</p>
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<p>In a <code>library</code> target, we define:</p>
<ul>
<li>The settings with which to build the library (in this case, we just import <code>common-settings</code>)</li>
<li>The directory in which the source files can be found</li>
<li>The packages we require to build the library</li>
<li>The modules exposed from the library and can be used by others</li>
<li>The modules <em>not</em> exposed from the library and which <em>cannot</em> be used by others;
these could be any module you don't wish to export, such as an internal utility
functions module.
In our case, we don't have anything like this, so we commented out the <code>other-modules</code>
label.</li>
</ul>
<p>Note that it is common to specify <strong>version bounds</strong> for packages.
Version bounds specify <em>which package versions this library works with</em>.
These can also be generated using cabal with the <code>cabal gen-bounds</code> command.</p>
<pre><code class="language-cabal">library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:
</code></pre>
<p>Also, note that we've added an additional <em>hierarchy</em> for our modules and defined
a different source directory (<code>src</code>). This means we will need to move the files around
a bit and change the <code>module</code> name in each file and the <code>import</code> statements. This is to avoid
conflict with other packages that a user might import.</p>
<hr />
<p>Do this now.</p>
<details><summary>Solution</summary>
<ol>
<li>
<p><code>Main.hs</code> -&gt; <code>src/HsBlog.hs</code></p>
<pre><code class="language-hs">module HsBlog
  ( main
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)
</code></pre>
</li>
<li>
<p><code>Convert.hs</code> -&gt; <code>src/HsBlog/Convert.hs</code></p>
<pre><code class="language-hs">module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
</code></pre>
</li>
<li>
<p><code>Html.hs</code> -&gt; <code>src/HsBlog/Html.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html
...

import HsBlog.Html.Internal
</code></pre>
</li>
<li>
<p><code>Html/Internal.hs</code> -&gt; <code>src/HsBlog/Html/Internal.hs</code></p>
<pre><code class="language-hs">module HsBlog.Html.Internal where
</code></pre>
</li>
<li>
<p><code>Markup.hs</code> -&gt; <code>src/HsBlog/Markup.hs</code></p>
<pre><code class="language-hs">module HsBlog.Markup
</code></pre>
</li>
</ol>
</details>
<hr />
<h3 id="executable"><a class="header" href="#executable">Executable</a></h3>
<p>We have separated our code into two sections: a library and an executable; why?</p>
<p>First, libraries can be used by others. If we publish our code and someone wants to
use it and build upon it, they can. Executables can't be imported by other projects.
Second, we can write unit tests for libraries. It is usually
beneficial to write most, if not all, of our logic as a library, and provide
a thin executable over it.</p>
<p>Executables' descriptions are very similar to libraries; here, we define:</p>
<ul>
<li>The name of the executable</li>
<li>Where the source directory for this application is</li>
<li>Which file is the 'Main' file</li>
<li>Import our library, which is named <code>hs-blog</code></li>
<li>Additional flags for GHC, e.g., <code>-O</code> to compile with optimizations</li>
</ul>
<pre><code class="language-cabal">executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We can write many executables' descriptions. In this case, we only have one.</p>
<hr />
<p><strong>Exercise</strong>: Add a new file: <code>app/Main.hs</code> which imports <code>HsBlog</code> and runs <code>main</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- app/Main.hs

module Main where

import qualified HsBlog

main :: IO ()
main = HsBlog.main
</code></pre>
</details>
<hr />
<h3 id="test-suites"><a class="header" href="#test-suites">Test-suites</a></h3>
<p><code>test-suite</code> defines a target for running package tests. We will get back to it
in a later chapter.</p>
<h2 id="our-complete-cabal-file"><a class="header" href="#our-complete-cabal-file">Our complete .cabal file</a></h2>
<pre><code class="language-cabal">cabal-version:       2.4

name:                hs-blog
version:             0.1.0.0
synopsis:            A custom blog generator from markup files
description:         This package provides a static blog generator
                     from a custom markup format to HTML.
                     It defines a parser for this custom markup format
                     as well as an html pretty printer EDSL.

                     It is used as the example project in the online book
                     'Learn Haskell Blog Generator'. See the README for
                     more details.
homepage:            https://github.com/soupi/learn-haskell-blog-generator
bug-reports:         https://github.com/soupi/learn-haskell-blog-generator/issues
license:             BSD-3-Clause
license-file:        LICENSE.txt
author:              Gil Mizrahi
maintainer:          gilmi@posteo.net
category:            Learning, Web
extra-doc-files:
  README.md

common common-settings
  default-language: Haskell2010
  ghc-options:
    -Wall

library
  import: common-settings
  hs-source-dirs: src
  build-depends:
      base
    , directory
  exposed-modules:
    HsBlog
      HsBlog.Convert
      HsBlog.Html
        HsBlog.Html.Internal
      HsBlog.Markup
  -- other-modules:

executable hs-blog-gen
  import: common-settings
  hs-source-dirs: app
  main-is: Main.hs
  build-depends:
      base
    , hs-blog
  ghc-options:
    -O
</code></pre>
<p>We'll also add a <code>README.md</code> file and a <code>LICENSE.txt</code> file:</p>
<details><summary>README.md</summary>
<p>Just write whatever you want here:</p>
<pre><code class="language-md"># hs-blog

One day it will be a static blog generator.

[Read the book](https://learn-haskell.blog).
</code></pre>
</details>
<details><summary>LICENSE.txt</summary>
<p>This is BSD-3-Clause with me as the author. Please write your own name for your projects :)</p>
<pre><code>BSD 3-Clause License

Copyright (c) 2021-2022, Gil Mizrahi
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</code></pre>
</details>
<h2 id="cabalproject-and-stackyaml"><a class="header" href="#cabalproject-and-stackyaml"><code>cabal.project</code> and <code>stack.yaml</code></a></h2>
<p>The <a href="https://cabal.readthedocs.io/en/stable/cabal-project.html">cabal.project</a> and
<a href="https://docs.haskellstack.org/en/stable/yaml_configuration/#project-specific-config">stack.yaml</a>
files are used by <code>cabal</code> and <code>stack</code> respectively to add additional information on <em>how
to build the package</em>. While <code>cabal.project</code> isn't necessary to use <code>cabal</code>, <code>stack.yaml</code>
is necessary in order to use <code>stack</code>, so we will cover it briefly.</p>
<p>There are two important fields a <code>stack.yaml</code> file must have:</p>
<ul>
<li><code>resolver</code>: Describes which snapshot to use for packages and ghc version.
We will choose the latest (at time of writing) on the <code>lts</code> branch: <code>lts-18.22</code>.
Visit <a href="https://www.stackage.org/lts-18.22">this link</a> to find out which packages this
snapshot includes, what their versions are, and which GHC version is used
with this snapshot</li>
<li><code>packages</code>: Describes the location of packages we plan to build. In our case
we have only one, and it can be found in the current directory</li>
</ul>
<p>We'll add <code>stack.yaml</code> to our project directory:</p>
<pre><code class="language-yaml">resolver: lts-18.22

packages:
- .
</code></pre>
<p>For additional options and configurations, please consult the relevant user guides.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Now, instead of manually running <code>runghc Main.hs</code>, we will use either <code>stack</code>
or <code>cabal</code> to build and run our program and package (I mostly use stack, but it's up to you).</p>
<h3 id="for-cabal"><a class="header" href="#for-cabal">For cabal:</a></h3>
<p>Building the project - on the first run, cabal will download the package dependencies
and use the GHC on PATH to build the project.</p>
<p>Cabal caches packages between projects, so if a new project uses the same packages
with the same versions (and the same flag settings), they will not need to be reinstalled.</p>
<blockquote>
<p>In older versions of cabal, packages could be installed globally or in sandboxes.
In each sandbox (and globally), there could only be one version of a package installed,
and users would usually create different sandboxes for different projects without caching
packages between projects.</p>
<p>With the new build system implementation, multiple versions of the same package can be
installed globally, and for each project, cabal will (try to) choose a specific version for each
package dependency such that they all work together without needing sandboxing.
This change helps us increase sharing of built packages while avoiding conflicts and manual
handling of sandboxes.</p>
</blockquote>
<p>A few important commands we should be familiar with:</p>
<pre><code class="language-sh">cabal update
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-update"><code>update</code></a>
fetches information from remote package repositories (specifically Hackage unless specified otherwise)
and updates the local package index, which includes various information about available packages, such as
their names, versions, and dependencies.</p>
<p><code>cabal update</code> is usually the first command to run before fetching package dependencies.</p>
<pre><code class="language-sh">cabal build
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-build"><code>build</code></a>
compiles the various targets (such as <code>library</code> and <code>executable</code>s).
It will also fetch and install the package dependencies when they're not already installed.</p>
<p>When building executables, <code>cabal build</code> will report where the executable has been created,
and it is also possible to find the path to the executable using <code>cabal exec -- which hs-blog-gen</code>.</p>
<pre><code class="language-sh">cabal run hs-blog-gen -- &lt;program arguments&gt;
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-run"><code>run</code></a>
Can be used to compile and then run a target (in our case our <code>executable</code> which we named <code>hs-blog-gen</code>).
We separate arguments passed to <code>cabal</code> and arguments passed to our target program with <code>--</code>.</p>
<pre><code class="language-sh">cabal repl hs-blog
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-repl"><code>repl</code></a>
runs <code>ghci</code> in the context of the target (in our case our <code>library</code> which we named <code>hs-blog</code>) -
it will load the target's package dependencies and modules to be available in <code>ghci</code>.</p>
<pre><code class="language-sh">cabal clean
</code></pre>
<p><a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html#cabal-clean"><code>clean</code></a>
Deletes the build artifacts that we built.</p>
<p>There are more interesting commands we could use, such as <code>cabal freeze</code>, to generate
a file that records the versions of the packages and flags we used to build this project,
and <code>cabal sdist</code> to bundle the project source to a package tarball which can be
uploaded to Hackage. If you'd like to learn more, visit the
<a href="https://cabal.readthedocs.io/en/stable/cabal-commands.html">Cabal user guide</a>.</p>
<h3 id="for-stack"><a class="header" href="#for-stack">For stack:</a></h3>
<p>Building the project - on the first run, stack will install the right GHC for this project
which is specified by the <code>resolver</code> field in the <code>stack.yaml</code> file,
download the package dependencies, and compile the project.</p>
<p>Stack caches these installations between projects that use the same resolver,
so future projects with the same resolver and future runs of this project won't
require reinstallation. This approach is kind of a middle ground between full package
sharing and sandboxes.</p>
<p>Let's look at the (somewhat) equivalent commands for Stack:</p>
<pre><code class="language-sh">stack build
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/build_command/#build-command"><code>build</code></a>
will compile the project as described above - installing GHC and package dependencies if they are not
installed.</p>
<p>When building executables, <code>stack build</code> will report where the executable has been created,
and it is also possible to find the path to the executable using <code>stack exec -- which hs-blog-gen</code>.</p>
<pre><code class="language-sh">stack exec hs-blog-gen -- &lt;program arguments&gt;
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/GUIDE/#stack-exec"><code>exec</code></a>
will run the executable passing the program arguments to our executable.</p>
<pre><code class="language-sh">stack ghci hs-blog
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/ghci/#ghci"><code>ghci</code></a>
runs <code>ghci</code> in the context of our library <code>hs-blog</code> - loading the library modules
and packages.</p>
<pre><code class="language-sh">stack clean
</code></pre>
<p><a href="https://docs.haskellstack.org/en/stable/GUIDE/#cleaning-your-project"><code>clean</code></a>
cleans up build artifacts.</p>
<p>The <a href="https://docs.haskellstack.org/en/stable/GUIDE/">Stack user guide</a> contains more
information about how stack works and how to use it effectively.</p>
<h3 id="build-artifacts"><a class="header" href="#build-artifacts">Build artifacts</a></h3>
<p>Both stack and cabal create build artifacts that we will not want to track using
our version control. These build artifacts are found in the <code>dist</code>, <code>dist-newstyle</code>
and <code>.stack-work</code> directories. We can add these to a <code>.gitignore</code> file
(or similar for other version control programs) to ignore them:</p>
<pre><code class="language-txt">dist
dist-newstyle
.stack-work
</code></pre>
<h2 id="finding-packages"><a class="header" href="#finding-packages">Finding packages</a></h2>
<p>Finding packages isn't a very straightforward process at the moment.
People have written on
<a href="https://www.haskellforall.com/2018/05/how-i-evaluate-haskell-packages.html">how they choose packages</a>,
<a href="https://github.com/soupi/haskell-study-plan#useful-packages">recommendation lists</a>, <a href="https://leanpub.com/haskell-stdlibs">books</a>, and more.</p>
<p>My suggestion is:</p>
<ul>
<li>Search for a tutorial on something you'd like to do, and see which packages come up</li>
<li>Use the download amount on Hackage as an indication of package popularity</li>
<li>Use <a href="https://www.stackage.org/lts">Stackage</a> package synopses to locate a relevant package</li>
<li>Check social network channels for recommendations, but know that sometimes people tend
to recommend inappropriate solutions and packages that might be too complicated or
still experimental</li>
</ul>
<p>It's also important to note the amount of dependencies a package has. Adding many dependencies
will affect compilation time and code size. And it can sometimes be a good thing to consider
when comparing packages or considering whether a package is needed at all.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>We've created a package description for our library and used <code>stack</code> and/or <code>cabal</code>
to build our program. In future chapters, we'll start adding external packages,
we'll only have to add them to the <code>build-depends</code> section in the cabal file, and
our package manager will download and install the required package for us!</p>
<p>We've made some changes to our project directory, and it should now look like this:</p>
<pre><code>.
├── app
│   └── Main.hs
├── hs-blog.cabal
├── LICENSE.txt
├── README.md
├── src
│   ├── HsBlog
│   │   ├── Convert.hs
│   │   ├── Html
│   │   │   └── Internal.hs
│   │   ├── Html.hs
│   │   └── Markup.hs
│   └── HsBlog.hs
└── stack.yaml

4 directories, 10 files
</code></pre>
<p>Note that this package format could be released on <a href="https://hackage.haskell.org/">Hackage</a>
for other Haskell developers to use!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/8ca58aef80930db82cd20e85f44f5e34e1d74214">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/8ca58aef80930db82cd20e85f44f5e34e1d74214">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fancy-options-parsing"><a class="header" href="#fancy-options-parsing">Fancy options parsing</a></h1>
<p>We'd like to define a nicer interface for our program. While we could manage something
ourselves with <code>getArgs</code> and pattern matching, it is easier to get good results using a library.
We are going to use a package called
<a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>.</p>
<p><code>optparse-applicative</code> provides us with an EDSL (yes, another one) to build
command arguments parsers. Things like commands, switches, and flags can be built
and composed together to make a parser for command-line arguments without actually
writing operations on strings as we did when we wrote our Markup parser, and will
provide other benefits such as automatic generation of usage lines, help screens,
error reporting, and more.</p>
<p>While <code>optparse-applicative</code>'s dependency footprint isn't very large,
it is likely that a user of our library wouldn't need command-line parsing
in this particular case, so it makes sense to add this dependency to the <code>executable</code> section
(rather than the <code>library</code> section) in the <code>.cabal</code> file:</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
   build-depends:
       base
+    , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="building-a-command-line-parser"><a class="header" href="#building-a-command-line-parser">Building a command-line parser</a></h2>
<p>The optparse-applicative package has pretty decent
<a href="https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative">documentation</a>,
but we will cover a few important things to pay attention to in this chapter.</p>
<p>In general, there are four important things we need to do:</p>
<ol>
<li>
<p>Define our model - we want to define an ADT that describes the various options
and commands for our program</p>
</li>
<li>
<p>Define a parser that will produce a value of our model type when run</p>
</li>
<li>
<p>Run the parser on our program arguments input</p>
</li>
<li>
<p>Pattern match on the model and call the right operations according to the options</p>
</li>
</ol>
<h3 id="define-a-model"><a class="header" href="#define-a-model">Define a model</a></h3>
<p>Let's envision our command-line interface for a second; what should it
look like?</p>
<p>We want to be able to convert a single file or input stream to either a file
or an output stream, or we want to process a whole directory and create a new directory.
We can model it in an ADT like this:</p>
<pre><code class="language-hs">data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show
</code></pre>
<blockquote>
<p>Note that we could technically also use <code>Maybe FilePath</code> to encode both <code>SingleInput</code>
and <code>SingleOutput</code>, but then we would have to remember what <code>Nothing</code> means
in each context. By creating a new type with properly named constructors
for each option, we make it easier for readers of the code to understand
the meaning of our code.</p>
</blockquote>
<p>In terms of interface, we could decide that when a user would like to convert
a single input source, they would use the <code>convert</code> command, and supply the optional flags
<code>--input FILEPATH</code> and <code>--output FILEPATH</code> to read or write from a file.
When the user does not supply one or both flags, we will read or write from
the standard input/output accordingly.</p>
<p>If the user would like to convert a directory, they can use the <code>convert-dir</code>
command and supply the two mandatory flags <code>--input FILEPATH</code> and
<code>--output FILEPATH</code>.</p>
<h3 id="build-a-parser"><a class="header" href="#build-a-parser">Build a parser</a></h3>
<p>This is the most interesting part of the process. How do we build a parser
that fits our model?</p>
<p>The <code>optparse-applicative</code> library introduces a new type called <code>Parser</code>.
<code>Parser</code>, similar to <code>Maybe</code> and <code>IO</code>, has the kind <code>* -&gt; *</code> - when it
is supplied with a saturated (or concrete) type such as <code>Int</code>, <code>Bool</code> or
<code>Options</code>, it can become a saturated type (one that has values).</p>
<p>A <code>Parser a</code> represents a specification of a command-line options parser
that produces a value of type <code>a</code> when the command-line arguments are
successfully parsed.
This is similar to how <code>IO a</code> represents a description of a program
that can produce a value of type <code>a</code>. The main difference between these
two types is that while we can't convert an <code>IO a</code> to an <code>a</code>
(we just chain IO operations and have the Haskell runtime execute them),
we <em>can</em> convert a <code>Parser a</code> to a function that takes a list of strings
representing the program arguments and produces an <code>a</code> if it manages
to parse the arguments.</p>
<p>As we've seen with the previous EDSLs, this library uses the <em>combinator pattern</em>
as well. We need to consider the basic primitives for building
a parser and the methods of composing small parsers into bigger
parsers.</p>
<p>Let's see an example of a small parser:</p>
<pre><code class="language-hs">inp :: Parser FilePath
inp =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Input file&quot;
    )

out :: Parser FilePath
out =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Output file&quot;
    )
</code></pre>
<p><code>strOption</code> is a parser builder. It is a function that takes a combined
<em>option modifiers</em> as an argument, and returns a parser that will parse a string.
We can specify the type to be <code>FilePath</code> because <code>FilePath</code> is an
alias to <code>String</code>. The parser builder describes how to parse the value,
and the modifiers describe its properties, such as the flag name,
the shorthand of the flag name, and how it would be described in the usage
and help messages.</p>
<blockquote>
<p>Actually, <code>strOption</code> can return any string type
that implements the interface <code>IsString</code>. There are a few such types,
for example, <code>Text</code>, a much more efficient Unicode text type from the <code>text</code> package.
It is more efficient than <code>String</code> because while <code>String</code> is implemented as a
linked list of <code>Char</code>, <code>Text</code> is implemented as an array of bytes.
<code>Text</code> is usually what we should use for text values instead of <code>String</code>. We haven't
been using it up until now because it is slightly less ergonomic to use
than <code>String</code>. But it is often the preferred type to use for text!</p>
</blockquote>
<p>As you can see, modifiers can be composed using the <code>&lt;&gt;</code> function,
which means modifiers implement an instance of the <code>Semigroup</code> type class!</p>
<p>With such an interface, we don't have to supply all the modifier
options, only the relevant ones. So if we don't want to
have a shortened flag name, we don't have to add it.</p>
<h4 id="functor"><a class="header" href="#functor">Functor</a></h4>
<p>For the data type we've defined, having <code>Parser FilePath</code> takes us
a good step in the right direction, but it is not exactly what we need
for a <code>ConvertSingle</code>. We need a <code>Parser SingleInput</code> and a
<code>Parser SingleOutput</code>. If we had a <code>FilePath</code>, we could convert
it into <code>SingleInput</code> by using the <code>InputFile</code> constructor.
Remember, <code>InputFile</code> is also a function:</p>
<pre><code class="language-hs">InputFile :: FilePath -&gt; SingleInput
OutputFile :: FilePath -&gt; SingleOutput
</code></pre>
<p>However, to convert a parser, we need functions with these types:</p>
<pre><code class="language-hs">f :: Parser FilePath -&gt; Parser SingleInput
g :: Parser FilePath -&gt; Parser SingleOutput
</code></pre>
<p>Fortunately, the <code>Parser</code> interface provides us with a function to &quot;lift&quot;
a function like <code>FilePath -&gt; SingleInput</code> to work on parsers, making
it a function with the type <code>Parser FilePath -&gt; Parser SingleInput</code>.
Of course, this function will work for any input and output,
so if we have a function with the type <code>a -&gt; b</code>, we can pass it to
that function and get a new function of the type <code>Parser a -&gt; Parser b</code>.</p>
<p>This function is called <code>fmap</code>:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b

-- Or with its infix version
(&lt;$&gt;)  :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
</code></pre>
<p>We've seen <code>fmap</code> before in the interface of other types:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]

fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>fmap</code> is a type class function like <code>&lt;&gt;</code> and <code>show</code>. It belongs
to the type class <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>:</p>
<pre><code class="language-hs">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And it has the following laws:</p>
<pre><code class="language-hs">-- 1. Identity law:
--    if we don't change the values, nothing should change
fmap id = id

-- 2. Composition law:
--    Composing the lifted functions is the same a composing
--    them after fmap
fmap (f . g) == fmap f . fmap g
</code></pre>
<p>Any type <code>f</code> that can implement <code>fmap</code> and follow these laws can be a valid
instance of <code>Functor</code>.</p>
<blockquote>
<p>Notice how <code>f</code> has a kind <code>* -&gt; *</code>, we can infer the kind of <code>f</code>
by looking at the other types in the type signature of <code>fmap</code>:</p>
<ol>
<li><code>a</code> and <code>b</code> have the kind <code>*</code> because they are used as arguments/return
types of functions</li>
<li><code>f a</code> has the kind <code>*</code> because it is used as an argument to a function, therefore</li>
<li><code>f</code> has the kind <code>* -&gt; *</code></li>
</ol>
</blockquote>
<p>Let's choose a data type and see if we can implement a <code>Functor</code> instance.
We need to choose a data type that has the kind <code>* -&gt; *</code>. <code>Maybe</code> fits the bill.
We need to implement a function <code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>.
Here's one very simple (and wrong) implementation:</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX = Nothing
</code></pre>
<p>Check it out yourself! It compiles successfully! But unfortunately, it does not
satisfy the first law. <code>fmap id = id</code> means that
<code>mapMaybe id (Just x) == Just x</code>, however, from the definition, we can
clearly see that <code>mapMaybe id (Just x) == Nothing</code>.</p>
<p>This is a good example of how Haskell doesn't help us ensure the laws
are satisfied, and why they are important. Unlawful <code>Functor</code> instances
will behave differently from how we'd expect a <code>Functor</code> to behave.
Let's try again!</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX =
  case maybeX of
    Nothing -&gt; Nothing
    Just x -&gt; Just (func x)
</code></pre>
<p>This <code>mapMaybe</code> will satisfy the functor laws. This can be proved
by doing algebra - if we can do substitution and reach the other side of the
equation in each law, then the law holds.</p>
<p>Functor is a very important type class, and many types implement this interface.
As we know, <code>IO</code>, <code>Maybe</code>, <code>[]</code> and <code>Parser</code> all have the kind <code>* -&gt; *</code>,
and all allow us to map over their &quot;payload&quot; type.</p>
<blockquote>
<p>Often, people try to look for analogies and metaphors to what a type class means,
but type classes with funny names like <code>Functor</code> don't usually have an
analogy or a metaphor that fits them in all cases. It is easier to give up
on the metaphor and think about it as it is - an interface with laws.</p>
</blockquote>
<p>We can use <code>fmap</code> on <code>Parser</code> to make a parser that returns <code>FilePath</code> to
return a <code>SingleInput</code> or <code>SingleOutput</code> instead:</p>
<pre><code class="language-hs">pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>Now that we have two parsers,
<code>pInputFile :: Parser SingleInput</code>
and <code>pOutputFile :: Parser SingleOutput</code>,
we want to <em>combine</em> them as <code>Options</code>. Again, if we only had
<code>SingleInput</code> and <code>SingleOutput</code>, we could use the constructor <code>ConvertSingle</code>:</p>
<pre><code class="language-hs">ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options
</code></pre>
<p>Can we do a similar trick to the one we saw before with <code>fmap</code>?
Does a function exist that can lift a binary function to work
on <code>Parser</code>s instead? One with this type signature:</p>
<pre><code>???
  :: (SingleInput -&gt; SingleOutput -&gt; Options)
  -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)
</code></pre>
<p>Yes. This function is called <code>liftA2</code>, and it is from the <code>Applicative</code>
type class. <code>Applicative</code> (also known as applicative functor) has three
primary functions:</p>
<pre><code class="language-hs">class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>
is another very popular type class with many instances.</p>
<p>Just like any <code>Monoid</code> is a <code>Semigroup</code>, any <code>Applicative</code>
is a <code>Functor</code>. This means that any type that wants to implement
the <code>Applicative</code> interface should also implement the <code>Functor</code> interface.</p>
<p>Beyond what a regular functor can do, which is to lift a function over
a certain <code>f</code>, applicative functors allow us to apply a function to
<em>multiple instances</em> of a certain <code>f</code>, as well as &quot;lift&quot; any value of type <code>a</code> into an <code>f a</code>.</p>
<p>You should already be familiar with <code>pure</code>, we've seen it when we
talked about <code>IO</code>. For <code>IO</code>, <code>pure</code> lets us create an <code>IO</code> action
with a specific return value without doing IO.
With <code>pure</code> for <code>Parser</code>, we can create a <code>Parser</code> that, when run,
will return a specific value as output without doing any parsing.</p>
<p><code>liftA2</code> and <code>&lt;*&gt;</code> are two functions that can be implemented in
terms of one another. <code>&lt;*&gt;</code> is actually the more useful one between
the two. Because when combined with <code>fmap</code> (or rather the infix version <code>&lt;$&gt;</code>),
it can be used to apply a function with many arguments instead of just two.</p>
<p>To combine our two parsers into one, we can use either <code>liftA2</code> or
a combination of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>:</p>
<pre><code class="language-hs">-- with liftA2
pConvertSingle :: Parser Options
pConvertSingle =
  liftA2 ConvertSingle pInputFile pOutputFile

-- with &lt;$&gt; and &lt;*&gt;
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile
</code></pre>
<p>Note that both <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> associate to the left,
so we have invisible parenthesis that look like this:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile
</code></pre>
<p>Let's take a deeper look at the types of the sub-expressions
we have here to prove that this type-checks:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options

pInputFile :: Parser SingleInput
pOutputFile :: Parser SingleOutput

ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options

(&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a` is `SingleInput`
  -- and `b` is `SingleOutput -&gt; Options`,

ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options)

(&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options`
  -- so `a` is `SingleOutput` and `b` is `Options`

-- So we get:
(ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options
</code></pre>
<p>With <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can chain as many parsers (or any applicative, really)
as we want. This is because of two things: currying and parametric polymorphism.
Because functions in Haskell take exactly one argument and return exactly one,
any multiple-argument function can be represented as <code>a -&gt; b</code>.</p>
<blockquote>
<p>You can find the laws for the applicative functors in this article called
<a href="https://wiki.haskell.org/Typeclassopedia#Laws_2">Typeclassopedia</a>, which
talks about various useful type classes and their laws.</p>
</blockquote>
<p>Applicative functor is a very important concept and will appear in various
parser interfaces (not just for command-line arguments, but also JSON
parsers and general parsers), I/O, concurrency, non-determinism, and more.
The reason this library is called optparse-applicative is because
it uses the <code>Applicative</code> interface as the main API for
constructing parsers.</p>
<hr />
<p><strong>Exercise</strong>: create a similar interface for the <code>ConvertDir</code> constructor of <code>Options</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir
</code></pre>
</details>
<hr />
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<p>One thing we forgot about is that each input and output for
<code>ConvertSingle</code> could also potentially use the standard input and output instead.
Up until now, we only offered one option: reading from or writing to a file
by specifying the flags <code>--input</code> and <code>--output</code>.
However, we'd like to make these flags optional, and when they are
not specified, use the alternative standard i/o. We can do that by using
the function <code>optional</code> from <code>Control.Applicative</code>:</p>
<pre><code class="language-hs">optional :: Alternative f =&gt; f a -&gt; f (Maybe a)
</code></pre>
<p><code>optional</code> works on types which implement instances of the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a> type class:</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
  empty :: f a
</code></pre>
<p><code>Alternative</code> looks very similar to the <code>Monoid</code> type class,
but it works on applicative functors. This type class isn't
very common and is mostly used for parsing libraries as far as I know.
It provides us with an interface to combine two <code>Parser</code>s -
if the first one fails to parse, try the other.
It also provides other useful functions such as <code>optional</code>,
which will help us with our case:</p>
<pre><code class="language-hs">pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile
</code></pre>
<p>Note that with <code>fromMaybe :: a -&gt; Maybe a -&gt; a</code> we can extract
the <code>a</code> out of the <code>Maybe</code> by supplying a value for the <code>Nothing</code> case.</p>
<p>Now we can use these more appropriate functions in <code>pConvertSingle</code> instead:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput
</code></pre>
<h4 id="commands-and-subparsers"><a class="header" href="#commands-and-subparsers">Commands and subparsers</a></h4>
<p>We currently have two possible operations in our interface,
convert a single source, or convert a directory. A nice interface for
selecting the right operation would be via commands.
If the user would like to convert a single source, they can use
<code>convert</code>, for a directory, <code>convert-dir</code>.</p>
<p>We can create a parser with commands with the <code>subparser</code> and <code>command</code>
functions:</p>
<pre><code class="language-hs">subparser :: Mod CommandFields a -&gt; Parser a

command :: String -&gt; ParserInfo a -&gt; Mod CommandFields a
</code></pre>
<p><code>subparser</code> takes <em>command modifiers</em> (which can be constructed
with the <code>command</code> function) as input and produces a <code>Parser</code>.
<code>command</code> takes the command name (in our case, &quot;convert&quot; or &quot;convert-dir&quot;)
and a <code>ParserInfo a</code>, and produces a command modifier. As we've seen
before these modifiers have a <code>Monoid</code> instance, and they can be
composed, meaning that we can append multiple commands to serve as alternatives.</p>
<p>A <code>ParserInfo a</code> can be constructed with the <code>info</code> function:</p>
<pre><code class="language-hs">info :: Parser a -&gt; InfoMod a -&gt; ParserInfo a
</code></pre>
<p>This function wraps a <code>Parser</code> with some additional information
such as a helper message, description, and more, so that the program
itself, and each sub-command can print some additional information.</p>
<p>Let's see how to construct a <code>ParserInfo</code>:</p>
<pre><code class="language-hs">pConvertSingleInfo :: ParserInfo Options
pConvertSingleInfo =
  info
    (helper &lt;*&gt; pConvertSingle)
    (progDesc &quot;Convert a single markup source to html&quot;)
</code></pre>
<p>Note that <code>helper</code> adds a helper output screen in case the parser fails.</p>
<p>Let's also build a command:</p>
<pre><code class="language-hs">pConvertSingleCommand :: Mod CommandFields Options
pConvertSingleCommand =
  command &quot;convert&quot; pConvertSingleInfo
</code></pre>
<p>Try creating a <code>Parser Options</code> combining the two options with <code>subparser</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )
</code></pre>
</details>
<h4 id="parserinfo"><a class="header" href="#parserinfo">ParserInfo</a></h4>
<p>Since we finished building a parser, we should wrap it up in a <code>ParserInfo</code>
and add some information to it to make it ready to run:</p>
<pre><code class="language-hs">opts :: ParserInfo Options
opts =
  info (helper &lt;*&gt; pOptions)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )
</code></pre>
<h3 id="running-a-parser"><a class="header" href="#running-a-parser">Running a parser</a></h3>
<p><code>optparse-applicative</code> provides a non-<code>IO</code> interface to parse arguments,
but the most convenient way to use it is to let it take care of fetching
program arguments, try to parse them, and throw errors and help messages in case
it fails. This can be done with the function <code>execParser :: ParserInfo a -&gt; IO a</code>.</p>
<p>We can place all these options parsing stuff in a new module
and then import it from <code>app/Main.hs</code>. Let's do that.
Here's what we have up until now:</p>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">-- | Command-line options parsing

module OptParse
  ( Options(..)
  , SingleInput(..)
  , SingleOutput(..)
  , parse
  )
  where

import Data.Maybe (fromMaybe)
import Options.Applicative

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

-- | Parse command-line options
parse :: IO Options
parse = execParser opts

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

-- | Parser for single output sink
pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
</details>
<h3 id="pattern-matching-on-options"><a class="header" href="#pattern-matching-on-options">Pattern matching on Options</a></h3>
<p>After running the command-line arguments parser, we can pattern match
on our model and call the right functions. Currently, our program
does not expose this kind of API. So let's go to our <code>src/HsBlog.hs</code>
module and change the API. We can delete <code>main</code> from that file and
add two new functions instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html#t:Handle"><code>Handle</code></a>
is an I/O abstraction over file system objects, including <code>stdin</code> and <code>stdout</code>.
Before, we used <code>writeFile</code> and <code>getContents</code> - these functions either
get a <code>FilePath</code> to open and work on, or they assume the <code>Handle</code> is the standard I/O.
We can use the explicit versions that take a <code>Handle</code> from <code>System.IO</code> instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)
</code></pre>
<p>We will leave <code>convertDirectory</code> unimplemented for now and implement it in the next chapter.</p>
<p>In <code>app/Main.hs</code>, we will need to pattern match on the <code>Options</code> and
prepare to call the right functions from <code>HsBlog</code>.</p>
<p>Let's look at our full <code>app/Main.hs</code> and <code>src/HsBlog.hs</code>:</p>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import OptParse
import qualified HsBlog

import System.Exit (exitFailure)
import System.Directory (doesFileExist)
import System.IO

main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output -&gt;
      HsBlog.convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            pure (&quot;&quot;, stdin)
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; pure stdout
          OutputFile file -&gt; do
            exists &lt;- doesFileExist file
            shouldOpenFile &lt;-
              if exists
                then confirm
                else pure True
            if shouldOpenFile
              then
                openFile file WriteMode
              else
                exitFailure

      HsBlog.convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle

------------------------------------------------
-- * Utilities

-- | Confirm user action
confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm
</code></pre>
</details>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">-- HsBlog.hs
module HsBlog
  ( convertSingle
  , convertDirectory
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)

import System.IO

convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory = error &quot;Not implemented&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
<p>We need to make a few small changes to the <code>.cabal</code> file.</p>
<p>First, we need to add the dependency <code>directory</code> to the <code>executable</code>,
because we use the library <code>System.Directory</code> in <code>Main</code>.</p>
<p>Second, we need to list <code>OptParse</code> in the list of modules in
the <code>executable</code>.</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
+  other-modules:
+    OptParse
   build-depends:
       base
+    , directory
     , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>We've learned about a new fancy library called <code>optparse-applicative</code>
and used it to create a fancier command-line interface in a declarative way.
See the result of running <code>hs-blog-gen --help</code> (or the equivalent
<code>cabal</code>/<code>stack</code> commands we discussed in the last chapter):</p>
<pre><code>hs-blog-gen - a static blog generator

Usage: hs-blog-gen COMMAND
  Convert markup files or directories to html

Available options:
  -h,--help                Show this help text

Available commands:
  convert                  Convert a single markup source to html
  convert-dir              Convert a directory of markup files to html
</code></pre>
<p>Along the way, we've learned two powerful new abstractions, <code>Functor</code>
and <code>Applicative</code>, as well as revisited an abstraction
called <code>Monoid</code>. With this library, we've seen another example
of the usefulness of these abstractions for constructing APIs and EDSLs.</p>
<p>We will continue to meet these abstractions in the rest of the book.</p>
<hr />
<p><strong>Bonus exercise</strong>: Add another flag named <code>--replace</code> to indicate that
if the output file or directory already exists, replacing them is okay.</p>
<hr />
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/d0d76aad632fe3abd8701e44db5ba687e0c7ac96">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/d0d76aad632fe3abd8701e44db5ba687e0c7ac96">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors-and-multiple-files"><a class="header" href="#handling-errors-and-multiple-files">Handling errors and multiple files</a></h1>
<p>We left an unimplemented function last chapter,
and there are a few more things left for us to do to actually call our program a static blog generator.
We still need to process multiple files in a directory and create an index landing page with links to other pages.</p>
<h2 id="links-in-html"><a class="header" href="#links-in-html">Links in HTML</a></h2>
<p>Our HTML EDSL currently does not support links or other content modifiers such as bold and italics.
We should add these so we can use them when creating an index.</p>
<p>Up until now, we've passed <code>String</code> to <code>Structure</code>, creating functions such as <code>p_</code>
and <code>h_</code>. Instead, we can create and pass them a new type, <code>Content</code>, which
can be regular text, links, images, and so on.</p>
<hr />
<p><strong>Exercise</strong>: implement what we've just discussed. Follow the compiler errors and refactor what needs refactoring.</p>
<details><summary>Solution</summary>
<details><summary>src/Html/Internal.hs</summary>
<pre><code class="language-hs">module HsBlog.Html.Internal where

import Numeric.Natural

-- * Types

newtype Html
  = Html String

newtype Structure
  = Structure String

newtype Content
  = Content String

type Title
  = String

-- * EDSL

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; (escape title))
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Structure

p_ :: Content -&gt; Structure
p_ = Structure . el &quot;p&quot; . getContentString

h_ :: Natural -&gt; Content -&gt; Structure
h_ n = Structure . el (&quot;h&quot; &lt;&gt; show n) . getContentString

ul_ :: [Structure] -&gt; Structure
ul_ =
  Structure . el &quot;ul&quot; . concat . map (el &quot;li&quot; . getStructureString)

ol_ :: [Structure] -&gt; Structure
ol_ =
  Structure . el &quot;ol&quot; . concat . map (el &quot;li&quot; . getStructureString)

code_ :: String -&gt; Structure
code_ = Structure . el &quot;pre&quot; . escape

instance Semigroup Structure where
  (&lt;&gt;) c1 c2 =
    Structure (getStructureString c1 &lt;&gt; getStructureString c2)

instance Monoid Structure where
  mempty = Structure &quot;&quot;

-- * Content

txt_ :: String -&gt; Content
txt_ = Content . escape

link_ :: FilePath -&gt; Content -&gt; Content
link_ path content =
  Content $
    elAttr
      &quot;a&quot;
      (&quot;href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&quot;)
      (getContentString content)

img_ :: FilePath -&gt; Content
img_ path =
  Content $ &quot;&lt;img src=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

b_ :: Content -&gt; Content
b_ content =
  Content $ el &quot;b&quot; (getContentString content)

i_ :: Content -&gt; Content
i_ content =
  Content $ el &quot;i&quot; (getContentString content)

instance Semigroup Content where
  (&lt;&gt;) c1 c2 =
    Content (getContentString c1 &lt;&gt; getContentString c2)

instance Monoid Content where
  mempty = Content &quot;&quot;

-- * Render

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str

-- * Utilities

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

elAttr :: String -&gt; String -&gt; String -&gt; String
elAttr tag attrs content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot; &quot; &lt;&gt; attrs &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

getStructureString :: Structure -&gt; String
getStructureString structure =
  case structure of
    Structure str -&gt; str

getContentString :: Content -&gt; String
getContentString content =
  case content of
    Content str -&gt; str

escape :: String -&gt; String
escape =
  let
    escapeChar c =
      case c of
        '&lt;' -&gt; &quot;&amp;lt;&quot;
        '&gt;' -&gt; &quot;&amp;gt;&quot;
        '&amp;' -&gt; &quot;&amp;amp;&quot;
        '&quot;' -&gt; &quot;&amp;quot;&quot;
        '\'' -&gt; &quot;&amp;#39;&quot;
        _ -&gt; [c]
  in
    concat . map escapeChar


</code></pre>
</details>
<details><summary>src/Html.hs</summary>
<pre><code class="language-hs">module HsBlog.Html
  ( Html
  , Title
  , Structure
  , html_
  , p_
  , h_
  , ul_
  , ol_
  , code_
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
  where

import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/Convert.hs</summary>
<pre><code class="language-hs">module HsBlog.Convert where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html

convert :: Html.Title -&gt; Markup.Document -&gt; Html.Html
convert title = Html.html_ title . foldMap convertStructure

convertStructure :: Markup.Structure -&gt; Html.Structure
convertStructure structure =
  case structure of
    Markup.Heading n txt -&gt;
      Html.h_ n $ Html.txt_ txt

    Markup.Paragraph p -&gt;
      Html.p_ $ Html.txt_ p

    Markup.UnorderedList list -&gt;
      Html.ul_ $ map (Html.p_ . Html.txt_) list

    Markup.OrderedList list -&gt;
      Html.ol_ $ map (Html.p_ . Html.txt_) list

    Markup.CodeBlock list -&gt;
      Html.code_ (unlines list)
</code></pre>
</details>
</details>
<hr />
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/110a19029f0be42eb2ac656f5d38356dbf9c5746">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/110a19029f0be42eb2ac656f5d38356dbf9c5746">code up until now</a>.</p>
</blockquote>
<h2 id="creating-an-index-page"><a class="header" href="#creating-an-index-page">Creating an index page</a></h2>
<p>With our extended HTML EDSL, we can now create an index page with links to the other pages.</p>
<p>To create an index page, we need a list of files with their <em>target destinations</em>,
as well as their <code>Markup</code> (so we can extract information to include in our index page,
such as the first heading and paragraph). Our output should be an <code>Html</code> page.</p>
<hr />
<p>We need to implement the following function:</p>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 3 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
<hr />
<h2 id="processing-directories"><a class="header" href="#processing-directories">Processing directories</a></h2>
<p>Our general strategy for processing whole directories is going to be:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension; we want to process the <code>txt</code> files and
copy other files without modification</li>
<li>We want to parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<p>While our parsing function can't really fail, trying to read or write a file
to the file-system can fail in several ways. It would be nice if our
static blog generator was robust enough that it wouldn't fail completely if one
single file gave it some trouble. This is an excellent opportunity to learn about
error handling in Haskell, both in uneffectful code and for I/O code.</p>
<p>In the next few chapters, we'll survey the landscape of error handling in Haskell
before figuring out the right approach for our use case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-errors-with-either"><a class="header" href="#handling-errors-with-either">Handling errors with Either</a></h1>
<p>There are quite a few ways to indicate and handle errors in Haskell.
We are going to look at one solution: using the type
<a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html">Either</a>.
Either is defined like this:</p>
<pre><code class="language-hs">data Either a b
  = Left a
  | Right b
</code></pre>
<p>Simply put, a value of type <code>Either a b</code> can contain either a value of type <code>a</code>,
or a value of type <code>b</code>.
We can tell them apart from the constructor used.</p>
<pre><code class="language-hs">Left True :: Either Bool b
Right 'a' :: Either a Char
</code></pre>
<p>With this type, we can use the
<code>Left</code> constructor to indicate failure with some error value attached,
and the <code>Right</code> constructor with one type to represent success with the
expected result.</p>
<p>Since <code>Either</code> is polymorphic, we can use any two types to represent
failure and success. It is often useful to describe the failure modes
using an ADT.</p>
<p>For example, let's say that we want to parse a <code>Char</code> as a decimal digit
to an <code>Int</code>. This operation could fail if the Character is not a digit.
We can represent this error as a data type:</p>
<pre><code class="language-hs">data ParseDigitError
  = NotADigit Char
  deriving Show
</code></pre>
<p>And our parsing function can have the type:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
</code></pre>
<p>Now when we implement our parsing function, we can return <code>Left</code> on an error
describing the problem, and <code>Right</code> with the parsed value on successful parsing:</p>
<pre><code class="language-hs">parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p><code>Either a</code> is also an instance of <code>Functor</code> and <code>Applicative</code>,
so we have some combinators to work with if we want to combine these
kinds of computations.</p>
<p>For example, if we had three characters and we wanted to try and parse
each of them and then find the maximum between them; we could use the
applicative interface:</p>
<pre><code class="language-hs">max3chars :: Char -&gt; Char -&gt; Char -&gt; Either ParseDigitError Int
max3chars x y z =
  (\a b c -&gt; max a (max b c))
    &lt;$&gt; parseDigit x
    &lt;*&gt; parseDigit y
    &lt;*&gt; parseDigit z
</code></pre>
<p>The <code>Functor</code> and <code>Applicative</code> interfaces of <code>Either a</code> allow us to
apply functions to the payload values and <strong>delay</strong> the error handling to a
later phase. Semantically, the first Either in order that returns a <code>Left</code>
will be the return value. We can see how this works in the implementation
of the applicative instance:</p>
<pre><code class="language-hs">instance Applicative (Either e) where
    pure          = Right
    Left  e &lt;*&gt; _ = Left e
    Right f &lt;*&gt; r = fmap f r
</code></pre>
<p>At some point, someone will actually want to <strong>inspect</strong> the result
and see if we get an error (with the <code>Left</code> constructor) or the expected value
(with the <code>Right</code> constructor) and they can do that by pattern-matching the result.</p>
<h2 id="applicative--traversable"><a class="header" href="#applicative--traversable">Applicative + Traversable</a></h2>
<p>The <code>Applicative</code> interface of <code>Either</code> is very powerful and can be combined
with another abstraction called
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Traversable.html#g:1"><code>Traversable</code></a> -
for data structures that can be traversed from left to right, like a linked list or a binary tree.
With these, we can combine an unspecified amount of values such as <code>Either ParseDigitError Int</code>,
as long as they are all in a data structure that implements <code>Traversable</code>.</p>
<p>Let's see an example:</p>
<pre><code class="language-hs">ghci&gt; :t &quot;1234567&quot;
&quot;1234567&quot; :: String
-- remember, a String is an alias for a list of Char
ghci&gt; :info String
type String :: *
type String = [Char]
      -- Defined in ‘GHC.Base’

ghci&gt; :t map parseDigit &quot;1234567&quot;
map parseDigit &quot;1234567&quot; :: [Either ParseDigitError Int]
ghci&gt; map parseDigit &quot;1234567&quot;
[Right 1,Right 2,Right 3,Right 4,Right 5,Right 6,Right 7]

ghci&gt; :t sequenceA
sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a)
-- Substitute `t` with `[]`, and `f` with `Either Error` for a specialized version

ghci&gt; sequenceA (map parseDigit &quot;1234567&quot;)
Right [1,2,3,4,5,6,7]

ghci&gt; map parseDigit &quot;1a2&quot;
[Right 1,Left (NotADigit 'a'),Right 2]
ghci&gt; sequenceA (map parseDigit &quot;1a2&quot;)
Left (NotADigit 'a')
</code></pre>
<p>The pattern of doing <code>map</code> and then <code>sequenceA</code> is another function called <code>traverse</code>:</p>
<pre><code class="language-hs">ghci&gt; :t traverse
traverse
  :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
ghci&gt; traverse parseDigit &quot;1234567&quot;
Right [1,2,3,4,5,6,7]
ghci&gt; traverse parseDigit &quot;1a2&quot;
Left (NotADigit 'a')
</code></pre>
<p>We can use <code>traverse</code> on any two types where one implements the <code>Applicative</code>
interface, like <code>Either a</code> or <code>IO</code>, and the other implements the <code>Traversable</code> interface,
like <code>[]</code> (linked lists) and
<a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#t:Map"><code>Map k</code></a>
(also known as a dictionary in other languages - a mapping from keys to values).
For example, using <code>IO</code> and <code>Map</code>. Note that we can construct a <code>Map</code> data structure
from a list of tuples using the
<a href="https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Strict.html#v:fromList"><code>fromList</code></a>
function - the first value in the tuple is the key, and the second is the type.</p>
<pre><code class="language-hs">ghci&gt; import qualified Data.Map as M -- from the containers package

ghci&gt; file1 = (&quot;output/file1.html&quot;, &quot;input/file1.txt&quot;)
ghci&gt; file2 = (&quot;output/file2.html&quot;, &quot;input/file2.txt&quot;)
ghci&gt; file3 = (&quot;output/file3.html&quot;, &quot;input/file3.txt&quot;)
ghci&gt; files = M.fromList [file1, file2, file3]
ghci&gt; :t files :: M.Map FilePath FilePath -- FilePath is an alias of String
files :: M.Map FilePath FilePath :: M.Map FilePath FilePath

ghci&gt; readFiles = traverse readFile
ghci&gt; :t readFiles
readFiles :: Traversable t =&gt; t FilePath -&gt; IO (t String)

ghci&gt; readFiles files
fromList [(&quot;output/file1.html&quot;,&quot;I'm the content of file1.txt\n&quot;),(&quot;output/file2.html&quot;,&quot;I'm the content of file2.txt\n&quot;),(&quot;output/file3.html&quot;,&quot;I'm the content of file3.txt\n&quot;)]
ghci&gt; :t readFiles files
readFiles files :: IO (Map String String)
</code></pre>
<p>Above, we created a function <code>readFiles</code> that will take a mapping from <em>output file path</em>
to <em>input file path</em> and returns an IO operation that, when run will read the input files
and replace their contents right there in the map! Surely this will be useful later.</p>
<h2 id="multiple-errors"><a class="header" href="#multiple-errors">Multiple errors</a></h2>
<p>Note, since <code>Either</code> has the kind <code>* -&gt; * -&gt; *</code> (it takes two type
parameters) <code>Either</code> cannot be an instance of <code>Functor</code> or <code>Applicative</code>:
instances of these type classes must have the
kind <code>* -&gt; *</code>.
Remember that when we look at a type class function signature like:</p>
<pre><code class="language-hs">fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And if we want to implement it for a specific type (in place of the <code>f</code>),
we need to be able to <em>substitute</em> the <code>f</code> with the target type. If we'd try
to do it with <code>Either</code> we would get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Either a -&gt; Either b
</code></pre>
<p>And neither <code>Either a</code> or <code>Either b</code> are <em>saturated</em>, so this won't type check.
For the same reason, if we'll try to substitute <code>f</code> with, say, <code>Int</code>, we'll get:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Int a -&gt; Int b
</code></pre>
<p>Which also doesn't make sense.</p>
<p>While we can't use <code>Either</code>, we can use <code>Either e</code>, which has the kind
<code>* -&gt; *</code>. Now let's try substituting <code>f</code> with <code>Either e</code> in this signature:</p>
<pre><code class="language-hs">liftA2 :: Applicative =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>And we'll get:</p>
<pre><code class="language-hs">liftA2 :: (a -&gt; b -&gt; c) -&gt; Either e a -&gt; Either e b -&gt; Either e c
</code></pre>
<p>What this teaches us is that we can only use the applicative interface to
combine two <em><code>Either</code>s with the same type for the <code>Left</code> constructor</em>.</p>
<p>So what can we do if we have two functions that can return different errors?
There are a few approaches; the most prominent ones are:</p>
<ol>
<li>Make them return the same error type. Write an ADT that holds all possible
error descriptions. This can work in some cases but isn't always ideal.
For example, a user calling <code>parseDigit</code> shouldn't be forced to
handle a possible case that the input might be an empty string</li>
<li>Use a specialized error type for each type, and when they are composed together,
map the error type of each function to a more general error type. This can
be done with the function
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Bifunctor.html#v:first"><code>first</code></a>
from the <code>Bifunctor</code> type class</li>
</ol>
<h2 id="monadic-interface"><a class="header" href="#monadic-interface">Monadic interface</a></h2>
<p>The applicative interface allows us to lift a function to work on multiple
<code>Either</code> values (or other applicative functor instances such as <code>IO</code> and <code>Parser</code>).
But more often than not, we'd like to use a value from one computation
that might return an error in another computation that might return an error.</p>
<p>For example, a compiler such as GHC operates in stages, such as lexical analysis,
parsing, type-checking, and so on. Each stage depends on the output of the stage
before it, and each stage might fail. We can write the types for these functions:</p>
<pre><code class="language-hs">tokenize :: String -&gt; Either Error [Token]

parse :: [Token] -&gt; Either Error AST

typecheck :: AST -&gt; Either Error TypedAST
</code></pre>
<p>We want to compose these functions so that they work in a chain. The output of <code>tokenize</code>
goes to <code>parse</code>, and the output of <code>parse</code> goes to <code>typecheck</code>.</p>
<p>We know that we can lift a function over an <code>Either</code> (and other functors),
we can also lift a function that returns an <code>Either</code>:</p>
<pre><code class="language-hs">-- reminder the type of fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
-- specialized for `Either Error`
fmap :: (a -&gt; b) -&gt; Either Error a -&gt; Either Error b

-- here, `a` is [Token] and `b` is `Either Error AST`:

&gt; fmap parse (tokenize string) :: Either Error (Either Error AST)
</code></pre>
<p>While this code compiles, it isn't great, because we are building
layers of <code>Either Error</code>, and we can't use this trick again with
<code>typecheck</code>! <code>typecheck</code> expects an <code>AST</code>, but if we try to fmap it
on <code>fmap parse (tokenize string)</code>, the <code>a</code> will be <code>Either Error AST</code>
instead.</p>
<p>What we would really like is to flatten this structure instead of nesting it.
If we look at the kind of values <code>Either Error (Either Error AST)</code> could have,
it looks something like this:</p>
<ul>
<li><code>Left &lt;error&gt;</code></li>
<li><code>Right (Left error)</code></li>
<li><code>Right (Right &lt;ast&gt;)</code></li>
</ul>
<hr />
<p><strong>Exercise</strong>: What if we just used pattern matching for this instead? What would this look like?</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">case tokenize string of
  Left err -&gt;
    Left err
  Right tokens -&gt;
    case parse tokens of
      Left err -&gt;
        Left err
      Right ast -&gt;
        typecheck ast
</code></pre>
<p>If we run into an error in a stage, we return that error and stop. If we succeed, we
use the value in the next stage.</p>
</details>
<hr />
<p>Flattening this structure for <code>Either</code> is very similar to that last part - the body
of the <code>Right tokens</code> case:</p>
<pre><code class="language-hs">flatten :: Either e (Either e a) -&gt; Either e a
flatten e =
  case e of
    Left l -&gt; Left l
    Right x -&gt; x
</code></pre>
<p>Because we have this function, we can now use it on the output of
<code>fmap parse (tokenize string) :: Either Error (Either Error AST)</code>
from before:</p>
<pre><code>&gt; flatten (fmap parse (tokenize string)) :: Either Error AST
</code></pre>
<p>And now, we can use this function again to compose with <code>typecheck</code>:</p>
<pre><code class="language-hs">&gt; flatten (fmap typecheck (flatten (fmap parse (tokenize string)))) :: Either Error TypedAST
</code></pre>
<p>This <code>flatten</code> + <code>fmap</code> combination looks like a recurring pattern which
we can combine into a function:</p>
<pre><code class="language-hs">flatMap :: (a -&gt; Either e b) -&gt; Either a -&gt; Either b
flatMap func val = flatten (fmap func val)
</code></pre>
<p>And now, we can write the code this way:</p>
<pre><code class="language-hs">&gt; flatMap typecheck (flatMap parse (tokenize string)) :: Either Error TypedAST

-- Or using backticks syntax to convert the function to infix form:
&gt; typecheck `flatMap` parse `flatMap` tokenize string

-- Or create a custom infix operator: (=&lt;&lt;) = flatMap
&gt; typeCheck =&lt;&lt; parse =&lt;&lt; tokenize string
</code></pre>
<p>This function, <code>flatten</code> (and <code>flatMap</code> as well), have different names in Haskell.
They are called
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:join"><code>join</code></a>
and <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-61--60--60-"><code>=&lt;&lt;</code></a>
(pronounced &quot;reverse bind&quot;),
and they are the essence of another incredibly useful abstraction in Haskell.</p>
<p>If we have a type that can implement:</p>
<ol>
<li>The <code>Functor</code> interface, specifically the <code>fmap</code> function</li>
<li>The <code>Applicative</code> interface, most importantly the <code>pure</code> function</li>
<li>This <code>join</code> function</li>
</ol>
<p>They can implement an instance of the <code>Monad</code> type class.</p>
<p>With functors, we were able to &quot;lift&quot; a function to work over the type implementing the functor type class:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>With applicative functors we were able to &quot;lift&quot; a function of multiple arguments
over multiple values of a type implementing the applicative functor type class,
and also lift a value into that type:</p>
<pre><code class="language-hs">pure :: a -&gt; f a

liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<p>With monads we can now flatten (or &quot;join&quot; in Haskell terminology) types that implement
the <code>Monad</code> interface:</p>
<pre><code class="language-hs">join :: m (m a) -&gt; m a

-- this is =&lt;&lt; with the arguments reversed, pronounced &quot;bind&quot;
(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>With <code>&gt;&gt;=</code>, we can write our compilation pipeline from before in a left-to-right
manner, which seems to be more popular for monads:</p>
<pre><code class="language-hs">&gt; tokenize string &gt;&gt;= parse &gt;&gt;= typecheck
</code></pre>
<p>We had already met this function before when we talked about <code>IO</code>. Yes,
<code>IO</code> also implements the <code>Monad</code> interface. The monadic interface for <code>IO</code>
helped us with creating a proper ordering of effects.</p>
<p>The essence of the <code>Monad</code> interface is the <code>join</code>/<code>&gt;&gt;=</code> functions, and as we've seen
we can implement <code>&gt;&gt;=</code> in terms of <code>join</code>, we can also implement <code>join</code> in terms
of <code>&gt;&gt;=</code> (try it!).</p>
<p>The monadic interface can mean very different things for different types. For <code>IO</code> this
is ordering of effects, for <code>Either</code> it is early cutoff,
for <a href="https://hackage.haskell.org/package/logict-0.7.1.0"><code>Logic</code></a> this means backtracking computation, etc.</p>
<p>Again, don't worry about analogies and metaphors; focus on the API and the
<a href="https://wiki.haskell.org/Monad_laws">laws</a>.</p>
<blockquote>
<p>Hey, did you check the monad laws? left identity, right identity, and associativity? We've already
discussed a type class with exactly these laws - the <code>Monoid</code> type class. Maybe this is related
to the famous quote about monads being just monoids in something something...</p>
</blockquote>
<h3 id="do-notation-1"><a class="header" href="#do-notation-1">Do notation?</a></h3>
<p>Remember the <a href="06-errors_and_files/../05-glue/02-io.html#do-notation">do notation</a>? It turns out it works for any type that is
an instance of <code>Monad</code>. How cool is that? Instead of writing:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string =
  tokenize string &gt;&gt;= \tokens -&gt;
    parse tokens &gt;&gt;= \ast -&gt;
      typecheck ast
</code></pre>
<p>We can write:</p>
<pre><code class="language-hs">pipeline :: String -&gt; Either Error TypedAST
pipeline string = do
  tokens &lt;- tokenize string
  ast &lt;- parse tokens
  typecheck ast
</code></pre>
<p>And it will work! Still, in this particular case, <code>tokenize string &gt;&gt;= parse &gt;&gt;= typecheck</code>
is so concise it can only be beaten by using
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-62--61--62-">&gt;=&gt;</a>
or
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Monad.html#v:-60--61--60-">&lt;=&lt;</a>:</p>
<pre><code class="language-hs">(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
(&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c

-- compare with function composition:
(.) ::              (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
</code></pre>
<pre><code class="language-hs">pipeline  = tokenize &gt;=&gt; parse &gt;=&gt; typecheck
</code></pre>
<p>or</p>
<pre><code class="language-hs">pipeline = typecheck &lt;=&lt; parse &lt;=&lt; tokenize
</code></pre>
<p>Haskell's ability to create very concise code using abstractions is
great once one is familiar with the abstractions. Knowing the monad abstraction,
we are now already familiar with the core composition API of many libraries - for example:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/stm">Concurrent</a>
and <a href="https://hackage.haskell.org/package/async">asynchronous programming</a></li>
<li><a href="https://gilmi.me/blog/post/2020/12/05/scotty-bulletin-board">Web programming</a></li>
<li><a href="http://hspec.github.io/">Testing</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-State-Lazy.html#g:2">Emulating stateful computation</a></li>
<li><a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2">sharing environment between computations</a></li>
<li>and many more.</li>
</ul>
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Using <code>Either</code> for error handling is useful for two reasons:</p>
<ol>
<li>We encode possible errors using types, and we <strong>force users to acknowledge and handle</strong> them, thus
making our code more resilient to crashes and bad behaviours</li>
<li>The <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> interfaces provide us with mechanisms for
<strong>composing</strong> functions that might fail (almost) effortlessly - reducing boilerplate while
maintaining strong guarantees about our code and delaying the need to handle errors until
it is appropriate</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="either-with-io"><a class="header" href="#either-with-io">Either with IO?</a></h1>
<p>When we create <code>IO</code> actions that may require I/O, we risk running into all kinds of errors.
For example, when we use <code>writeFile</code>, we could run out of disk space in the middle of writing,
or the file might be write-protected. While these scenarios aren't super common, they are definitely
possible.</p>
<p>We could've potentially encoded Haskell functions like <code>readFile</code> and <code>writeFile</code> as <code>IO</code> operations
that return <code>Either</code>, for example:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; IO (Either ReadFileError String)
writeFile :: FilePath -&gt; String -&gt; IO (Either WriteFileError ())
</code></pre>
<p>However, there are a couple of issues here; the first is that composing <code>IO</code> actions
becomes more difficult. Previously we could write:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;output.html&quot;
</code></pre>
<p>But now the types no longer match - <code>readFile</code> will return an <code>Either ReadFileError String</code> when executed,
but <code>writeFile</code> wants to take a <code>String</code> as input. We are forced to handle the error
before calling <code>writeFile</code>.</p>
<h2 id="composing-io--either-using-exceptt"><a class="header" href="#composing-io--either-using-exceptt">Composing IO + Either using ExceptT</a></h2>
<p>One way to handle this is by using <strong>monad transformers</strong>. Monad transformers provide a way
to stack monad capabilities on top of one another. They are called transformers because
<strong>they take a type that has an instance of monad as input and return a new type that
implements the monad interface, stacking a new capability on top of it</strong>.</p>
<p>For example, if we want to compose values of a type that is equivalent to <code>IO (Either Error a)</code>,
using the monadic interface (the function <code>&gt;&gt;=</code>), we can use a monad transformer
called <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Except.html#g:2"><code>ExceptT</code></a>
and stack it over <code>IO</code>.
Let's see how <code>ExceptT</code> is defined:</p>
<pre><code class="language-hs">newtype ExceptT e m a = ExceptT (m (Either e a))
</code></pre>
<p>Remember, a <code>newtype</code> is a new name for an existing type. And if we substitute
<code>e</code> with <code>Error</code> and <code>m</code> with <code>IO</code>, we get exactly <code>IO (Either Error a)</code> as we wanted.
And we can convert an <code>ExceptT Error IO a</code> into <code>IO (Either Error a)</code> using
the function <code>runExceptT</code>:</p>
<pre><code class="language-hs">runExceptT :: ExceptT e m a -&gt; m (Either e a)
</code></pre>
<p><code>ExceptT</code> implements the monadic interface in a way that combines the capabilities of
<code>Either</code>, and whatever <code>m</code> it takes. Because <code>ExceptT e m</code> has a <code>Monad</code> instance,
a specialized version of <code>&gt;&gt;=</code> would look like this:</p>
<pre><code class="language-hs">-- Generalized version
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b

-- Specialized version, replace the `m` above with `ExceptT e m`.
(&gt;&gt;=) :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b
</code></pre>
<p>Note that the <code>m</code> in the specialized version still needs to be an instance of <code>Monad</code>.</p>
<hr />
<p>Unsure how this works? Try to implement <code>&gt;&gt;=</code> for <code>IO (Either Error a)</code>:</p>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
</code></pre>
<details><summary>Solution</summary>
<pre><code class="language-hs">bindExceptT :: IO (Either Error a) -&gt; (a -&gt; IO (Either Error b)) -&gt; IO (Either Error b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either Error a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>Note that we didn't actually use the implementation details of <code>Error</code> or <code>IO</code>,
<code>Error</code> isn't mentioned at all, and for <code>IO</code>, we only used the monadic interface with
the do notation. We could write the same function with a more generalized type signature:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; m (Either e a) -&gt; (a -&gt; m (Either e b)) -&gt; m (Either e b)
bindExceptT mx f = do
  x &lt;- mx -- `x` has the type `Either e a`
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; f y
</code></pre>
<p>And because <code>newtype ExceptT e m a = ExceptT (m (Either e a))</code>, we can just
pack and unpack that <code>ExceptT</code> constructor and get:</p>
<pre><code class="language-hs">bindExceptT :: Monad m =&gt; ExceptT e m a -&gt; (a -&gt; ExceptT e m b) -&gt; ExceptT e m b
bindExceptT mx f = ExceptT $ do
  -- `runExceptT mx` has the type `m (Either e a)`
  -- `x` has the type `Either e a`
  x &lt;- runExceptT mx
  case x of
    Left err -&gt; pure (Left err)
    Right y -&gt; runExceptT (f y)
</code></pre>
</details>
<hr />
<blockquote>
<p>Note that when stacking monad transformers, the order in which we stack them matters.
With <code>ExceptT Error IO a</code>, we have an <code>IO</code> operation that, when run will return <code>Either</code>
an error or a value.</p>
</blockquote>
<p><code>ExceptT</code> can enjoy both worlds - we can return error values using the function <code>throwError</code>:</p>
<pre><code class="language-hs">throwError :: e -&gt; ExceptT e m a
</code></pre>
<p>and we can &quot;lift&quot; functions that return a value of the underlying monadic type <code>m</code> to return
a value of <code>ExceptT e m a</code> instead:</p>
<pre><code class="language-hs">lift :: m a -&gt; ExceptT e m a
</code></pre>
<p>for example:</p>
<pre><code class="language-hs">getLine :: IO String

lift getLine :: ExceptT e IO String
</code></pre>
<blockquote>
<p>Actually, <code>lift</code> is also a type class function from <code>MonadTrans</code>, the type class
of monad transformers. So technically, <code>lift getLine :: MonadTrans t =&gt; t IO String</code>,
but we are specializing for concreteness.</p>
</blockquote>
<p>Now, if we had:</p>
<pre><code class="language-hs">readFile :: FilePath -&gt; ExceptT IOError IO String

writeFile :: FilePath -&gt; String -&gt; ExceptT IOError IO ()
</code></pre>
<p>We could compose them again without issue:</p>
<pre><code class="language-hs">readFile &quot;input.txt&quot; &gt;&gt;= writeFile &quot;output.html&quot;
</code></pre>
<p>But remember - the error type <code>e</code> (in both the case <code>Either</code> and <code>Except</code>)
must be the same between composed functions! This means that the type representing
errors for both <code>readFile</code> and <code>writeFile</code> must be the same - that would also
force anyone using these functions to handle these errors - should a user who
called <code>writeFile</code> be required to handle a &quot;file not found&quot; error? Should a user
who called <code>readFile</code> be required to handle an &quot;out of disk space&quot; error?
There are many, many more possible IO errors! &quot;network unreachable&quot;, &quot;out of memory&quot;,
&quot;cancelled thread&quot;, we cannot require a user to handle all these errors, or
even cover them all in a data type.</p>
<p>So what do we do?</p>
<p>We give up on this approach <strong>for IO code</strong>, and use a different one: Exceptions,
as we'll see in the next chapter.</p>
<blockquote>
<p>Note - when we stack <code>ExceptT</code> on top of a different type called
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor-Identity.html"><code>Identity</code></a>
that also implements the <code>Monad</code> interface, we get a type that is exactly like <code>Either</code>
called <a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Except.html#t:Except"><code>Except</code></a>
(without the <code>T</code> at the end). You might sometimes want to use <code>Except</code> instead of <code>Either</code>
because it has a more appropriate name and better API for error handling than <code>Either</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h1>
<p>The <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html">Control.Exception</a>
module provides us with the ability to
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:throwIO">throw</a>
exceptions from <code>IO</code> code,
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#g:5"><code>catch</code></a>
Haskell exceptions in <code>IO</code> code, and even convert them to <code>IO (Either ...)</code>
with the function <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#g:7"><code>try</code></a>:</p>
<pre><code class="language-hs">throwIO :: Exception e =&gt; e -&gt; IO a

catch
  :: Exception e
  =&gt; IO a         -- The computation to run
  -&gt; (e -&gt; IO a)  -- Handler to invoke if an exception is raised
  -&gt; IO a

try :: Exception e =&gt; IO a -&gt; IO (Either e a)
</code></pre>
<p>The important part of these type signatures is the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#t:Exception"><code>Exception</code></a>
type class. By making a type an instance of the <code>Exception</code> type class, we can throw it
and catch it in <code>IO</code> code:</p>
<pre><code class="language-hs">{-# language LambdaCase #-}

import Control.Exception
import System.IO

data MyException
  = ErrZero
  | ErrOdd Int
  deriving Show

instance Exception MyException

sayDiv2 :: Int -&gt; IO ()
sayDiv2 n
  | n == 0 = throwIO ErrZero
  | n `mod` 2 /= 0 = throwIO (ErrOdd n)
  | otherwise = print (n `div` 2)

main :: IO ()
main =
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
    )
</code></pre>
<blockquote>
<p>Note: we are using two new things here: guards and the <code>LambdaCase</code> language extension.</p>
<ol>
<li>
<p>Guards, as seen in <code>sayDiv2</code> are just a nicer syntax around <code>if-then-else</code> expressions.
Using guards, we can have multiple <code>if</code> branches and finally use the <code>else</code> branch
by using <code>otherwise</code>. After each guard (<code>|</code>), there's a condition; after the condition, there's
a <code>=</code> and then the expression (the part after <code>then</code> in an <code>if</code> expression)</p>
</li>
<li>
<p>LambdaCase, as seen in <code>catch</code>, is just a syntactic sugar to save a few characters,
instead of writing <code>\e -&gt; case e of</code>, we can write <code>\case</code>. It requires enabling the
<code>LambdaCase</code> extension</p>
<h4 id="language-extensions"><a class="header" href="#language-extensions">Language extensions</a></h4>
<p>Haskell is a standardized language. However, GHC provides <em>extensions</em> to the language -
additional features that aren't covered in the 98 or 2010 standards of Haskell.
Features such as syntactic extensions (like LambdaCase above), extensions to the type checker,
and more.</p>
<p>These extensions can be added by adding <code>{-# language &lt;extension-name&gt; #-}</code>
(the <code>language</code> part is case insensitive)
to the top of a Haskell source file, or they can be set globally for an entire project by
specifying them in the
<a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-default-extensions">default-extensions</a>
section in the <code>.cabal file</code>.</p>
<p>The list of language extensions can be found in the
<a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts.html">GHC manual</a>,
feel free to browse it, but don't worry about trying to memorize all the extensions.</p>
</li>
</ol>
</blockquote>
<p>Of course, this example would work much better using <code>Either</code> and separating
the division and printing à la 'functional core, imperative shell'. But as an example, it works.
We created a custom exception and handled it specifically outside an <code>IO</code> block.
However, we have not handled exceptions that might be raised by <code>putStrLn</code>.
What if, for example, for some reason, we close the <code>stdout</code> handle before this block:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
    )
</code></pre>
<p>Our program will crash with an error:</p>
<pre><code>ghc: &lt;stdout&gt;: hFlush: illegal operation (handle is closed)
</code></pre>
<p>First, how do we know which exception we should handle? Some functions' documentation
include this, but unfortunately, <code>putStrLn</code>'s does not. We could guess from the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#i:Exception">list of instances</a>
the <code>Exception</code> type class has; I think
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/GHC-IO-Exception.html#t:IOException"><code>IOException</code></a> fits. Now, how can we handle this case as well? We can chain catches:</p>
<pre><code class="language-hs">-- need to add these at the top

{-# language ScopedTypeVariables #-}

import GHC.IO.Exception (IOException(..))

main :: IO ()
main = do
  hClose stdout
  catch
    ( catch
      ( do
        putStrLn &quot;Going to print a number now.&quot;
        sayDiv2 7
        putStrLn &quot;Did you like it?&quot;
      )
      ( \case
        ErrZero -&gt;
          hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
        ErrOdd n -&gt;
          hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)
      )
    )
    ( \(e :: IOException) -&gt;
      -- we can check if the error was an illegal operation on the stderr handle
      if ioe_handle e /= Just stderr &amp;&amp; ioe_type e /= IllegalOperation
        then pure () -- we can't write to stderr because it is closed
        else hPutStrLn stderr (displayException e)
    )
</code></pre>
<blockquote>
<p>We use the <code>ScopedTypeVariables</code> to be able to specify types inside let expressions,
lambdas, pattern matching, and more.</p>
</blockquote>
<p>Or we could use the convenient function
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:catches"><code>catches</code></a>
to pass a list of exception
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#t:Handler">handlers</a>:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catches
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    [ Handler $ \case
      ErrZero -&gt;
        hPutStrLn stderr &quot;Error: we don't support dividing zeroes for some reason&quot;
      ErrOdd n -&gt;
        hPutStrLn stderr (&quot;Error: &quot; &lt;&gt; show n &lt;&gt; &quot; is odd and cannot be divided by 2&quot;)

    , Handler $ \(e :: IOException) -&gt;
      -- we can check if the error was an illegal operation on the stderr handle
      if ioe_handle e /= Just stderr &amp;&amp; ioe_type e /= IllegalOperation
        then pure () -- we can't write to stderr because it is closed
        else hPutStrLn stderr (displayException e)
    ]
</code></pre>
<blockquote>
<p>As an aside, <code>Handler</code> uses a concept called
<a href="https://en.m.wikibooks.org/wiki/Haskell/Existentially_quantified_types">existentially quantified types</a>
to hide inside it a function that takes an arbitrary type that implements <code>Exception</code>.
This is why we can encode a seemingly heterogeneous list of functions that handle exceptions
for <code>catches</code> to take as input.
This pattern is rarely useful, but I've included it here to avoid confusion.</p>
</blockquote>
<p>And if we wanted to catch any exception, we'd catch <code>SomeException</code>:</p>
<pre><code class="language-hs">main :: IO ()
main = do
  hClose stdout
  catch
    ( do
      putStrLn &quot;Going to print a number now.&quot;
      sayDiv2 7
      putStrLn &quot;Did you like it?&quot;
    )
    ( \(SomeException e) -&gt;
      hPutStrLn stderr (show e)
    )
</code></pre>
<p>This could also go in <code>catches</code> as the last element in the list if we wanted specialized
handling for other scenarios.</p>
<p>A couple more functions worth knowing are
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:bracket"><code>bracket</code></a>
and <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Exception.html#v:finally"><code>finally</code></a>.
These functions can help us handle resource acquisition more safely when errors are present.</p>
<hr />
<p>In our <code>main</code> in the <code>app/Main.hs</code> file, we do a small ritual of opening and closing handles.
Are there scenarios where we would clean-up after ourselves (meaning, close handles we've
opened)? Which parts of the code could throw an exception? Which handles won't get closed?</p>
<ul>
<li>Try to use <code>bracket</code> to make sure we always close a handle afterward, even if an exception
is thrown, and avoid closing the handle for the <code>stdin</code> and <code>stdout</code> cases<details><summary>Hint</summary>We might need to use continuation-passing style,
passing a function that takes a parameter to a function that produces a parameter
and calls it with that parameter.
</details>
</li>
<li>How can we avoid duplicating the <code>outputHandle</code> code for the <code>Stdin</code> and <code>InputFile</code>
branches? <details><summary>Hint</summary> Use <code>let</code>.</details></li>
</ul>
<details><summary>Answer</summary>
<pre><code class="language-hs">import Control.Exception (bracket)

main :: IO ()
main = do
...

    ConvertSingle input output -&gt;
      let
        -- Here, action is the next steps we want to do.
        -- It takes as input the values we produce,
        -- uses it, and then returns control for us to clean-up
        -- afterwards.
        withInputHandle :: (String -&gt; Handle -&gt; IO a) -&gt; IO a
        withInputHandle action =
          case input of
            Stdin -&gt;
              action &quot;&quot; stdin
            InputFile file -&gt;
              bracket
                (openFile file ReadMode)
                hClose
                (action file)

        -- Note that in both functions our action can return any `a`
        -- it wants.
        withOutputHandle :: (Handle -&gt; IO a) -&gt; IO a
        withOutputHandle action =
          case output of
            Stdout -&gt;
              action stdout
            OutputFile file -&gt; do
              exists &lt;- doesFileExist file
              shouldOpenFile &lt;-
                if exists
                  then confirm
                  else pure True
              if shouldOpenFile
                then
                  bracket (openFile file WriteMode) hClose action
                else
                  exitFailure
      in
        withInputHandle (\title -&gt; withOutputHandle . HsBlog.convertSingle title)
</code></pre>
</details>
<p>There's actually a custom function that does a similar thing to
<code>bracket (openFile file &lt;mode&gt;) hClose</code>, it's called
<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/System-IO.html#v:withFile">withFile</a>.
Keep an eye out for functions that start with the prefix <code>with</code>; they are probably using the
same pattern of continuation-passing style.</p>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Exceptions are useful and often necessary when we work with <code>IO</code> and want to make sure
our program is handling errors gracefully. They have an advantage over <code>Either</code> in that
we can easily compose functions that may throw errors of different types, but also have
a disadvantage of not encoding types as return values, and therefore does not force us
to handle them.</p>
<p>For Haskell, the language designers have made a choice for us by designing <code>IO</code> to
use exceptions instead of <code>Either</code>. And this is what I would recommend for
handling your own effectful computations. However, I think that <code>Either</code> is more
appropriate for uneffectful code, because it forces us to acknowledge and handle errors
(eventually), thus making our programs more robust. And also because we can only
catch exceptions in <code>IO</code> code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-code-already"><a class="header" href="#lets-code-already">Let's code already!</a></h1>
<p>This was a long info dump. Let's practice what we've learned. We want to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension</li>
<li>Process .txt files</li>
<li>Copy other files without modification</li>
<li>Parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<blockquote>
<p>Note: I did not write this code immediately in the final form it was presented.
It was an iterative process of writing code, refactoring, splitting functions, changing
type signatures, and more. When solving a coding problem, start small and simple,
do the thing that works, and refactor it when it makes sense and makes the code clearer
and more modular. In Haskell, we pride ourselves in our ability to refactor code and improve
it over time, and that principle holds when writing new software as well!</p>
</blockquote>
<h2 id="new-module"><a class="header" href="#new-module">New module</a></h2>
<p>Let's create a new module, <code>HsBlog.Directory</code>, which will be responsible for handling
directories and multiple files. From this module, we will export the <code>convertDirectory</code>
and <code>buildIndex</code> functions we've defined before:</p>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
</code></pre>
<p>In this module, we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html">directory</a>
and <a href="https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html">filepath</a>
libraries to manipulate directories, files, and file paths.
We'll use the new abstractions we've learned, <code>Traversable</code> and <code>Monad</code>, and the concepts
and types we've learned about: <code>Either</code>, <code>IO</code>, and exceptions.</p>
<p>For all of that, we need quite a few imports:</p>
<pre><code class="language-hs">import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
</code></pre>
<p>If you are unsure what a specific function we're using does, look it up at
<a href="https://hoogle.haskell.org/">Hoogle</a>,
read the type signature and the documentation, and play around with it in <code>ghci</code>.</p>
<h2 id="converting-a-directory"><a class="header" href="#converting-a-directory">Converting a directory</a></h2>
<p>We can start by describing the high-level function <code>convertDirectory</code>, which
encapsulates many smaller functions, each responsible for doing a specific thing.
<code>convertDirectory</code> is quite imperative looking, and looks like a different way to
describe the steps of completing our task:</p>
<pre><code class="language-hs">-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>Here we trust that each <code>IO</code> function handles errors responsibly,
and terminates the project when necessary.</p>
<p>Let's examine the steps in order.</p>
<h3 id="getdirfilesandcontent"><a class="header" href="#getdirfilesandcontent"><code>getDirFilesAndContent</code></a></h3>
<pre><code class="language-hs">-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents

</code></pre>
<p><code>getDirFilesAndContent</code> is responsible for providing the relevant files for processing --
both the ones we need to convert to markup (and their textual content) and other files we
might want to copy as-is (such as images and style-sheets):</p>
<pre><code class="language-hs">-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
</code></pre>
<p>This function does 4 important things:</p>
<ol>
<li>Lists all the files in the directory</li>
<li>Splits the files into 2 groups according to their file extension</li>
<li>Reads the contents of the .txt files and reports when files fail to be read</li>
<li>Returns the results. We've defined a data type to make the result content more obvious</li>
</ol>
<p>Part (3) is a little bit more involved than the rest; let's explore it.</p>
<h4 id="applyioonlist"><a class="header" href="#applyioonlist"><code>applyIoOnList</code></a></h4>
<hr />
<p><code>applyIoOnList</code> has the following type signature:</p>
<pre><code class="language-hs">applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
</code></pre>
<p>It tries to apply an <code>IO</code> function on a list of values and document successes and failures.</p>
<p>Try to implement it! If you need a hint for which functions to use, see the import list
we wrote earlier.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -&gt; do
    maybeResult &lt;-
      catch
        (Right &lt;$&gt; action input)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)
</code></pre>
</details>
<hr />
<p><code>applyIoOnList</code> is a higher-order function that applies a particular <code>IO</code> function
(in our case, <code>readFile</code>) on a list of things (in our case, <code>FilePath</code>s).
For each thing, it returns the thing itself along with the result of
applying the <code>IO</code> function as an <code>Either</code>, where the <code>Left</code> side is a <code>String</code>
representation of an error if one occurred.</p>
<p>Notice how much the type of this function tells us about what it might do.
Because the types are polymorphic, there is nothing else to do with
the <code>a</code>s other than apply them to the function, and nowhere to generate <code>b</code>
from other than the result of the function.</p>
<blockquote>
<p>Note: when I first wrote this function, it was specialized to work only on <code>readFile</code>,
take specifically <code>[FilePath]</code> and return <code>IO [(FilePath, Either String String)]</code>.
But after running into other use cases where I could use it (<code>writeFiles</code> and <code>copyFiles</code>)
I refactored out the <code>action</code>, the input type, and the return type.</p>
</blockquote>
<p>This function uses exceptions to catch any error that might be thrown and encodes
both the failure and success cases in the type system using <code>Either</code>, delaying
the handling of exceptions to the function caller while making sure it won't
be forgotten!</p>
<p>Next, let's look at the function that handles the errors by reporting and then filtering out
all the cases that failed.</p>
<h4 id="filterandreportfailures"><a class="header" href="#filterandreportfailures"><code>filterAndReportFailures</code></a></h4>
<hr />
<p><code>filterAndReportFailures</code> has the following type signature:</p>
<pre><code class="language-hs">filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
</code></pre>
<p>It filters out unsuccessful operations on files and reports errors to the stderr.</p>
<p>Try to implement it!</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]
</code></pre>
<p>This code may seem a bit surprising - how come we can use <code>foldMap</code> here? Reminder,
the type of <code>foldMap</code> is:</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</code></pre>
<p>If we specialize this function for our use case, substituting the general type
with the types we are using, we learn that <code>IO [(a, b)]</code> is a monoid.
And indeed - <code>[a]</code> is a monoid for any <code>a</code> with <code>[]</code> (the empty list) as <code>mempty</code>
and <code>++</code> as <code>&lt;&gt;</code>, but also <code>IO a</code> is a monoid for any <code>a</code> that is itself
a monoid with <code>pure mempty</code> as <code>mempty</code> and <code>liftA2 (&lt;&gt;)</code> as <code>&lt;&gt;</code>!</p>
<p>Using these instances, we can <code>map</code> over the content, handle errors, and return
an empty list to filter out a failed case, or a singleton list to keep the result.
And the <code>fold</code> in <code>foldMap</code> will concatenate the resulting list where we return
all of the successful cases!</p>
<p>If you've written this in a different way that does the same thing, that's fine too!
It's just nice to see how sometimes abstractions can be used to write concise code.</p>
</details>
<hr />
<p>These functions are responsible for fetching the right information. Next,
let's look at the code for creating a new directory.</p>
<h3 id="createoutputdirectoryorexit"><a class="header" href="#createoutputdirectoryorexit"><code>createOutputDirectoryOrExit</code></a></h3>
<pre><code class="language-hs">-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
</code></pre>
<p><code>createOutputDirectoryOrExit</code> itself is not terribly exciting; it does
what it is named -- it tries to create the output directory and exits the
program in case it didn't succeed.</p>
<p><code>createOutputDirectory</code> is the function that actually does the heavy lifting.
It checks if the directory already exists, and checks if the user would like to
override it. If they do, we remove it and create a new directory; if they don't,
we do nothing and report their decision.</p>
<h3 id="txtstorenderedhtml"><a class="header" href="#txtstorenderedhtml"><code>txtsToRenderedHtml</code></a></h3>
<pre><code class="language-hs">let
  outputHtmls = txtsToRenderedHtml filesToProcess
</code></pre>
<hr />
<p>In this part of the code, we convert files to markup and change the
input file paths to their respective output file paths (<code>.txt</code> -&gt; <code>.html</code>).
We then build the index page and convert everything to HTML.</p>
<p>Implement <code>txtsToRenderedHtml</code>, which has the following type signature:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
</code></pre>
<details><summary>Hint</summary>
<p>I implemented this by defining three functions:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
</code></pre>
</details>
<p>.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
</code></pre>
<p>One possibly surprising thing about this code could be the <code>map (fmap Html.render)</code>
part. We can use <code>fmap</code> on the tuple because it is a <code>Functor</code> on the second
argument, just like <code>Either</code>!</p>
</details>
<hr />
<h3 id="copyfiles-and-writefiles"><a class="header" href="#copyfiles-and-writefiles"><code>copyFiles</code> and <code>writeFiles</code></a></h3>
<p>The only thing left to do is to write the directory
content, after the processing is completed, to the newly created directory:</p>
<pre><code class="language-hs">-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Here we use <code>applyIoOnList</code> again to do something a bit more complicated,
instead of reading from a file, it copies from the input path to a newly generated
output path. Then we pass the result (which has the type <code>[(FilePath, Either String ())]</code>)
to <code>filterAndReportFailures</code> to print the errors and filter out the unsuccessful copies.
Because we are not really interested in the output of <code>filterAndReportFailures</code>,
we discard it with <code>void</code>, returning <code>()</code> as a result instead:</p>
<pre><code class="language-hs">-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Once again, this code looks almost exactly like <code>copyFiles</code>, but the types are different.
Haskell's combination of parametric polymorphism + type class for abstractions is really
powerful, and has helped us reduce quite a bit of code.</p>
<hr />
<p>This pattern of using <code>applyIoOnList</code> and then <code>filterAndReportFailures</code>
happens more than once. It might be a good candidate for refactoring. Try it!
What do you think about the resulting code? Is it easier or more difficult to
understand? Is it more modular or less? What are the pros and cons?</p>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>With that, we have completed our <code>HsBlog.Directory</code> module, which is responsible for converting
a directory safely. Note that the code could probably be simplified quite a bit if we
were fine with errors crashing the entire program altogether, but sometimes this is
the price we pay for robustness. It is up to you to choose what you can live with
and what not, but I hope this saga has taught you how to approach error handling
in Haskell in case you need to.</p>
<p>View the full module:</p>
<details><summary>HsBlog.Directory</summary>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;

------------------------------------
-- * Read directory content

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

------------------------------------
-- * Build index page

buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )

------------------------------------
-- * Conversion

-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * Output to directory

-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures

-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures

------------------------------------
-- * IO work and handling errors

-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -&gt; do
    maybeResult &lt;-
      catch
        (Right &lt;$&gt; action input)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)

-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]

------------------------------------
-- * Utilities

confirm :: String -&gt; IO Bool
confirm question = do
  putStrLn (question &lt;&gt; &quot; (y/n)&quot;)
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. Use y or n.&quot;
      confirm question

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-10"><a class="header" href="#summary-10">Summary</a></h1>
<p>This was quite a section. Let's recount the things we've learned.</p>
<p>We discussed several ways to handle errors in Haskell:</p>
<ol>
<li>Encoding errors as a data type and using the <code>Either</code> type to encode &quot;a value or an error&quot;.
Useful approach for uneffectful code</li>
<li>Using <code>ExceptT</code> when we want to combine the approach in (1) on top of an existing
type with monadic capabilities</li>
<li>Using exceptions for IO code</li>
</ol>
<p>We've also learned a few new abstractions and techniques:</p>
<ol>
<li>The <code>Traversable</code> type class, for data structures that can be traversed from left to right, 
such as linked lists, binary trees and <code>Map</code>s.
Pretty useful when combined with another applicative functor type like <code>Either</code> or <code>IO</code></li>
<li>The <code>Monad</code> type class extends the <code>Applicative</code> type class with the <code>join :: m (m a) -&gt; m a</code>
function. We learned that <code>Either</code> implements this type class interface, and so does <code>IO</code></li>
<li>The <code>MonadTrans</code> type class for <em>monad transformers</em> for types that take other monads as inputs
and provide a monadic interface (<code>&gt;&gt;=</code>, do notation, etc.) while combining both their capabilities.
We saw how to stack an <code>Either</code>-like monad transformer, <code>ExceptT</code>, on top of <code>IO</code></li>
</ol>
<p>We are almost done – only a couple more things left to do with this project. Let's go!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/a08d148d981fa00cb7025f1b651d7b75084dd1ae">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/a08d148d981fa00cb7025f1b651d7b75084dd1ae">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-environment-variables"><a class="header" href="#passing-environment-variables">Passing environment variables</a></h1>
<p>We'd like to add some sort of an environment to keep general information on
the blog for various processings, such as the blog name, stylesheet
location, and so on.</p>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<p>We can represent our environment as a record data type and build it from user input.
The user input can be from command-line arguments, a configuration file,
or something else:</p>
<pre><code class="language-hs">module HsBlog.Env where

data Env
  = Env
    { eBlogName :: String
    , eStylesheetPath :: FilePath
    }
  deriving Show

defaultEnv :: Env
defaultEnv = Env &quot;My Blog&quot; &quot;style.css&quot;
</code></pre>
<p>After filling this record with the requested information, we can pass it as
input to any function that might need it.</p>
<h3 id="first-things-first"><a class="header" href="#first-things-first">First things first</a></h3>
<p>In this chapter, we'll show a different approach to passing around <code>Env</code>,
but please try using the argument passing approach first -
it would help to have a point of reference to compare to better understand
this other technique!</p>
<hr />
<ol>
<li>Make the <code>convert</code> function from <code>HsBlog.Convert</code>,
and the <code>buildIndex</code> function from <code>HsBlog.Directory</code> take an additional
argument for <code>Env</code>, and pass it around from <code>main</code> all the way down.
You can use <code>defaultEnv</code> for starters, later I will ask you to write an
options parser for <code>Env</code> values.</li>
</ol>
<p>After getting <code>Env</code> to <code>convert</code> and <code>buildIndex</code>,
we can finally use the information in the environment for the page generation.
But actually, we don't even have the ability to add stylesheets to our
HTML EDSL at the moment! We need to go back and extend it.</p>
<p>Let's do all that now:</p>
<p>Since stylesheets go in the <code>head</code> element, perhaps it's a good idea to create an additional
<code>newtype</code> like <code>Structure</code> for <code>head</code> information? Things like title, stylesheet,
and even meta elements can be composed together just like we did for <code>Structure</code>
to build the <code>head</code>!</p>
<ol start="2">
<li>
<p>Do it now: extend our HTML library to include headings and add 3 functions:
<code>title_</code> for titles, <code>stylesheet_</code> for stylesheets, and <code>meta_</code> for meta elements
like <a href="https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards">twitter cards</a>.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Html.hs</summary>
<pre><code class="language-hs">-- Html.hs

module HsBlog.Html
  ( Html
  , Head
  , title_
  , stylesheet_
  , meta_
  , Structure
  , html_
  , p_
  , h_
  , ul_
  , ol_
  , code_
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
  where

import Prelude hiding (head)
import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/HsBlog/Html/Internal.hs</summary>
<pre><code class="language-hs">newtype Head
  = Head String

-- * EDSL

html_ :: Head -&gt; Structure -&gt; Html
html_ (Head head) content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; head
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Head

title_ :: String -&gt; Head
title_ = Head . el &quot;title&quot; . escape

stylesheet_ :: FilePath -&gt; Head
stylesheet_ path =
  Head $ &quot;&lt;link rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

meta_ :: String -&gt; String -&gt; Head
meta_ name content =
  Head $ &quot;&lt;meta name=\&quot;&quot; &lt;&gt; escape name &lt;&gt; &quot;\&quot; content=\&quot;&quot; &lt;&gt; escape content &lt;&gt; &quot;\&quot;&gt;&quot;

instance Semigroup Head where
  (&lt;&gt;) (Head h1) (Head h2) =
    Head (h1 &lt;&gt; h2)

instance Monoid Head where
  mempty = Head &quot;&quot;
</code></pre>
</details>
</details>
</li>
<li>
<p>Use <code>Env</code> in <code>convert</code> and <code>buildIndex</code> to add a stylesheet to the page, and the blog name to the title.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Convert.hs</summary>
<pre><code class="language-hs">import Prelude hiding (head)
import HsBlog.Env (Env(..))

convert :: Env -&gt; String -&gt; Markup.Document -&gt; Html.Html
convert env title doc =
  let
    head =
      Html.title_ (eBlogName env &lt;&gt; &quot; - &quot; &lt;&gt; title)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
    article =
      foldMap convertStructure doc
    websiteTitle =
      Html.h_ 1 (Html.link_ &quot;index.html&quot; $ Html.txt_ $ eBlogName env)
    body =
      websiteTitle &lt;&gt; article
  in
    Html.html_ head body
</code></pre>
</details>
<details><summary>src/HsBlog/Directory.hs</summary>
<pre><code class="language-hs">buildIndex :: Env -&gt; [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex env files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Head 1 head : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ head))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      ( Html.title_ (eBlogName env)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
      )
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
</details>
</li>
</ol>
<hr />
<p>The argument passing approach is a simple approach that can definitely
work for small projects. But sometimes, when the project gets bigger, and many
nested functions need the same information, threading the environment can get
tedious.</p>
<p>There is an alternative solution to threading the environment as input to functions,
and that is using the
<a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2"><code>ReaderT</code></a>
type from the <code>mtl</code> (or <code>transformers</code>) package.</p>
<h3 id="readert"><a class="header" href="#readert">ReaderT</a></h3>
<pre><code class="language-hs">newtype ReaderT r m a = ReaderT (r -&gt; m a)
</code></pre>
<p><code>ReaderT</code> is another <em>monad transformer</em> like <code>ExceptT</code>, which means
that it also has an instance of <code>Functor</code>, <code>Applicative</code>, <code>Monad</code>, and <code>MonadTrans</code>.</p>
<p>As we can see in the definition, <code>ReaderT</code> is <em>a newtype</em> over a function that takes
some value of type <code>r</code>, and returns a value of type <code>m a</code>. The <code>r</code> usually
represents the environment we want to share between functions we want to compose,
and the <code>m a</code> represents the underlying result we return.
The <code>m</code> could be any type that implements <code>Monad</code> that we are familiar with.
Usually, it goes well with <code>IO</code> or <code>Identity</code>, depending on if we want to share
an environment between effectful or uneffectful computations.</p>
<p><code>ReaderT</code> <em>carries</em> a value of type <code>r</code> and passes it around to
other functions when we use the <code>Applicative</code> and <code>Monad</code> interfaces so that
we don't have to pass the value around manually. And when we want to grab
the <code>r</code> and use it, all we have to do is <code>ask</code>.</p>
<p>For our case, this means that instead of passing around <code>Env</code>, we can instead
convert our functions to use <code>ReaderT</code> - those that are uneffectful and don't use
<code>IO</code> can return <code>ReaderT Env Identity a</code>  instead of <code>a</code> (or the simplified version, <code>Reader Env a</code>),
and those that are effectful can return <code>ReaderT Env IO a</code> instead of <code>IO a</code>.</p>
<p>Note, as we've said before, <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> all expect the type
that implements their interfaces to have the kind <code>* -&gt; *</code>.
This means that it is <code>ReaderT r m</code> that implements these interfaces,
and when we compose functions with <code>&lt;*&gt;</code> or <code>&gt;&gt;=</code> we replace the <code>f</code> or <code>m</code>
in their type signature with <code>ReaderT r m</code>.</p>
<p>This means that as with <code>Either e</code> when we had composed functions with the same error type,
so it is with <code>ReaderT r m</code> - we have to compose functions with the same <code>r</code> type and the same
<code>m</code> type, we can't mix different environment types or different underlying <code>m</code> types.</p>
<p>We're going to use a specialized version of <code>ReaderT</code> that uses a specific <code>m</code> = <code>Identity</code>
called <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html#g:2"><code>Reader</code></a>.
The <code>Control.Monad.Reader</code> provides an alias: <code>Reader r a = ReaderT r Identity a</code>.</p>
<blockquote>
<p>If the idea behind <code>ReaderT</code> is still a bit fuzzy to you and you want
to get a better understanding of how <code>ReaderT</code> works,
try doing the following exercise:</p>
<ol>
<li>Choose an <code>Applicative</code> or <code>Monad</code> interface function; I recommend <code>liftA2</code>,
and specialize its type signature by replacing <code>f</code> (or <code>m</code>) with a concrete <code>ReaderT</code> type such as
<code>ReaderT Int IO</code></li>
<li>Unpack the <code>ReaderT</code> newtype, replacing <code>ReaderT Int IO t</code> with <code>Int -&gt; IO t</code></li>
<li>Implement this specialized version of the function you've chosen</li>
</ol>
<details><summary>Solution for liftA2</summary>
<pre><code class="language-hs">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<details><summary>Solution for (1)</summary>
<pre><code class="language-hs">-- Specialize: replace `f` with `ReaderT Env IO`
liftA2 :: (a -&gt; b -&gt; c) -&gt; ReaderT Env IO a -&gt; ReaderT Env IO b -&gt; ReaderT Env IO c
</code></pre>
</details>
<details><summary>Solution for (2)</summary>
<pre><code class="language-hs">-- Unpack the newtype, replacing `ReaderT Env IO a` with `Env -&gt; IO a`
liftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
</code></pre>
</details>
<details><summary>Solution for (3)</summary>
<pre><code class="language-hs">specialLiftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
specialLiftA2 combine funcA funcB env =
  liftA2 combine (funcA env) (funcB env)
</code></pre>
<p>Notice how the job of our special <code>liftA2</code> for <code>ReaderT</code> is to supply the
two functions with <code>env</code> and then use the <code>liftA2</code>
implementation of the underlying <code>m</code> type (in our case, <code>IO</code>) to do the rest of the work.
Does it look like we're adding a capability on top of a different <code>m</code>?
That's the idea behind monad transformers.</p>
</details>
</details>
</blockquote>
<h3 id="how-to-use-reader"><a class="header" href="#how-to-use-reader">How to use Reader</a></h3>
<h4 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a function</a></h4>
<p>Instead of defining a function like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
</code></pre>
<p>We define it like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
</code></pre>
<p>Now that our code uses <code>Reader</code>, we have to accommodate that in the way we write our functions.</p>
<p>Before:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml env txtFiles =
 let
   txtOutputFiles = map toOutputMarkupFile txtFiles
   index = (&quot;index.html&quot;, buildIndex env txtOutputFiles)
   htmlPages = map (convertFile env) txtOutputFiles
 in
   map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we needed to thread the <code>env</code> to the other functions that use it.</p>
<p>After:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
txtsToRenderedHtml txtFiles = do
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
  index &lt;- (,) &quot;index.html&quot; &lt;$&gt; buildIndex txtOutputFiles
  htmlPages &lt;- traverse convertFile txtOutputFiles
  pure $ map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we use <em>do notation</em> now, and <em>instead of threading</em> <code>env</code> around we <em>compose</em>
the relevant functions, <code>buildIndex</code> and <code>convertFile</code>, we use the type classes
interfaces to compose the functions. Note how we needed to <code>fmap</code> over <code>buildIndex</code>
to add the output file we needed with the tuple and how we needed to use <code>traverse</code> instead
of <code>map</code> to compose the various <code>Reader</code> values <code>convertFile</code> will produce.</p>
<h3 id="extracting-env"><a class="header" href="#extracting-env">Extracting <code>Env</code></a></h3>
<p>When we want to use our <code>Env</code>, we need to <em>extract</em> it from the <code>Reader</code>.
We can do it with:</p>
<pre><code class="language-hs">ask :: ReaderT r m r
</code></pre>
<p>Which yanks the <code>r</code> from the <code>Reader</code> - we can extract with <code>&gt;&gt;=</code> or <code>&lt;-</code> in do notation.
See the comparison:</p>
<p>Before:</p>
<pre><code class="language-hs">convertFile :: Env -&gt; (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile env (file, doc) =
  (file, convert env (takeBaseName file) doc)
</code></pre>
<p>After:</p>
<pre><code class="language-hs">convertFile :: (FilePath, Markup.Document) -&gt; Reader Env (FilePath, Html.Html)
convertFile (file, doc) = do
  env &lt;- ask
  pure (file, convert env (takeBaseName file) doc)
</code></pre>
<blockquote>
<p>Note: we didn't change <code>convert</code> to use <code>Reader</code> because it is a user-facing API for our
library. By providing a simpler interface, we allow more users to use our library -
even those that aren't yet familiar with monad transformers.</p>
<p>Providing a simple function argument passing interface is preferred in this case.</p>
</blockquote>
<h3 id="run-a-reader"><a class="header" href="#run-a-reader">Run a <code>Reader</code></a></h3>
<p>Similar to handling the errors with <code>Either</code>, at some point, we need to supply the environment to
a computation that uses <code>Reader</code> and extract the result from the computation.
We can do that with the functions <code>runReader</code> and <code>runReaderT</code>:</p>
<pre><code class="language-hs">runReader :: Reader r a -&gt; (r -&gt; a)

runReaderT :: ReaderT r m a -&gt; (r -&gt; m a)
</code></pre>
<p>These functions convert a <code>Reader</code> or <code>ReaderT</code> to a function that takes <code>r</code>.
Then we can pass the initial environment to that function:</p>
<pre><code class="language-hs">convertDirectory :: Env -&gt; FilePath -&gt; FilePath -&gt; IO ()
convertDirectory env inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>See the <code>let outputHtmls</code> part.</p>
<h3 id="extra-transforming-env-for-a-particular-call"><a class="header" href="#extra-transforming-env-for-a-particular-call">Extra: Transforming <code>Env</code> for a particular call</a></h3>
<p>Sometimes we may want to modify the <code>Env</code> we pass to a particular function call.
For example, we may have a general <code>Env</code> type that contains a lot of information and
functions that only need a part of that information.</p>
<p>If the functions we are calling are like <code>convert</code> and take the environment as an
argument instead of a <code>Reader</code>, we can just extract the environment
with <code>ask</code>, apply a function to the extracted environment,
and pass the result to the function like this:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  pure (inner (extractSmallEnv env))

inner :: SmallEnv -&gt; MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>But if <code>inner</code> uses a <code>Reader SmallEnv</code> instead of argument passing,
we can use <code>runReader</code> to <em>convert <code>inner</code> to a normal function</em>,
and use the same idea as above!</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  -- Here the type of `runReader inner` is `SmallEnv -&gt; MyResult`
  pure (runReader inner (extractSmallEnv env))

inner :: Reader SmallEnv MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>This pattern is generalized and captured by a function called
<a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Reader.html#v:withReaderT">withReaderT</a>,
and works even for <code>ReaderT</code>:</p>
<pre><code class="language-hs">withReaderT :: (env2 -&gt; env1) -&gt; ReaderT env1 m a -&gt; ReaderT env2 m a
</code></pre>
<p><code>withReaderT</code> takes a function that modifies the environment,
and converts a <code>ReaderT env1 m a</code> computation to a <code>ReaderT env2 m a</code> computation
using this function.</p>
<p>Let's see it concretely with our example:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = withReaderT extractSmallEnv inner
</code></pre>
<hr />
<p>Question: what is the type of <code>withReaderT</code> when specialized in our case?</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">withReaderT
  :: (BigEnv -&gt; SmallEnv)     -- This is the type of `extractSmallEnv`
  -&gt; Reader SmallEnv MyResult -- This is the type of `inner`
  -&gt; Reader BigEnv   MyResult -- This is the type of `outer`
</code></pre>
</details>
<hr />
<p>Note the order of the environments! We use a function from a <code>BigEnv</code> to a <code>SmallEnv</code>,
to convert a <code>Reader</code> of <code>SmallEnv</code> to a <code>Reader</code> of <code>BigEnv</code>!</p>
<p>This is because we are mapping over the <em>input</em> of a function rather than the <em>output</em>,
and is related to topics like variance and covariance, but it isn't terribly important
for us at the moment.</p>
<h3 id="finishing-touches"><a class="header" href="#finishing-touches">Finishing touches</a></h3>
<p>The are a couple of things left to do:</p>
<hr />
<ol>
<li>
<p>Change <code>buildIndex</code> to use <code>Reader</code> instead of argument passing.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Reader Env Html.Html
buildIndex files = do
  env &lt;- ask
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Head 1 head : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ head))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  pure $ Html.html_
      ( Html.title_ (eBlogName env)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
      )
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
</li>
<li>
<p>Create a command-line parser for <code>Env</code>, attach it to the <code>convert-dir</code> command,
and pass the result to the <code>convertDirectory</code> function.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">import HsBlog.Env (defaultEnv)

convertSingle :: String -&gt; Handle -&gt; Handle -&gt; IO ()

process :: String -&gt; String -&gt; String
process title = Html.render . convert defaultEnv title . Markup.parse
</code></pre>
</details>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">import HsBlog.Env

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath Env
  deriving Show

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir &lt;*&gt; pEnv

-- | Parser for blog environment
pEnv :: Parser Env
pEnv =
  Env &lt;$&gt; pBlogName &lt;*&gt; pStylesheet

-- | Blog name parser
pBlogName :: Parser String
pBlogName =
  strOption
    ( long &quot;name&quot;
      &lt;&gt; short 'N'
      &lt;&gt; metavar &quot;STRING&quot;
      &lt;&gt; help &quot;Blog name&quot;
      &lt;&gt; value (eBlogName defaultEnv)
      &lt;&gt; showDefault
    )

-- | Stylesheet parser
pStylesheet :: Parser String
pStylesheet =
  strOption
    ( long &quot;style&quot;
      &lt;&gt; short 'S'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Stylesheet filename&quot;
      &lt;&gt; value (eStylesheetPath defaultEnv)
      &lt;&gt; showDefault
    )

</code></pre>
</details>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output env -&gt;
      HsBlog.convertDirectory env input output

    ...
</code></pre>
</details>
</details>
</li>
</ol>
<hr />
<h3 id="summary-11"><a class="header" href="#summary-11">Summary</a></h3>
<p>Which version do you like better? Manually passing arguments, or using <code>Reader</code>?</p>
<p>To me, it is not clear that the second version with <code>Reader</code> is better than the first
with explicit argument passing in our particular case.</p>
<p>Using <code>Reader</code> and <code>ReaderT</code> makes our code a little less friendly toward beginners
that are not yet familiar with these concepts and techniques, and we don't see
(in this case) many benefits.</p>
<p>As programs grow larger, techniques like <code>Reader</code> become more attractive.
For our relatively small example, using <code>Reader</code> might not be appropriate.
I've included it in this book because it is an important technique to have in our
arsenal, and I wanted to demonstrate it.</p>
<p>It is important to weigh the benefits and costs of using advanced techniques,
and it's often better to try and get away with simpler techniques if possible.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/f9fe7179fcf0e6c818f6caa860b52e991432dab2">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/f9fe7179fcf0e6c818f6caa860b52e991432dab2">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>We want to add some tests to our blog generator. At the very least
a few regression tests to make sure that if we extend or change our markup parsing code,
HTML generation code, or translation from markup to HTML code, and make a mistake, we'll
have a safety net alerting us of issues.</p>
<p>We will use the <a href="https://hspec.github.io/">Hspec</a> testing framework to write our tests.
There are other testing frameworks in Haskell, for example,
<a href="https://hackage.haskell.org/package/tasty">tasty</a>, but I like Hspec's documentation,
so we'll use that.</p>
<h2 id="initial-setup"><a class="header" href="#initial-setup">Initial setup</a></h2>
<h3 id="cabal-file-additions"><a class="header" href="#cabal-file-additions">Cabal file additions</a></h3>
<p>We're going to define a new section in our <code>hs-blog-gen.cabal</code> file for our new test suite.
This section is called <code>test-suite</code> and is fairly similar to the <code>library</code> and
<code>executable</code> sections.</p>
<p>The interfaces for how to define a test suite are described in the
<a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#test-suites">Cabal documentation</a>.
We are going to use the <code>exitcode-stdio-1.0</code> interface. Let's go over the different settings
and options:</p>
<pre><code class="language-cabal">test-suite hs-blog-gen-test
  import: common-settings
  type: exitcode-stdio-1.0
  hs-source-dirs: test
  main-is: Spec.hs

  -- other-modules:
  build-depends:
      base
    , hspec
    , hspec-discover
    , raw-strings-qq
    , hs-blog
  ghc-options:
    -O -threaded -rtsopts -with-rtsopts=-N
  build-tool-depends:
    hspec-discover:hspec-discover
</code></pre>
<ul>
<li><code>hs-source-dirs: test</code> - The directory of the source files for the test suite</li>
<li><code>main-is: Spec.hs</code> - The entry point to the test suite</li>
<li><code>other-modules</code> - The modules in our test suite.
Currently commented out because we haven't added any yet</li>
<li><code>build-depends</code> - The packages we are going to use:
<ul>
<li><a href="https://hackage.haskell.org/package/base"><code>base</code></a> -
The standard library for Haskell, as we've used before</li>
<li><a href="https://hackage.haskell.org/package/hspec"><code>hspec</code></a> -
The test framework we are going to use</li>
<li><a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> -
Automatic discovery of Hspec tests</li>
<li><a href="https://hackage.haskell.org/package/raw-strings-qq"><code>raw-strings-qq</code></a> -
Additional syntax for writing raw string literals</li>
<li><code>hs-blog</code> - Our library</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-ghc-options"><code>ghc-options</code></a> -
Extra options and flags for GHC:
<ul>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-optimisation.html#options-optimise"><code>-O</code></a> -
Compile with optimizations</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--threaded"><code>-threaded</code></a> -
Use the multi-core runtime instead of the single-core runtime. The multi-core
runtime is generally a bit slower in my experience, but when writing code that actually uses
multiple cores (such as a test framework that runs tests in parallel), it can give a good
performance boost</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts</code></a> -
Let us configure the Haskell runtime system by passing command-line arguments to our application</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=-N</code></a> -
Set specific default options for the program at link-time.
Specifically, <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--N%20%E2%9F%A8x%E2%9F%A9"><code>-N</code></a>
Sets the number of cores to use in our program</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-build-tool-depends"><code>build-tool-depends</code></a> -
Use a specific executable from a package dependency in aid of building the package.
In this case, we are using the <code>hspec-discover</code> executable from the
<a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> package, which
goes over the source directory for the tests, finds all of the <code>Spec</code> files
and creates an entry point for the program that will run all the tests it discovered</li>
</ul>
<h3 id="hspec-discovery"><a class="header" href="#hspec-discovery">Hspec discovery</a></h3>
<p>For <code>hspec-discover</code> to work, we need to add the following
to the &quot;main&quot; file of the test suite, for us, this is <code>test/Spec.hs</code>:</p>
<pre><code class="language-hs">{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
</code></pre>
<p>That's it! <code>hspec-discover</code> will automatically define a <code>main</code> for us.
Now we can run the tests using <code>stack test</code> or <code>cabal test</code> (your choice).
Because we haven't defined any tests, our output is:</p>
<pre><code class="language-sh">Finished in 0.0000 seconds
0 examples, 0 failures
</code></pre>
<p>When we add new Hspec tests, <code>hspec-discover</code> will find and run them automatically
(though we will still need to add them to the <code>other-modules</code> section in the cabal file).</p>
<p>For <code>hspec-discover</code> to identify modules as test modules, the modules must follow
a convention:</p>
<ol>
<li>Their module names must end with <code>Spec</code></li>
<li>They must define a value <code>spec :: Spec</code> (which describes the test) and export it
outside of the module (by adding it to the export list of the module, for example)</li>
</ol>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>Let's write our first test. We'll create a new module to test
markup parsing. We'll call it <code>MarkupParsingSpec.hs</code>. We'll need
the following imports as well:</p>
<pre><code class="language-hs">module MarkupParsingSpec where

import Test.Hspec
import HsBlog.Markup
</code></pre>
<p><code>Hspec</code> provides us with a monadic interface for describing, composing and
nesting test specifications (<code>Spec</code>s).</p>
<p>Using the <code>describe</code> function, we can
describe a group of tests; using the <code>it</code> function, we can add a new test,
and using a function like <code>shouldBe</code>, we can compare two values and make
sure they are equal by using their <code>Eq</code> instance.
If they are, the test will pass; if not, it will fail with a descriptive error.</p>
<p>Let's try it and write a test that obviously fails!</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        [Heading 1 &quot;bug&quot;]
</code></pre>
<p>After adding the module to the <code>other-modules</code> list in the cabal file:</p>
<pre><code class="language-hs">  other-modules:
    MarkupParsingSpec
</code></pre>
<p>And running the tests, we get this output:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty FAILED [1]

Failures:

  test/MarkupParsingSpec.hs:10:7:
  1) MarkupParsing, Markup parsing tests, empty
       expected: [Heading 1 &quot;bug&quot;]
        but got: []

  To rerun use: --match &quot;/MarkupParsing/Markup parsing tests/empty/&quot;

Randomized with seed 763489823

Finished in 0.0004 seconds
1 example, 1 failure
</code></pre>
<p>The output describes which tests are running in a hierarchy tree (module, group, and test),
whether the tests pass or fail, and if they fail, the output and the expected output.</p>
<p>We can fix our test by matching the expected output:</p>
<pre><code class="language-hs">      shouldBe
        (parse &quot;&quot;)
        []
</code></pre>
<p>Now, running the tests will produce:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty

Finished in 0.0001 seconds
1 example, 0 failures
</code></pre>
<p>We can add a few more tests:</p>
<pre><code class="language-hs">    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>And run the tests again:</p>
<pre><code class="language-sh">MarkupParsing
  Markup parsing tests
    Test empty
    paragraph
    heading 1
    code

Finished in 0.0003 seconds
4 examples, 0 failures
</code></pre>
<p>This is the gist of writing unit tests with Hspec. It's important to note
that we can nest <code>Spec</code>s that are declared with <code>describe</code> to create trees,
and, of course, refactor and move things to different functions and modules
to make our test suite better organized.</p>
<p>For example, we can write our tests like this:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple

simple :: Spec
simple = do
  describe &quot;simple&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        []

    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>Also, there are other &quot;expectations&quot; like <code>shouldBe</code> that we can use when writing tests.
They are described in the <a href="https://hspec.github.io/expectations.html">Hspec tutorial</a>
and can be found in the
<a href="https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html">haddock documentation</a> as well.</p>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>If we want to write multi-line strings or avoid escaping strings as we did in the &quot;code&quot;
test, we can use a library called
<a href="https://hackage.haskell.org/package/raw-strings-qq">raw-strings-qq</a>
which uses a language extension called
<a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html#extension-QuasiQuotes"><code>QuasiQuotes</code></a>.
<code>QuasiQuotes</code> is a meta-programming extension that provides a mechanism for extending the
syntax of Haskell.</p>
<p>A quasi-quote has the form <code>[quoter| string |]</code>, where the quoter is the name
of the function providing the syntax we wish to use, and the string is our input.</p>
<p>In our case, we use the quoter <code>r</code>, which is defined in
<a href="https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html">raw-strings-qq</a>,
and write any string we want, with multi-lines and unescaped characters!
We could use this to write the tests
<a href="04-markup/01-data_type.html#exercises">we previously wrote</a>:</p>
<pre><code class="language-hs">{-# language QuasiQuotes #-}

...

import Text.RawString.QQ

...

example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together into a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]
</code></pre>
<p>And add multi-line tests:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple
    multiline


multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result


example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together into a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]

example3Result :: Document
example3Result =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together into a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
<p>Running the tests:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    simple
      Test empty
      paragraph
      heading 1
      code
    Multi-line tests
      example3

Finished in 0.0004 seconds
5 examples, 0 failures
</code></pre>
<hr />
<p><strong>Exercise</strong>: Add a test for the fourth example described in the
<a href="04-markup/01-data_type.html#exercises">previous exercises</a>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result

    it &quot;example4&quot; $
      shouldBe
        (parse example4)
        example4Result


example4 :: String
example4 = [r|
* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
|]

example4Result :: Document
example4Result =
  [ Heading 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;➜ ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<hr />
<h2 id="parallel-test-execution"><a class="header" href="#parallel-test-execution">Parallel test execution</a></h2>
<p>Without further configuration, Hspec will run all
of our tests on the main thread sequentially.</p>
<p>There are a couple of ways to configure tests to run
in parallel. One is to manually mark a <code>Spec</code>
as parallel by passing it to the <code>parallel</code> function,
and another is by creating a /hook/ that will apply
<code>parallel</code> to each <code>Spec</code> automatically with
<code>hspec-discover</code>.</p>
<p>Consult the <a href="https://hspec.github.io/parallel-spec-execution.html#running-all-tests-in-parallel-with-hspec-discover">Hspec manual</a>
on this topic and try both methods. Remember that
we already enabled the threaded runtime and set it to
use multiple cores in the cabal file.</p>
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>This chapter has been just the tip of the iceberg of the Haskell testing landscape.
We haven't talked about
<a href="https://www.scs.stanford.edu/16wi-cs240h/slides/testing.html">property testing</a> or
<a href="https://ro-che.info/articles/2017-12-04-golden-tests">golden testing</a>,
testing expected failures, testing IO code, inspection testing, benchmarking, and more.
There's just too much to cover!</p>
<p>I hope this chapter
provided you with the basics of how to start writing tests for your projects.
Please consult the tutorial for your chosen testing framework, and read more about
this very important subject on your own.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/da1615b6e0a2a4ff2728528240d790754853bf02">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/da1615b6e0a2a4ff2728528240d790754853bf02">code up until now</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-documentation"><a class="header" href="#generating-documentation">Generating documentation</a></h1>
<p>There are <a href="https://documentation.divio.com/">many ways</a>
to help others to get started with our projects and libraries.
For example, we can write tutorials, provide runnable examples,
describe the system's internals, and create an API reference.</p>
<p>In this chapter, we will focus on generating API reference pages (the kind that can be seen on Hackage)
from annotated Haskell source code using <a href="https://haskell-haddock.readthedocs.io/en/latest/">Haddock</a>.</p>
<h2 id="running-haddock"><a class="header" href="#running-haddock">Running Haddock</a></h2>
<p>We can generate API reference pages (a.k.a. haddocks in the Haskell world) for our project
using our favorite package manager:</p>
<h3 id="cabal"><a class="header" href="#cabal">Cabal</a></h3>
<p>We can run <code>cabal haddock</code> to generate haddocks:</p>
<pre><code class="language-sh">➜ cabal haddock
Resolving dependencies...
Build profile: -w ghc-9.0.1 -O1
In order, the following will be built (use -v for more details):
 - hs-blog-0.1.0.0 (lib) (first run)
Configuring library for hs-blog-0.1.0.0..
Preprocessing library for hs-blog-0.1.0.0..
Running Haddock on library for hs-blog-0.1.0.0..
Haddock coverage:
   0% (  0 /  3) in 'HsBlog.Env'
  Missing documentation for:
    Module header
    Env (src/HsBlog/Env.hs:3)
    defaultEnv (src/HsBlog/Env.hs:10)
  21% (  7 / 33) in 'HsBlog.Html.Internal'
  Missing documentation for:
    Module header
    Html (src/HsBlog/Html/Internal.hs:8)
...
Documentation created:
/tmp/learn-haskell-blog-generator/dist-newstyle/build/x86_64-linux/ghc-9.0.1/hs-blog-0.1.0.0/doc/html/hs-blog/index.html
</code></pre>
<p>Cabal and Haddock will build our project and generate HTML pages for us at:</p>
<pre><code class="language-html">./dist-newstyle/build/&lt;platform&gt;/&lt;compiler&gt;/&lt;package&gt;-&lt;version&gt;/doc/html/&lt;package&gt;/
</code></pre>
<p>We can then open the <code>index.html</code> file from that directory in a web browser and view our package documentation.</p>
<h3 id="stack"><a class="header" href="#stack">Stack</a></h3>
<p>We can run <code>stack haddock</code> to generate haddocks:</p>
<pre><code class="language-sh">➜ stack haddock
...
hs-blog&gt; build (lib + exe)
Preprocessing library for hs-blog-0.1.0.0..
Building library for hs-blog-0.1.0.0..
[1 of 7] Compiling HsBlog.Env
[2 of 7] Compiling HsBlog.Html.Internal
...
hs-blog&gt; haddock
Preprocessing library for hs-blog-0.1.0.0..
Running Haddock on library for hs-blog-0.1.0.0..
Haddock coverage:
   0% (  0 /  3) in 'HsBlog.Env'
  Missing documentation for:
    Module header
    Env (src/HsBlog/Env.hs:3)
    defaultEnv (src/HsBlog/Env.hs:10)
  21% (  7 / 33) in 'HsBlog.Html.Internal'
  Missing documentation for:
    Module header
    Html (src/HsBlog/Html/Internal.hs:8)
...
Documentation created:
.stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/index.html,
.stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/doc/html/hs-blog/hs-blog.txt
Preprocessing executable 'hs-blog-gen' for hs-blog-0.1.0.0..
...
</code></pre>
<p>Stack and Haddock will build our project and generate HTML pages for us at:</p>
<pre><code class="language-html">./.stack-work/dist/&lt;platform&gt;/Cabal-&lt;version&gt;/doc/html/&lt;package&gt;/
</code></pre>
<p>We can then open the <code>index.html</code> file from that directory in a web browser and view our package documentation.</p>
<h3 id="haddock-coverage"><a class="header" href="#haddock-coverage">Haddock coverage</a></h3>
<p>Haddock will also output a coverage report when run and mention user-exposed constructs that are missing
documentation. These constructs could be module headers, types, data constructors, type classes, functions, values, etc.</p>
<p>For example:</p>
<pre><code class="language-hs">Haddock coverage:
...
   0% (  0 /  3) in 'HsBlog.Convert'
  Missing documentation for:
    Module header
    convert (src/HsBlog/Convert.hs:8)
    convertStructure (src/HsBlog/Convert.hs:23)
  67% (  2 /  3) in 'HsBlog.Directory'
  Missing documentation for:
    buildIndex (src/HsBlog/Directory.hs:80)
...
</code></pre>
<p>We can see that we did not document the <code>HsBlog.Convert</code> at all, and we are missing
documentation for the module header, the <code>convert</code> function, and the <code>convertStructure</code> function.</p>
<p>On the other hand, it seems that we do currently have some documentation written for the <code>HsBlog.Directory</code>
module! We'll see why, but first - try to generate haddocks, visit the module hierarchy, browse around
the different modules, follow the links of the types, imagine what this API reference could look like,
and let's see how we can improve it.</p>
<h2 id="haddock-markup"><a class="header" href="#haddock-markup">Haddock markup</a></h2>
<p>Haddock builds the API reference pages by building our project, examining the exported modules
and their exported definitions, and grabbing source code comments written in special markup format.</p>
<p>Let's take a quick look at this markup format. We will go over a few important bits,
but if you'd like to learn more, a complete guide for Haddock markup can be found in the
<a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html">Haddock documentation</a>.</p>
<h3 id="documenting-definitions"><a class="header" href="#documenting-definitions">Documenting definitions</a></h3>
<p>All haddock annotations appear as part of regular Haskell comments.
They can be used with both single-line form (<code>--</code>) and multi-line form (<code>{-</code> and <code>-}</code>).
The placements of a comment block and the haddock marker determine which Haskell
definition the haddock string is attached to.</p>
<p>We can annotate a Haskell definition by writing a comment block prefixed with <code>|</code> <em>before</em>
the definition, or by writing a comment block prefixed with <code>^</code> <em>after</em> the definition.</p>
<p>For example:</p>
<pre><code class="language-hs">-- | Construct an HTML page from a `Head`
--   and a `Structure`.
html_
  :: Head -- ^ Represents the @\&lt;head\&gt;@ section in an HTML file
  -&gt; Structure -- ^ Represents the @\&lt;body\&gt;@ section in an HTML file
  -&gt; Html
html_ = ...
...
</code></pre>
<p>Here's another example:</p>
<pre><code class="language-hs">{- | Represents a single markup structure. Such as:

- A paragraph
- An unordered list
- A code block
-}
data Structure
  = Heading Natural String
  -- ^ A section heading with a level
  | Paragraph String
  -- ^ A paragraph
  | UnorderedList [String]
  -- ^ An unordered list of strings
  | OrderedList [String]
  -- ^ An ordered list of strings
  | CodeBlock [String]
  -- ^ A code block
</code></pre>
<p>And another:</p>
<pre><code class="language-hs">{- | Markup to HTML conversion module.

This module handles converting documents written in our custom
Markup language into HTML pages.
-}
module HsBlog.Convert where
</code></pre>
<p>As you can see, <code>|</code> and <code>^</code> can be used to document functions, function arguments,
types, data constructors, modules, and more. They are probably the most important
Haddock annotations to remember (and even then, <code>|</code> alone will suffice).</p>
<blockquote>
<p><strong>Tip</strong>: Annotate the modules, types, and the top-level definitions
which are exported from your project
with some high-level description of what they are used for (at the very least).</p>
<p>Your users and collaborators will thank you!</p>
</blockquote>
<h3 id="section-headings"><a class="header" href="#section-headings">Section headings</a></h3>
<p>We can separate our module into sections by adding headings.
Headings are comments prefixed with a number of <code>*</code> (just like in our markup language).</p>
<p>For example:</p>
<pre><code class="language-hs">-- * HTML EDSL

html_ :: Head -&gt; Structure -&gt; Html
html_ = ...

-- ** Structure

p_ :: Content -&gt; Structure
p_ = ..

h_ :: Content -&gt; Structure
h_ = ..

...

-- ** Content

txt_ :: String -&gt; Content
txt_ = ...

link_ :: FilePath -&gt; Content -&gt; Content
link_ = ...
</code></pre>
<p>It is also possible to add headings to the export list instead:</p>
<pre><code class="language-hs">module HsBlog.Html
  ( -- * HTML EDSL
    Html
  , html_

    -- ** Combinators used to construct the @\&lt;head\&gt;@ section
  , Head
  , title_
  , stylesheet_
  , meta_

    -- ** Combinators used to construct the @\&lt;body\&gt;@ section
  , Structure
  , p_
  , h_
  , ul_
  , ol_
  , code_

    -- ** Combinators used to construct content inside structures
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_

    -- ** Render HTML to String
  , render
  )
  where
</code></pre>
<p>Separating parts of the module into sections helps keep the important things together
and Haddock will create a table of contents at the top of a module page for us as well.</p>
<p>Sometimes it's also easier to figure out whether a module should be split into multiple
modules or not after splitting it into sections using headings.</p>
<hr />
<p><strong>Exercise</strong>: Try to re-arrange the modules in our project to your liking and add headings to sections.</p>
<hr />
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<p>As we saw earlier, we can also add formatting in the content of our comments.
For example, we can:</p>
<ul>
<li>
<p>Hyperlink identifiers by surrounding them with <code>`</code></p>
<p>For example: <code>`Heading`</code></p>
</li>
<li>
<p>Write <code>monospaced text</code> by surrounding it with <code>@</code></p>
<p>For example: <code>@Paragraph &quot;Hello&quot;@</code></p>
</li>
<li>
<p>Add <em>emphasis</em> to text by surrounding it with <code>/</code></p>
<p>For example: <code>/this is emphasised/</code></p>
</li>
<li>
<p>Add <strong>bold</strong> to text by surrounding it with <code>__</code></p>
<p>For example: <code>__this is bold__</code></p>
</li>
</ul>
<h3 id="more"><a class="header" href="#more">More</a></h3>
<p>In this chapter, we've covered the basics of the Haddock markup language.
If you'd like to know more, the <a href="https://haskell-haddock.readthedocs.io/en/latest/markup.html">Haddock markup guide</a>
contains information on creating even more interesting documentation structures, such as
code blocks, grid tables, images, and examples.</p>
<h2 id="summary-13"><a class="header" href="#summary-13">Summary</a></h2>
<p>We've briefly covered one aspect of documenting Haskell programs:
using Haddock to generate informative API reference pages created from source code
comments which are annotated with Haddock markup.</p>
<p>While API references are incredibly valuable, remember that there are other forms of
documentation that can help your users get started quickly, such as examples and tutorials.</p>
<hr />
<p><strong>Exercise</strong>: Add haddock annotation to the top-level definitions in our project and test your understanding
of the program and the various parts - sometimes, the best way to learn something is to try explaining it!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="recap"><a class="header" href="#recap">Recap</a></h1>
<p>In this book, we've implemented a very simple static blog generator while learning Haskell as we go.</p>
<ul>
<li>We've learned about basic Haskell building blocks, such as definitions, functions,
types, modules, recursion, pattern matching, type classes, IO, and exceptions.</li>
<li>We've learned about <a href="./03-html/03-edsls.html">EDSLs</a> and used the <em>combinator pattern</em> to implement
a composable html generation library.</li>
<li>We've learned how to leverage types, modules, and smart constructors
to <a href="./03-html/04-safer_construction.html">make invalid states unrepresentable</a>.</li>
<li>We've learned how to represent complex data using <a href="./04-markup/01-data_type.html">ADTs</a>.</li>
<li>We've learned how to use <a href="./04-markup/04-parsing_02.html#pattern-matching">pattern matching</a> to transform ADTs,
and how to use <a href="./04-markup/02-parsing_01.html#recursion-and-accumulating-information">recursion</a> to solve problems.</li>
<li>We've used the <em>functional core, imperative shell</em> approach to build a program that handles IO and applies
our domain logic to user inputs.</li>
<li>We've learned about abstractions such as <a href="./05-glue/01-markup_to_html.html#monoids">monoids</a>,
<a href="./05-glue/04-optparse.html#functor">functors</a> and <a href="./06-errors_and_files/01-either.html#monadic-interface">monads</a>,
and how they can help us reuse code and convey information about shared interfaces.</li>
<li>We've learned how to create fancy <a href="./05-glue/04-optparse.html">command-line interfaces</a>, <a href="./08-testing.html">write tests</a>,
and <a href="./09-documentation.html">generate documentation</a>.</li>
</ul>
<p>While Haskell is a very big and complex language, and there's always more to be learned,
I think we've reached an important milestone where
you can start building your own Haskell projects and be productive with Haskell!</p>
<p>This is a good time to celebrate and pat yourself on the back for getting this far! Great job, you!</p>
<p>If you'd like to learn even more about Haskell and continue your Haskell journey
beyond this book, check out the appendix sections <a href="./11-next.html">Where to go next</a> and the <a href="./12-faq.html">FAQ</a>.</p>
<h2 id="thank-you"><a class="header" href="#thank-you">Thank you!</a></h2>
<p>Thank you for reading this book. I hope you enjoyed it and found Haskell interesting.</p>
<p>I would very much like to hear your feedback. If you'd like, you could leave your
feedback on this book's
<a href="https://github.com/soupi/learn-haskell-blog-generator/discussions">discussion board</a>,
or you could reach me directly on <a href="https://fosstodon.org/@suppi">mastodon</a> or via email.
You can find my contact information <a href="https://gilmi.me">on my website</a>.</p>
<p>If you liked this book, do let me know - your kind words mean a lot.</p>
<blockquote>
<p>Finally, if you <em>really</em> liked this book and would like to support future passion projects
like it, you can <a href="https://ko-fi.com/gilmi">support me directly via Ko-fi</a>.</p>
</blockquote>
<p>Thank you, and good luck with your next Haskell project!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-go-next"><a class="header" href="#where-to-go-next">Where to go next</a></h1>
<p>Haskell is an incredibly rich and deep programming language.
New cutting-edge techniques, concepts, and features are still being discovered
and sometimes integrated into GHC. This sometimes makes it seemingly impossible
to catch up to.</p>
<p>This phenomena is sometimes dubbed
<a href="https://patrickmn.com/software/the-haskell-pyramid/">The Haskell pyramid</a>.
I hope that by reading this book and following the exercises,
you readers have reached the bar of productivity, and you can now go and start
working on your own projects with Haskell. I highly encourage you to do so.
In my opinion, writing useful Haskell projects is the best method to solidify
what you currently know and identify what you still need to learn.</p>
<h2 id="extending-this-project"><a class="header" href="#extending-this-project">Extending this project</a></h2>
<p>If you'd like to extend this project, here are a few ideas for you:</p>
<ol>
<li><strong>Serve over HTTP</strong> - You can use a web library such as
<a href="https://www.youtube.com/watch?v=mz5_HmLGRXc">wai</a> or
<a href="https://gilmi.me/blog/post/2022/04/24/learn-twain-bulletin-app">twain</a>
to serve this blog over HTTP instead of generating it statically</li>
<li><strong>Rewrite it with libraries</strong> - you could rewrite it and use a real-world
<a href="https://hackage.haskell.org/package/lucid">HTML package</a>
and <a href="https://hackage.haskell.org/package/cmark-gfm">markdown parser</a></li>
<li><strong>Add features</strong>
<ol>
<li>You could add a metadata block at the top of each article
which would include the title, publish date, and tags of a blog post,
and use them when generating HTML, index page, and even tags pages</li>
<li>You could add HTML pages templating using
<a href="https://hackage.haskell.org/package/mustache">mustache</a> or similar,
and use that to generate a nice and customizable structure to the page</li>
<li>You could add support for links and images in our markup language parser</li>
<li>You could add support for configuration files which would include things like
the blog title, description, or other meta information for things like
<a href="https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards">twitter cards</a></li>
</ol>
</li>
</ol>
<p>Or anything else you can think of, consider this project your playground and
do whatever you like with it!</p>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>At some point, you are likely to run into new concepts, techniques,
or even just a feeling of &quot;I feel like this could be done better&quot;.
I'd like to point you in the right direction so you can find additional information
and learn new Haskell things when you need to or want to.</p>
<p>I've compiled a list of resources for learning Haskell called
<a href="https://github.com/soupi/haskell-study-plan">Haskell study plan</a>,
which includes links to very useful articles, community hubs, and news aggregators,
project suggestions, and even cool open-source Haskell projects.
You will also find alternative explanations for things we've covered
and even links to other Haskell tutorials, guides, and books in case you need
a different view on things.</p>
<p>Also, the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/index.html">GHC User Guide</a>
is a fantastic resource with loads of articles and information about the language and GHC tooling around it.
It is often the best place to learn about the Haskell language.</p>
<p>However, don't feel pressured to learn everything Haskell
has to offer right away. Mastering Haskell is a journey that can take a lot of time.
Most of us are definitely not there yet, but we can still be very productive with Haskell,
build real-world projects, and even discover new techniques and concepts ourselves.</p>
<p>Remember that in a lazy language, we evaluate things only when needed.
Maybe we can do that too, with Haskell concepts!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<blockquote>
<p>Got a question? You can ask in the <a href="https://github.com/soupi/learn-haskell-blog-generator/discussions">discussion board</a> or the <a href="https://github.com/soupi/learn-haskell-blog-generator/issues">issue tracker</a>!</p>
</blockquote>
<h2 id="general-questions"><a class="header" href="#general-questions">General questions</a></h2>
<h3 id="why-should-i-learn-haskell"><a class="header" href="#why-should-i-learn-haskell">Why should I learn Haskell</a></h3>
<p>I've written a couple of articles on the topic:</p>
<ul>
<li><a href="https://gilmi.me/blog/post/2020/04/28/consider-haskell">Consider Haskell</a> (Alternative title, 'What can I do with Haskell?')</li>
<li><a href="https://gilmi.me/blog/post/2022/12/13/learned-from-haskell">7 things I learned from Haskell</a></li>
</ul>
<h3 id="how-to-install-editor-tools"><a class="header" href="#how-to-install-editor-tools">How to install editor tools</a></h3>
<p>As far as I know, the most recommended setup today for Haskell development is using
VSCode or <a href="https://vscodium.com/">VSCodium</a> together with the
marketplace <a href="https://marketplace.visualstudio.com/items?itemName=haskell.haskell">Haskell extension</a>.</p>
<p>The Haskell extension uses <a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a>
which can be installed via <a href="https://www.haskell.org/ghcup/">GHCup</a> or even via the Haskell extension itself.</p>
<p>If you already have a preferred editor,
<a href="https://haskell-language-server.readthedocs.io/en/latest/configuration.html#configuring-your-editor">see if HLS supports it</a>,
or alternatively use <a href="https://github.com/ndmitchell/ghcid#readme">GHCid</a>
which provides rapid feedback independently from an editor.</p>
<h3 id="how-to-learn-new-things"><a class="header" href="#how-to-learn-new-things">How to learn new things</a></h3>
<p>The Haskell community keeps marching forward, developing new libraries, tools, and techniques
as well as creating new material for older concepts.
The <a href="https://haskell.pl-a.net">Haskell planetarium</a> aggregates feeds from several communities into
one page, as well as a <a href="https://haskellweekly.news/">Haskell Weekly newsletter</a>.
You might also find quite a bit of Haskell presence on the
<a href="https://fosstodon.org/tags/haskell">Fediverse</a>!</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="how-to-debug-haskell-code"><a class="header" href="#how-to-debug-haskell-code">How to debug Haskell code</a></h3>
<p>Most imperative languages provide a step debugger. While the
<a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/ghci.html#the-ghci-debugger">GHCi debugger</a>,
exists, it is not particularly easy to use, especially because of Haskell's lazy evaluation, where things
might not be evaluated in the order we might intuitively expect. Because of that,
Haskellers tend to use
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Debug-Trace.html#g:1">trace debugging</a> and
equational reasoning. With trace debugging, we try to <em>verify our assumptions</em> about the code -
we use the various <code>trace</code> functions as a &quot;hack&quot; to print variables, functions inputs, functions output
or even just say &quot;got here&quot; from anywhere in the code.</p>
<p>After finding something that does not match our assumptions, such as unexpected input or output
of a function, we try to think what piece of code could be responsible for the discrepancy or even use
trace debugging again to pinpoint the exact location, and try to use &quot;equational reasoning&quot; to
evaluate the offending code that betrayed our expectations. If it's easy to do, we try running
the function in <code>ghci</code> with different inputs to check our assumptions as well.</p>
<p>Because Haskell focuses on immutability, composability, and using types to eliminate many
classes of possible errors, &quot;local reasoning&quot; becomes possible, and trace debugging
becomes a viable strategy for debugging Haskell programs.</p>
<h3 id="how-to-understand-type-errors"><a class="header" href="#how-to-understand-type-errors">How to understand type errors</a></h3>
<p>GHC type errors are often not the most friendly error messages, but they mean well! They are just
trying to help us find inconsistencies in our code - often with regard to type usage, they help us
avoid making errors.</p>
<p>When you run into error messages, start by reading them carefully
until you get used to them, and then the offending code hinted at by the error message.
As you gain experience, it is likely that the most important part of an error will be the location
of the offending code, and by reading the code, we can find the error without the actual error message.</p>
<p>Adding type signatures and annotations to test your understanding of the types also helps greatly.
We can even ask GHC for the expected type in a certain place by using
<a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/typed_holes.html">typed holes</a>.</p>
<h3 id="my-program-is-slow-why"><a class="header" href="#my-program-is-slow-why">My program is slow. Why?</a></h3>
<p>There could be various reasons. From inefficient algorithms or
<a href="https://github.com/soupi/haskell-study-plan#data-structures">unsuited data structures</a> for the task
in terms of time complexity of the common operations, to less efficient memory representations
(this is another reminder to use <code>Text</code> over <code>String</code> in most cases),
and laziness issues (again, the evaluation strategy!).</p>
<p>The <a href="https://github.com/soupi/haskell-study-plan#performance">performance section</a> in my Haskell
study plan links to various resources on Haskell evaluation, profiling, and case studies.</p>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="how-to-structure-programs"><a class="header" href="#how-to-structure-programs">How to structure programs</a></h3>
<p>Start with the imperative shell functional core approach, define EDSLs with the combinator
pattern for logic if needed, use capabilities such as <code>State</code> locally if needed,
maybe add an environment configuration with <code>ReaderT</code>, and see how it goes.</p>
<p>If that approach fails you, look at why it fails and examine other solutions according to your needs.</p>
<h3 id="how-to-model-data"><a class="header" href="#how-to-model-data">How to model data</a></h3>
<p>Modeling data using ADTs are usually the way to go. Often programmers coming from object-oriented
background tend to look at type classes as a way to define methods similar to inheritance,
but this often isn't the right approach, and ADTs with different constructors for different alternatives
go a long way. Remember that even OOP people often preach for composition over inheritance.</p>
<p>Use functions to define behavior on data rather than trying to couple the two together.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
