<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Passing an environment - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Lets code already!</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="07-environment.html" class="active"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="passing-environment-variables"><a class="header" href="#passing-environment-variables">Passing environment variables</a></h1>
<p>We'd like to add some sort of an environment to keep general information on
the blog for various processings, such as the blog name, stylesheet
location, and so on.</p>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<p>We can represent our environment as a record data type and build it from user input.
The user input can be from command-line arguments, a configuration file,
or something else:</p>
<pre><code class="language-hs">module HsBlog.Env where

data Env
  = Env
    { eBlogName :: String
    , eStylesheetPath :: FilePath
    }
  deriving Show

defaultEnv :: Env
defaultEnv = Env &quot;My Blog&quot; &quot;style.css&quot;
</code></pre>
<p>After filling this record with the requested information, we can pass it as
input to any function that might need it. This is a simple approach that can definitely
work for small projects. But sometimes when the project gets bigger and many
nested functions need the same information, threading the environment can get
tedious.</p>
<p>There is an alternative solution to threading the environment as input to functions,
and that is using the
<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2"><code>ReaderT</code></a>
type from the <code>mtl</code> (or <code>transformers</code>) package.</p>
<h3 id="readert"><a class="header" href="#readert">ReaderT</a></h3>
<pre><code class="language-hs">newtype ReaderT r m a = ReaderT (r -&gt; m a)
</code></pre>
<p><code>ReaderT</code> is another <em>monad transformer</em> like <code>ExceptT</code>, which means
that it also has an instance of <code>Functor</code>, <code>Applicative</code>, <code>Monad</code> and <code>MonadTrans</code>.</p>
<p>As we can see in the definition, <code>ReaderT</code> is <em>a newtype</em> over a function that takes
some value of type <code>r</code>, and returns a value of type <code>m a</code>. The <code>r</code> usually
represents the environment we want to share between functions that we want to compose,
and the <code>m a</code> represents the underlying result that we return.
The <code>m</code> could be any type that implements <code>Monad</code> that we are familiar with.
Usually it goes well with <code>IO</code> or <code>Identity</code>, depending on if we want to share
an environment between effectful or uneffectful computations.</p>
<p><code>ReaderT</code> <em>carries</em> a value of type <code>r</code> and passes it around to
other functions when we use the <code>Applicative</code> and <code>Monad</code> interfaces so that
we don't have to pass the value around manually. And when we want to grab
the <code>r</code> and use it, all we have to do is <code>ask</code>.</p>
<p>For our case, this means that instead of passing around <code>Env</code>, we can instead
convert our functions to use <code>ReaderT</code> - those that are uneffectful and don't use
<code>IO</code>, can return <code>ReaderT Env Identity a</code>  instead of <code>a</code> (or the simplified version, <code>Reader Env a</code>),
and those that are effectful can return <code>ReaderT Env IO a</code> instead of <code>IO a</code>.</p>
<p>Note, as we've said before, <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> all expect the type
that implements their interfaces to have the kind <code>* -&gt; *</code>.
This means that it is <code>ReaderT r m</code> which implements these interfaces,
and when we compose functions with <code>&lt;*&gt;</code> or <code>&gt;&gt;=</code> we replace the <code>f</code> or <code>m</code>
in their type signature with <code>ReaderT r m</code>.</p>
<p>This means that, as with <code>Either e</code> when we had composed functions with the same error type,
so it is with <code>ReaderT r m</code> - we have to compose functions with the same <code>r</code> type and same
<code>m</code> type, we can't mix different environment types or different underlying <code>m</code> types.</p>
<p>We're going to use a specialized version of <code>ReaderT</code> that uses a specific <code>m</code> = <code>Identity</code>
called <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#g:2"><code>Reader</code></a>.
The <code>Control.Monad.Reader</code> provides an alias: <code>Reader r a = ReaderT r Identity a</code>.</p>
<blockquote>
<p>If the idea behind <code>ReaderT</code> is still a bit fuzzy to you and you want
to get a better understanding of how <code>ReaderT</code> works,
try doing the following exercise:</p>
<ol>
<li>Choose an <code>Applicative</code> or <code>Monad</code> interface function, I recommend <code>liftA2</code>,
and specialize its type signature by replacing <code>f</code> (or <code>m</code>) with a concrete <code>ReaderT</code> type such as
<code>ReaderT Int IO</code></li>
<li>Unpack the <code>ReaderT</code> newtype, replacing <code>ReaderT Int IO t</code> with <code>Int -&gt; IO t</code></li>
<li>Implement this specialized version of the function you've chosen</li>
</ol>
<details><summary>Solution for liftA2</summary>
<pre><code class="language-hs">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</code></pre>
<details><summary>Solution for (1)</summary>
<pre><code class="language-hs">-- Specialize: replace `f` with `ReaderT Env IO`
liftA2 :: (a -&gt; b -&gt; c) -&gt; ReaderT Env IO a -&gt; ReaderT Env IO b -&gt; ReaderT Env IO c
</code></pre>
</details>
<details><summary>Solution for (2)</summary>
<pre><code class="language-hs">-- Unpack the newtype, replacing `ReaderT Env IO a` with `Env -&gt; IO a`
liftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
</code></pre>
</details>
<details><summary>Solution for (3)</summary>
<pre><code class="language-hs">specialLiftA2 :: (a -&gt; b -&gt; c) -&gt; (Env -&gt; IO a) -&gt; (Env -&gt; IO b) -&gt; (Env -&gt; IO c)
specialLiftA2 combine funcA funcB env =
  liftA2 combine (funcA env) (funcB env)
</code></pre>
<p>Notice how the job of our special <code>liftA2</code> for <code>ReaderT</code> is to supply the
two functions with <code>env</code>, and then use the <code>liftA2</code>
implementation of the underlying <code>m</code> type (in our case <code>IO</code>) to do the rest of the work.
Does it look like we're adding a capability on top of a different <code>m</code>?
That's the idea behind monad transformers.</p>
</details>
</details>
</blockquote>
<h3 id="how-to-use-reader"><a class="header" href="#how-to-use-reader">How to use Reader</a></h3>
<h4 id="defining-a-function"><a class="header" href="#defining-a-function">Defining a function</a></h4>
<p>Instead of defining a function like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
</code></pre>
<p>We define it like this:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
</code></pre>
<p>Now that our code uses <code>Reader</code>, we have to accommodate that in the way we write our functions.</p>
<p>Before:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: Env -&gt; [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml env txtFiles =
 let
   txtOutputFiles = map toOutputMarkupFile txtFiles
   index = (&quot;index.html&quot;, buildIndex env txtOutputFiles)
   htmlPages = map (convertFile env) txtOutputFiles
 in
   map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we needed to thread the <code>env</code> to the other functions that use it.</p>
<p>After:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; Reader Env [(FilePath, String)]
txtsToRenderedHtml txtFiles = do
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
  index &lt;- (,) &quot;index.html&quot; &lt;$&gt; buildIndex txtOutputFiles
  htmlPages &lt;- traverse convertFile txtOutputFiles
  pure $ map (fmap Html.render) (index : htmlPages)
</code></pre>
<p>Note how we use <em>do notation</em> now, and <em>instead of threading</em> <code>env</code> around we <em>compose</em>
the relevant functions, <code>buildIndex</code> and <code>convertFile</code>, we use the type classes
interfaces to compose the functions. Note how we needed to <code>fmap</code> over <code>buildIndex</code>
to add the output file we needed with the tuple, and how we needed to use <code>traverse</code> instead
of <code>map</code> to compose the various <code>Reader</code> values <code>convertFile</code> will produce.</p>
<h3 id="extracting-env"><a class="header" href="#extracting-env">Extracting <code>Env</code></a></h3>
<p>When we want to use our <code>Env</code>, we need to <em>extract</em> it from the <code>Reader</code>.
We can do it with:</p>
<pre><code class="language-hs">ask :: ReaderT r m r
</code></pre>
<p>Which yanks the <code>r</code> from the <code>Reader</code> - we can extract with <code>&gt;&gt;=</code> or <code>&lt;-</code> in do notation.
See the comparison:</p>
<p>Before:</p>
<pre><code class="language-hs">convertFile :: Env -&gt; (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile env (file, doc) =
  (file, convert env (takeBaseName file) doc)
</code></pre>
<p>After:</p>
<pre><code class="language-hs">convertFile :: (FilePath, Markup.Document) -&gt; Reader Env (FilePath, Html.Html)
convertFile (file, doc) = do
  env &lt;- ask
  pure (file, convert env (takeBaseName file) doc)
</code></pre>
<blockquote>
<p>Note: we didn't change <code>convert</code> to use <code>Reader</code> because it is a user facing API for our
library. By providing a simpler interface we allow more users to use our library -
even those that aren't yet familiar with monad transformers.</p>
<p>Providing a simple function argument passing interface is preferred in this case.</p>
</blockquote>
<h3 id="run-a-reader"><a class="header" href="#run-a-reader">Run a <code>Reader</code></a></h3>
<p>Similar to handling the errors with <code>Either</code>, at some point we need to supply the environment to
a computation that uses <code>Reader</code>, and extract the result from the computation.
We can do that with the functions <code>runReader</code> and <code>runReaderT</code>:</p>
<pre><code class="language-hs">runReader :: Reader r a -&gt; (r -&gt; a)

runReaderT :: ReaderT r m a -&gt; (r -&gt; m a)
</code></pre>
<p>These functions convert a <code>Reader</code> or <code>ReaderT</code> to a function that takes <code>r</code>.
Then we can pass the initial environment to that function:</p>
<pre><code class="language-hs">convertDirectory :: Env -&gt; FilePath -&gt; FilePath -&gt; IO ()
convertDirectory env inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = runReader (txtsToRenderedHtml filesToProcess) env
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>See the <code>let outputHtmls</code>part.</p>
<h3 id="extra-transforming-env-for-a-particular-call"><a class="header" href="#extra-transforming-env-for-a-particular-call">Extra: Transforming <code>Env</code> for a particular call</a></h3>
<p>Sometimes we may want to modify the <code>Env</code> we pass to a particular function call.
For example, we may have a general <code>Env</code> type that contains a lot of information, and
functions that only need a part of that information.</p>
<p>If the functions we are calling are like <code>convert</code> and take the environment as an
argument instead of a <code>Reader</code>, we can just extract the environment
with <code>ask</code>, apply a function to the extracted environment,
and pass the result to the function, like this:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  pure (inner (extractSmallEnv env))

inner :: SmallEnv -&gt; MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>But if <code>inner</code> uses a <code>Reader SmallEnv</code> instead of argument passing,
we can use <code>runReader</code> to <em>convert <code>inner</code> to a normal function</em>,
and use the same idea as above!</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = do
  env &lt;- ask
  -- Here the type of `runReader inner` is `SmallEnv -&gt; MyResult`
  pure (runReader inner (extractSmallEnv env))

inner :: Reader SmallEnv MyResult
inner = ...

extractSmallEnv :: BigEnv -&gt; SmallEnv
extractSmallEnv = ...
</code></pre>
<p>This pattern is generalized and captured by a function called
<a href="https://hackage.haskell.org/package/transformers-0.6.0.2/docs/Control-Monad-Trans-Reader.html#v:withReaderT">withReaderT</a>,
and works even for <code>ReaderT</code>:</p>
<pre><code class="language-hs">withReaderT :: (env2 -&gt; env1) -&gt; ReaderT env1 m a -&gt; ReaderT env2 m a
</code></pre>
<p><code>withReaderT</code> takes a function that modifies the environment,
and converts a <code>ReaderT env1 m a</code> computation to a <code>ReaderT env2 m a</code> computation
using this function.</p>
<p>Let's see it concretely with our example:</p>
<pre><code class="language-hs">outer :: Reader BigEnv MyResult
outer = withReaderT extractSmallEnv inner
</code></pre>
<hr />
<p>Question: what is the type of <code>withReaderT</code> when specialized in our case?</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">withReaderT
  :: (BigEnv -&gt; SmallEnv)     -- This is the type of `extractSmallEnv`
  -&gt; Reader SmallEnv MyResult -- This is the type of `inner`
  -&gt; Reader BigEnv   MyResult -- This is the type of `outer`
</code></pre>
</details>
<hr />
<p>Note the order of the environments! We use a function from a <code>BigEnv</code> to a <code>SmallEnv</code>,
to convert a <code>Reader</code> of <code>SmallEnv</code> to a <code>Reader</code> of <code>BigEnv</code>!</p>
<p>This is because we are mapping over the <em>input</em> of a function rather than the <em>output</em>,
and is related to topics like variance and covariance, but isn't terribly important
for us at the moment.</p>
<h3 id="using-env-in-our-logic-code"><a class="header" href="#using-env-in-our-logic-code">Using <code>Env</code> in our logic code</a></h3>
<p>One thing we haven't talked about yet is using our environment in the <code>convert</code>
function to generate the pages we want. And actually, we don't even have the ability to add
stylesheets to our HTML EDSL at the moment! We need to go back and extend it. Let's do all
that now:</p>
<hr />
<p>Since stylesheets go in the <code>head</code> element, perhaps it's a good idea to create an additional
<code>newtype</code> like <code>Structure</code> for <code>head</code> information? Things like title, stylesheet,
and even meta elements can be composed together just like we did for <code>Structure</code>
to build the <code>head</code>!</p>
<ol>
<li>
<p>Do it now: extend our HTML library to include headings and add 3 functions:
<code>title_</code> for titles, <code>stylesheet_</code> for stylesheets, and <code>meta_</code> for meta elements
like <a href="https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/abouts-cards">twitter cards</a>.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Html.hs</summary>
<pre><code class="language-hs">-- Html.hs

module HsBlog.Html
  ( Html
  , Head
  , title_
  , stylesheet_
  , meta_
  , Structure
  , html_
  , p_
  , h_
  , ul_
  , ol_
  , code_
  , Content
  , txt_
  , img_
  , link_
  , b_
  , i_
  , render
  )
  where

import Prelude hiding (head)
import HsBlog.Html.Internal
</code></pre>
</details>
<details><summary>src/HsBlog/Html/Internal.hs</summary>
<pre><code class="language-hs">newtype Head
  = Head String

-- * EDSL

html_ :: Head -&gt; Structure -&gt; Html
html_ (Head head) content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; head
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

-- * Head

title_ :: String -&gt; Head
title_ = Head . el &quot;title&quot; . escape

stylesheet_ :: FilePath -&gt; Head
stylesheet_ path =
  Head $ &quot;&lt;link rel=\&quot;stylesheet\&quot; type=\&quot;text/css\&quot; href=\&quot;&quot; &lt;&gt; escape path &lt;&gt; &quot;\&quot;&gt;&quot;

meta_ :: String -&gt; String -&gt; Head
meta_ name content =
  Head $ &quot;&lt;meta name=\&quot;&quot; &lt;&gt; escape name &lt;&gt; &quot;\&quot; content=\&quot;&quot; &lt;&gt; escape content &lt;&gt; &quot;\&quot;&gt;&quot;

instance Semigroup Head where
  (&lt;&gt;) (Head h1) (Head h2) =
    Head (h1 &lt;&gt; h2)

instance Monoid Head where
  mempty = Head &quot;&quot;
</code></pre>
</details>
</details>
</li>
<li>
<p>Fix <code>convert</code> and <code>buildIndex</code> to use the new API. Note: <code>buildIndex</code> should return
<code>Reader</code>!</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog/Convert.hs</summary>
<pre><code class="language-hs">import Prelude hiding (head)
import HsBlog.Env (Env(..))

convert :: Env -&gt; String -&gt; Markup.Document -&gt; Html.Html
convert env title doc =
  let
    head =
      Html.title_ (eBlogName env &lt;&gt; &quot; - &quot; &lt;&gt; title)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
    article =
      foldMap convertStructure doc
    websiteTitle =
      Html.h_ 1 (Html.link_ &quot;index.html&quot; $ Html.txt_ $ eBlogName env)
    body =
      websiteTitle &lt;&gt; article
  in
    Html.html_ head body
</code></pre>
</details>
<details><summary>src/HsBlog/Directory.hs</summary>
<pre><code class="language-hs">buildIndex :: [(FilePath, Markup.Document)] -&gt; Reader Env Html.Html
buildIndex files = do
  env &lt;- ask
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Head 1 head : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ head))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  pure $ Html.html_
      ( Html.title_ (eBlogName env)
        &lt;&gt; Html.stylesheet_ (eStylesheetPath env)
      )
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )
</code></pre>
</details>
</details>
</li>
<li>
<p>Create a command-line parser for <code>Env</code>, attach it to the <code>convert-dir</code> command,
and pass the result it to the <code>convertDirectory</code> function.</p>
<details><summary>Solution</summary>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">import HsBlog.Env (defaultEnv)

convertSingle :: String -&gt; Handle -&gt; Handle -&gt; IO ()

process :: String -&gt; String -&gt; String
process title = Html.render . convert defaultEnv title . Markup.parse
</code></pre>
</details>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">import HsBlog.Env

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath Env
  deriving Show

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir &lt;*&gt; pEnv

-- | Parser for blog environment
pEnv :: Parser Env
pEnv =
  Env &lt;$&gt; pBlogName &lt;*&gt; pStylesheet

-- | Blog name parser
pBlogName :: Parser String
pBlogName =
  strOption
    ( long &quot;name&quot;
      &lt;&gt; short 'N'
      &lt;&gt; metavar &quot;STRING&quot;
      &lt;&gt; help &quot;Blog name&quot;
      &lt;&gt; value (eBlogName defaultEnv)
      &lt;&gt; showDefault
    )

-- | Stylesheet parser
pStylesheet :: Parser String
pStylesheet =
  strOption
    ( long &quot;style&quot;
      &lt;&gt; short 'S'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Stylesheet filename&quot;
      &lt;&gt; value (eStylesheetPath defaultEnv)
      &lt;&gt; showDefault
    )

</code></pre>
</details>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output env -&gt;
      HsBlog.convertDirectory env input output

    ...
</code></pre>
</details>
</details>
</li>
</ol>
<hr />
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Which version do you like better? Manually passing arguments, or using <code>Reader</code>?</p>
<p>To me, it is not clear that the second version with <code>Reader</code> is better than the first
with explicit argument passing in our particular case.</p>
<p>Using <code>Reader</code> and <code>ReaderT</code> makes our code a little less friendly toward beginners
that are not yet familiar with these concepts and techniques, and we don't see
(in this case) much benefit.</p>
<p>As programs grow larger, techniques like using <code>Reader</code> become more attractive to use.
For our relatively small example, using <code>Reader</code> might not be appropriate.
I've included it in this book because it is an important technique to have in our
arsenal and I wanted to demonstrate it.</p>
<p>It is important to weigh the benefits and costs of using advanced techniques,
and it's often better to try and get away with simpler techniques if we can.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/f9fe7179fcf0e6c818f6caa860b52e991432dab2">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/f9fe7179fcf0e6c818f6caa860b52e991432dab2">code up until now</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="06-errors_and_files/05-summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="08-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="06-errors_and_files/05-summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="08-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
