<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lets code already! - Learning Haskell by building a static blog generator</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learning Haskell by building a static blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://gilmi.me/static/misc/blog-stuff/gilmi.jpg">
        <meta name="twitter:image-alt" content="gilmi's avatar, a simply drawn koala hanging on a branch">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="../../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="../../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="../../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li><li class="chapter-item expanded "><a href="../../05-glue/05-multiple_files.html"><strong aria-hidden="true">5.5.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../05-glue/05-errors/01-either.html"><strong aria-hidden="true">5.5.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="../../05-glue/05-errors/02-except.html"><strong aria-hidden="true">5.5.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="../../05-glue/05-errors/03-exceptions.html"><strong aria-hidden="true">5.5.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="../../05-glue/05-errors/04-implementation.html" class="active"><strong aria-hidden="true">5.5.4.</strong> Lets code already!</a></li><li class="chapter-item expanded "><a href="../../05-glue/05-errors/05-summary.html"><strong aria-hidden="true">5.5.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../../05-glue/06-environment.html"><strong aria-hidden="true">5.6.</strong> Passing an environment</a></li></ol></li><li class="chapter-item expanded "><a href="../../06-testing.html"><strong aria-hidden="true">6.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="../../07-next.html"><strong aria-hidden="true">7.</strong> Where to go next</a></li><li class="chapter-item expanded "><a href="../../08-faq.html"><strong aria-hidden="true">8.</strong> Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Haskell by building a static blog generator</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lets-code-already"><a class="header" href="#lets-code-already">Lets code already!</a></h1>
<p>This was a long info dump. Let's practice what we've learned. We want to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension, we want to process <code>txt</code> file and</li>
<li>copy other files without modification</li>
<li>We want to parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<blockquote>
<p>Note: I did not write this code immediately in the final form it was presented.
It was an iterative process of writing code, refactoring, splitting functions, changing
type signatures, and more. When reaching a coding problem, start small and simple,
do the thing that works, and refactor it when it makes sense and makes the code clearer
and more modular. In Haskell we pride ourselves in our ability to refactor code and improve
it over time, and that principle holds when writing new software as well!</p>
</blockquote>
<h2 id="new-module"><a class="header" href="#new-module">New module</a></h2>
<p>Let's create a new module, <code>HsBlog.Directory</code>, which will be responsible for handling
directories and multiple files. From this module we will export the <code>convertDirectory</code>
and <code>buildIndex</code> functions we've defined before.</p>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
</code></pre>
<p>In this module we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html">directory</a>
and <a href="https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html">filepath</a>
libraries to manipulate directories, files and filepaths.
We'll use the new abstractions we've learned <code>Traversable</code> and <code>Monad</code> and the concepts
and types we've learned about: <code>Either</code>, <code>IO</code> and exceptions.</p>
<p>For all of that, we need quite a few imports:</p>
<pre><code class="language-hs">import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
</code></pre>
<p>If you are unsure what a specific function we're using does, look it up at good,
read the type signature and the documentation, and play around with it in <code>ghci</code>.</p>
<h2 id="converting-a-directory"><a class="header" href="#converting-a-directory">Converting a directory</a></h2>
<p>We can start by describing the high-level function <code>convertDirectory</code> which
encapsulates many smaller functions, each responsible on doing a specific thing.
<code>convertDirectory</code> is quite imperative looking, and looks like a different way to
describe the steps of completing our task:</p>
<pre><code class="language-hs">-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>Here we trust that each <code>IO</code> function handles errors responsibly,
and terminates the project when necessary.</p>
<p>Let's examine the steps in order.</p>
<h3 id="getdirfilesandcontent"><a class="header" href="#getdirfilesandcontent"><code>getDirFilesAndContent</code></a></h3>
<pre><code class="language-hs">-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents

</code></pre>
<p><code>getDirFilesAndContent</code> is responsible for providing the relevant files for processing.
Both the ones we need to convert to markup (and their textual content) and other files we
might want to copy as-is (such as images and style-sheets).</p>
<pre><code class="language-hs">-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
</code></pre>
<p>This functions does 4 important things:</p>
<ol>
<li>List all the files in the directory</li>
<li>Split the files to 2 groups according to their file extension</li>
<li>Read the contents of the .txt files and report when files failed to read</li>
<li>Return the results. We've defined a data type to make what each result more obvious</li>
</ol>
<p>Part (3) is a little bit more involved than the rest, lets explore it.</p>
<h4 id="applyioonlist"><a class="header" href="#applyioonlist"><code>applyIoOnList</code></a></h4>
<pre><code class="language-hs">-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)
</code></pre>
<p><code>applyIoOnList</code> is a higher order function that applies a particular <code>IO</code> function
(in our case <code>readFile</code>) on a list of things (In our case <code>FilePath</code>s),
and for each thing, it returns the thing itself along with the result of
applying the <code>IO</code> function as an <code>Either</code>, where the <code>Left</code> side is a <code>String</code>
representation of an error if one occurred.</p>
<p>Notice how much the type of this function tells us about what it might do.
Because the types are polymorphic, there is nothing else to do with with
the <code>a</code>s other than apply them to the function, and nowhere to generate <code>b</code>
from other than the result of the function.</p>
<blockquote>
<p>Note: when I first wrote this function, it was specialized to work only on <code>readFile</code>,
take specifically <code>[FilePath]</code> and return <code>IO [(FilePath, Either String String)]</code>.
But after running into other use cases where I could use it (<code>writeFiles</code> and <code>copyFiles</code>)
I refactored out the <code>action</code>, the input type and the return type.</p>
</blockquote>
<p>This function uses exceptions to catch any error that might be thrown, and encoding
both the failure and success cases in the type system using <code>Either</code>, delaying
the handling of exceptions to the caller of the function while making sure it won't
be forgotten!</p>
<p>Next, let's look at the function that handles the errors by reporting and then filtering out
all the cases that failed.</p>
<h4 id="filterandreportfailures"><a class="header" href="#filterandreportfailures"><code>filterAndReportFailures</code></a></h4>
<pre><code class="language-hs">-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]
</code></pre>
<p>This code may seem a bit surprising - how come we can use <code>foldMap</code> here? Reminder,
the type of <code>foldMap</code> is:</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</code></pre>
<p>If we specialize this function for our use case, substituting the general type
with the types we are using, we learn that <code>IO [(a, b)]</code> is a monoid.
And indeed - <code>[a]</code> is a monoid for any <code>a</code> with <code>[]</code> (the empty list) as <code>mempty</code>
and <code>++</code> as <code>&lt;&gt;</code>, but also <code>IO a</code> is a monoid for any <code>a</code> that is itself
a monoid with <code>pure mempty</code> as <code>mempty</code> and <code>liftA2 (&lt;&gt;)</code> as <code>&lt;&gt;</code>!</p>
<p>Using these instances, we can <code>map</code> over the content, handling errors and returning
an empty list to filter a failed case out, or a singleton list to keep the result.
and the <code>fold</code> in <code>foldMap</code> will concatenate the resulting list where we return
all of the successful cases!</p>
<p>These functions were responsible for fetching the right information. Next,
let's look at the code for creating a new directory.</p>
<h3 id="createoutputdirectoryorexit"><a class="header" href="#createoutputdirectoryorexit"><code>createOutputDirectoryOrExit</code></a></h3>
<pre><code class="language-hs">-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
</code></pre>
<p><code>createOutputDirectoryOrExit</code> itself is not terribly exciting, it does
what it is named after, it tries to create the output directory, and exits the
program in case it didn't succeed.</p>
<p><code>createOutputDirectory</code> is the function that actually does the heavy lifting.
It checks if the directory already exists, and checks if the user would like to
override it. If they do, we remove it and create the new directory, if they don't,
we do nothing and report their decision.</p>
<h3 id="txtstorenderedhtml"><a class="header" href="#txtstorenderedhtml"><code>txtsToRenderedHtml</code></a></h3>
<pre><code class="language-hs">let
  outputHtmls = txtsToRenderedHtml filesToProcess
</code></pre>
<p>In this part of the code we convert files to markup and change the
input file paths into their respective output file paths (<code>.txt</code> -&gt; <code>.html</code>),
we then build the index page, and convert everything to HTML.</p>
<pre><code class="language-hs">-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
</code></pre>
<p>One possibly surprising thing about this could could be the <code>map (fmap Html.render)</code>
part. We can use <code>fmap</code> on the tuple because it is a <code>Functor</code> on the second
argument, just like <code>Either</code>!</p>
<h3 id="copyfiles-and-writefiles"><a class="header" href="#copyfiles-and-writefiles"><code>copyFiles</code> and <code>writeFiles</code></a></h3>
<p>The only thing left to do after the processing is complete is to write the directory
content after processing to the newly created directory:</p>
<pre><code class="language-hs">-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Here we use <code>applyIoOnList</code> again to do something a bit more complicated,
instead of reading from a file, it copies from the input path to a newly generated
output path. Then we pass the result (which has the type <code>[(FilePath, Either String ())]</code>)
to <code>filterAndReportFailures</code> to print the errors and filter out the unsuccessful copies.
Because we are not really interested in the output of <code>filterAndReportFailures</code>,
we discard it with <code>void</code>, returning <code>()</code> as a result instead.</p>
<pre><code class="language-hs">-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Once again, this code looks almost exactly like <code>copyFiles</code>, but the types are different.
Haskell's combination of parametric polymorphism + type class for abstractions is really
powerful, and has helped us reduce quite a bit of code.</p>
<hr />
<p>This pattern of using <code>applyIoOnList</code> and then <code>filterAndReportFailures</code>
happens more than once. It might be a good candidate for refactoring. Try it!
What do you think about the resulting code? Is it easier or more difficult to
understand? Is it more modular or less? What are the pros and cons?</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>With that, we have completed our <code>HsBlog.Directory</code> module that handles converting
a directory safely. Note that code could probably be simplified quite a bit if we
were fine with errors crashing the entire program altogether, but sometimes this is
the price we pay for robustness. It is up to you to choose what you can live with
and what not, but I hope this saga have taught you how to approach handling errors
in Haskell in case you need to.</p>
<hr />
<p>View the full module:</p>
<details><summary>HsBlog.Directory</summary>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;

------------------------------------
-- * Read directory content

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

------------------------------------
-- * Build index page

buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Header 1 header : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ header))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h1_ (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )

------------------------------------
-- * Conversion

-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * Output to directory

-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures

-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures

------------------------------------
-- * IO work and handling errors

-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action files = do
  for files $ \file -&gt; do
    maybeContent &lt;-
      catch
        (Right &lt;$&gt; action file)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (file, maybeContent)

-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \ (file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]

------------------------------------
-- * Utilities

confirm :: String -&gt; IO Bool
confirm question = do
  putStrLn (question &lt;&gt; &quot; (y/n)&quot;)
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. Use y or n.&quot;
      confirm question

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../05-glue/05-errors/03-exceptions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../05-glue/05-errors/05-summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../05-glue/05-errors/03-exceptions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../05-glue/05-errors/05-summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
