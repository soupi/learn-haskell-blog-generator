<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Safer HTML construction with types - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html" class="active"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="../08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="../09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="../10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="../12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="safer-html-construction-with-types"><a class="header" href="#safer-html-construction-with-types">Safer HTML construction with types</a></h1>
<p>In this section, we'll learn how to create our own distinguished types
for HTML, and how they can help us avoid the invalid construction of HTML strings.</p>
<p>There are a few ways of defining new types in Haskell; in this section,
we are going to meet two ways: <code>newtype</code> and <code>type</code>.</p>
<h2 id="newtype"><a class="header" href="#newtype"><code>newtype</code></a></h2>
<p>A <code>newtype</code> declaration is a way to define a new, distinct type for an existing set of values.
This is useful when we want to reuse existing values but give them a different meaning
and ensure we can't mix the two.
For example, we can represent seconds, minutes, grams, and yens using integer values,
but we don't want to mix grams and seconds accidentally.</p>
<p>In our case, we want to represent structured HTML using textual values,
but distinguish them from everyday strings that are not valid HTML.</p>
<p>A <code>newtype</code> declaration looks like this:</p>
<pre><code>newtype &lt;type-name&gt; = &lt;constructor&gt; &lt;existing-type&gt;
</code></pre>
<p>For example, in our case, we can define a distinct type for <code>Html</code> like this:</p>
<pre><code class="language-hs">newtype Html = Html String
</code></pre>
<p>The first <code>Html</code>, to the left of the equals sign, lives in the <em>types</em>
name space, meaning that you will only see that name to the right of a
double-colon sign (<code>::</code>).</p>
<p>The second <code>Html</code> lives in the <em>expressions</em> (or terms/values) namespace,
meaning that you will see it where you expect expressions (we'll touch where
exactly that can be in a moment).</p>
<p>The two names, <code>&lt;type-name&gt;</code> and <code>&lt;constructor&gt;</code>, do not have to be the
same, but they often are. And note that both have to start with a
capital letter.</p>
<p>The right-hand side of the newtype declaration describes the shape of a
value of that type. In our case, we expect a value of
type <code>Html</code> to have the constructor <code>Html</code> and then an expression of
type string, for example: <code>Html &quot;hello&quot;</code> or <code>Html (&quot;hello &quot; &lt;&gt; &quot;world&quot;)</code>.</p>
<p>You can think of the constructor as a function that takes the argument
and returns something of our new type:</p>
<pre><code class="language-hs">Html :: String -&gt; Html
</code></pre>
<p><strong>Note</strong>: We cannot use an expression of type <code>Html</code> the same way we'd
use a <code>String</code>. So <code>&quot;hello &quot; &lt;&gt; Html &quot;world&quot;</code> would fail at type
checking.</p>
<p>This is useful when we want <em>encapsulation</em>. We can define and use
existing representation and functions for our underlying type, but not
mix them with other unrelated (to our domain) types. Similar as
meters and feet can both be numbers, but we don't want to accidentally
add feet to meters without any conversion.</p>
<hr />
<p>For now, let's create a couple of types for our use case.
We want two separate types to represent:</p>
<ol>
<li>A complete Html document</li>
<li>A type for html structures such as headings and paragraphs that can go inside the <body> tag</li>
</ol>
<p>We want them to be distinct because we don't want to mix them.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">newtype Html = Html String

newtype Structure = Structure String
</code></pre>
</details>
<hr />
<h2 id="using-newtypes"><a class="header" href="#using-newtypes">Using <code>newtype</code>s</a></h2>
<p>To use the underlying type that the newtype wraps, we first
need to extract it out of the type. We do this using pattern matching.</p>
<p>Pattern matching can be used in two ways, in case-expressions and in
function definitions.</p>
<ol>
<li>
<p>case expressions are kind of beefed up switch expressions and look like this:</p>
<pre><code>case &lt;expression&gt; of
  &lt;pattern&gt; -&gt; &lt;expression&gt;
  ...
  &lt;pattern&gt; -&gt; &lt;expression&gt;
</code></pre>
<p>The <code>&lt;expression&gt;</code> is the thing we want to unpack, and the <code>pattern</code>
is its concrete shape. For example, if we wanted to extract the <code>String</code>
out of the type <code>Structure</code> we defined in the exercise above, we do:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString struct =
  case struct of
    Structure str -&gt; str
</code></pre>
<p>This way, we can extract the <code>String</code> out of <code>Structure</code> and return
it.</p>
<blockquote>
<p>In later chapters we'll introduce <code>data</code> declarations (which are kind of
a struct + enum chimera), where we can define multiple constructors to
a type. Then the multiple patterns of a case expression will make more
sense.</p>
</blockquote>
</li>
<li>
<p>Alternatively, when declaring a function, we can also use pattern matching on the
arguments:</p>
<pre><code>func &lt;pattern&gt; = &lt;expression&gt;
</code></pre>
<p>For example:</p>
<pre><code class="language-hs">getStructureString :: Structure -&gt; String
getStructureString (Structure str) = str
</code></pre>
<p>Using the types we created, we can change the HTML functions we've defined before,
namely <code>html_</code>, <code>body_</code>, <code>p_</code>, etc., to operate on these types instead of <code>String</code>s.</p>
<p>But first, let's meet another operator that will make our code more concise.</p>
</li>
</ol>
<p>One very cool thing about <code>newtype</code> is that wrapping and extracting expressions doesn't actually
have a performance cost! The compiler knows how to remove any wrapping and extraction
of the <code>newtype</code> constructor and use the underlying type.</p>
<p>The new type and the constructor we defined are only there to help us <em>distinguish</em> between
the type we created and the underlying type when <em>we write our code</em>, they are not
needed <em>when the code is running</em>.</p>
<p><code>newtype</code>s provide us with type safety with no performance penalty!</p>
<h2 id="chaining-functions"><a class="header" href="#chaining-functions">Chaining functions</a></h2>
<p>Another interesting and extremely common operator
(which is a regular library function in Haskell) is <code>.</code> (pronounced compose).
This operator was made to look like the composition operator
you may know from math (<code>∘</code>).</p>
<p>Let's look at its type and implementation:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) f g x = f (g x)
</code></pre>
<p>Compose takes 3 arguments: two functions (named <code>f</code> and <code>g</code> here) and
a third argument named <code>x</code>. It then passes the argument <code>x</code> to the second
function <code>g</code> and calls the first function <code>f</code> with the result of <code>g x</code>.</p>
<p>Note that <code>g</code> takes as input something of the type
<code>a</code> and returns something of the type <code>b</code>, and <code>f</code> takes
something of the type <code>b</code> and returns something of the type <code>c</code>.</p>
<p>Another important thing to note is that types that start with
a <em>lowercase letter</em> are <strong>type variables</strong>.
Think of them as similar to regular variables. Just like
<code>content</code> could be any string, like <code>&quot;hello&quot;</code> or <code>&quot;world&quot;</code>, a type variable
can be any type: <code>Bool</code>, <code>String</code>, <code>String -&gt; String</code>, etc.
This ability is called <em>parametric polymorphism</em> (other languages often call this generics).</p>
<p>The catch is that type variables must match in a signature, so if for
example, we write a function with the type signature <code>a -&gt; a</code>, the
input type and the return type <strong>must</strong> match, but it could be
any type - we cannot know what it is. So the only way to implement a
function with that signature is:</p>
<pre><code class="language-hs">id :: a -&gt; a
id x = x
</code></pre>
<p><code>id</code>, short for the identity function, returns the exact value it received.
If we tried any other way, for example, returning some made-up value
like <code>&quot;hello&quot;</code>, or trying to use <code>x</code> as a value of a type we know, like
writing <code>x + x</code>, the type checker will complain.</p>
<p>Also, remember that <code>-&gt;</code> is right-associative? This signature is equivalent to:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Doesn't it look like a function that takes two functions and returns a
third function that is the composition of the two?</p>
<p>We can now use this operator to change our HTML functions. Let's start
with one example: <code>p_</code>.</p>
<p>Before, we had:</p>
<pre><code class="language-hs">p_ :: String -&gt; String
p_ = el &quot;p&quot;
</code></pre>
<p>And now, we can write:</p>
<pre><code class="language-hs">p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;
</code></pre>
<p>The function <code>p_</code> will take an arbitrary <code>String</code>, which is the content
of the paragraph we wish to create, wrap it in <code>&lt;p&gt;</code> and <code>&lt;/p&gt;</code> tags,
and then wrap it in the <code>Structure</code> constructor to produce the
output type <code>Structure</code> (remember: newtype constructors can be used as functions!).</p>
<p>Let's take a deeper look at the types:</p>
<ul>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
<li><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code></li>
<li><code>Structure . el &quot;p&quot; :: String -&gt; Structure</code></li>
</ul>
<p>Let's see why the expression <code>Structure . el &quot;p&quot;</code> type checks,
and why its type is <code>String -&gt; Structure</code>.</p>
<h3 id="type-checking-with-pen-and-paper"><a class="header" href="#type-checking-with-pen-and-paper">Type checking with pen and paper</a></h3>
<p>If we want to figure out if and how exactly an expression type-checks,
we can do that rather systematically. Let's look at an example
where we try and type-check this expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>First, we write down the type of the outer-most function. In
our case, this is the operator <code>.</code> which has the type:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>After that, we can try to <strong>match</strong> the type of the arguments we
apply to this function with the type of the arguments from the type signature.</p>
<p>In this case, we try to apply two arguments to <code>.</code>:</p>
<ol>
<li><code>Structure :: String -&gt; Structure</code></li>
<li><code>el &quot;p&quot; :: String -&gt; String</code></li>
</ol>
<p>And luckily, <code>.</code> expects two arguments with the types:</p>
<ol>
<li><code>b -&gt; c</code></li>
<li><code>a -&gt; b</code></li>
</ol>
<blockquote>
<p>Note: Applying a function with more arguments than it expects is a type error.</p>
</blockquote>
<p>Since the <code>.</code> operator takes at least the number of arguments we supply, we continue
to the next phase of type-checking: matching the types of the inputs with the types
of the expected inputs (from the type signature of the operator).</p>
<p>When we match two types, we check for <em>equivalence</em> between them. There are a few
possible scenarios here:</p>
<ol>
<li>When the two types are <strong>concrete</strong> (as opposed to type variables)
and <strong>simple</strong>, like <code>Int</code> and <code>Bool</code>,
we check if they are the same. If they are, they type check, and we continue.
If they aren't, they don't type check, and we throw an error.</li>
<li>When the two types we match are more <strong>complex</strong> (for example, both are functions),
we try to match their inputs and outputs (in the case of functions). If the inputs and outputs
match, then the two types match.</li>
<li>There is a special case when one of the types is a <strong>type variable</strong> -
in this case, we treat the matching process like an equation and write it down somewhere.
The next time we see this type variable, we <em>replace it with its match in the equation</em>.
Think about this like <em>assigning</em> a type <em>variable</em> with a <em>value</em>.</li>
</ol>
<p>In our case, we want to match (or check the equivalence of) these types:</p>
<ol>
<li><code>String -&gt; Structure</code> with <code>b -&gt; c</code></li>
<li><code>String -&gt; String</code> with <code>a -&gt; b</code></li>
</ol>
<p>Let's do this one by one, starting with (1) - matching <code>String -&gt; Structure</code> and <code>b -&gt; c</code>:</p>
<ol>
<li>Because the two types are complex, we check that they are both functions, match their
inputs and outputs: <code>String</code> with <code>b</code>, and <code>Structure</code> with <code>c</code>.</li>
<li>Because <code>b</code> is a <em>type variable</em>, we mark down somewhere that <code>b</code> should
be equivalent to <code>String</code>.
We write <code>b ~ String</code> (we use <code>~</code> to denote equivalence).</li>
<li>We match <code>Structure</code> and <code>c</code>, same as before, we write down that <code>c ~ Structure</code>.</li>
</ol>
<p>No problem so far; let's try matching <code>String -&gt; String</code> with <code>a -&gt; b</code>:</p>
<ol>
<li>The two types are complex; we see that both are functions, so we match
their inputs and outputs.</li>
<li>Matching <code>String</code> with <code>a</code> - we write down that <code>a ~ String</code>.</li>
<li>Matching <code>String</code> with <code>b</code> - we remember that we have already written
about <code>b</code> - looking back, we see that we already noted that <code>b ~ String</code>.
We need to replace <code>b</code> with the type that we wrote down before and
check it against this type, so we match <code>String</code> with <code>String</code> 
which, fortunately, type-check because they are the same.</li>
</ol>
<p>So far, so good. We've type-checked the expression and discovered the following equivalences 
about the type variables in it:</p>
<ol>
<li><code>a ~ String</code></li>
<li><code>b ~ String</code></li>
<li><code>c ~ Structure</code></li>
</ol>
<p>Now, when asking what is the type of the expression:</p>
<pre><code class="language-hs">p_ = Structure . el &quot;p&quot;
</code></pre>
<p>We say that it is the type of <code>.</code> after <em>replacing</em> the type variables using the equations, we found
and <em>removing</em> the inputs we applied to it, so we started with:</p>
<pre><code class="language-hs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
</code></pre>
<p>Then we replaced the type variables:</p>
<pre><code class="language-hs">(.) :: (String -&gt; Structure) -&gt; (String -&gt; String) -&gt; (String -&gt; Structure)
</code></pre>
<p>And removed the two arguments when we applied the function:</p>
<pre><code class="language-hs">Structure . el &quot;p&quot; :: String -&gt; Structure
</code></pre>
<p>And we got the type of expression!</p>
<p>Fortunately, Haskell can do this process for us. But when Haskell complains
that our types fail to type-check, and we don't understand exactly why, going through this process
can help us understand where the types do not match, and then we can figure out how to solve it.</p>
<blockquote>
<p><strong>Note</strong>: If we use a <em>parametrically polymorphic</em> function more than once,
or use different functions that have similar type variable names,
the type variables don't have to match in all instances simply because they share a name.
Each instance has its own unique set of type variables.
For example, consider the following snippet:</p>
<pre><code class="language-hs">incrementChar :: Char -&gt; Char
incrementChar c = chr (ord (id c) + id 1)
</code></pre>
<p>where the types for the functions we use are:</p>
<pre><code class="language-hs">id :: a -&gt; a
ord :: Char -&gt; Int
chr :: Int -&gt; Char
</code></pre>
<p>In the snippet above, we use <code>id</code> twice (for no good reason other than for demonstration purposes).
The first <code>id</code> takes a <code>Char</code> as argument, and its <code>a</code> is equivalent to <code>Char</code>.
The second <code>id</code> takes an <code>Int</code> as argument, and its <em>distinct</em> <code>a</code> is equivalent to <code>Int</code>.</p>
<p>This, unfortunately, only applies to functions defined at the top-level. If we'd define a local function
to be passed as an argument to <code>incrementChar</code> with the same type signature as <code>id</code>,
the types must match in all uses. So this code:</p>
<pre><code class="language-hs">incrementChar :: (a -&gt; a) -&gt; Char -&gt; Char
incrementChar func c = chr (ord (func c) + func 1)
</code></pre>
<p>Will not type check. Try it!</p>
</blockquote>
<h2 id="appending-structure"><a class="header" href="#appending-structure">Appending Structure</a></h2>
<p>Before, when we wanted to create richer HTML content and appended
nodes to one another, we used the append (<code>&lt;&gt;</code>) operator.
Since we are now not using <code>String</code> anymore, we need another way
to do it.</p>
<p>While it is possible to overload <code>&lt;&gt;</code> using a feature in
Haskell called type classes, we will instead create a new function
and call it <code>append_</code>, and cover type classes later.</p>
<p><code>append_</code> should take two <code>Structure</code>s, and return a third <code>Structure</code>,
appending the inner <code>String</code> in the first <code>Structure</code> to the second and wrapping the result back in <code>Structure</code>.</p>
<hr />
<p>Try implementing <code>append_</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">append_ :: Structure -&gt; Structure -&gt; Structure
append_ (Structure a) (Structure b) =
  Structure (a &lt;&gt; b)
</code></pre>
</details>
<hr />
<h2 id="converting-back-html-to-string"><a class="header" href="#converting-back-html-to-string">Converting back <code>Html</code> to <code>String</code></a></h2>
<p>After constructing a valid <code>Html</code> value, we want to be able to
print it to the output so we can display it in our browser.
For that, we need a function that takes an <code>Html</code> and converts it to a <code>String</code>, which we can then pass to <code>putStrLn</code>.</p>
<hr />
<p>Implement the <code>render</code> function.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="type"><a class="header" href="#type"><code>type</code></a></h2>
<p>Let's look at one more way to give new names to types.</p>
<p>A <code>type</code> definition looks really similar to a <code>newtype</code> definition - the only
difference is that we reference the type name directly without a constructor:</p>
<pre><code>type &lt;type-name&gt; = &lt;existing-type&gt;
</code></pre>
<p>For example, in our case, we can write:</p>
<pre><code class="language-hs">type Title = String
</code></pre>
<p><code>type</code>, in contrast with <code>newtype</code>, is just a type name alias.
When we declare <code>Title</code> as a <em>type alias</em> of <code>String</code>,
we mean that <code>Title</code> and <code>String</code> are interchangeable,
and we can use one or the other whenever we want:</p>
<pre><code class="language-hs">&quot;hello&quot; :: Title

&quot;hello&quot; :: String
</code></pre>
<p>Both are valid in this case.</p>
<p>We can sometimes use <code>type</code>s to give a bit more clarity to our code,
but they are much less useful than <code>newtype</code>s which allow us to
<em>distinguish</em> two types with the same type representation.</p>
<h2 id="the-rest-of-the-owl"><a class="header" href="#the-rest-of-the-owl">The rest of the owl</a></h2>
<hr />
<p>Try changing the code we wrote in previous chapters to use the new types we created.</p>
<blockquote>
<p><strong>Tips</strong></p>
<p>We can combine <code>makeHtml</code> and <code>html_</code>, and remove <code>body_</code> <code>head_</code> and <code>title_</code>
by calling <code>el</code> directly in <code>html_</code>, which can now have the type
<code>Title -&gt; Structure -&gt; Html</code>.
This will make our HTML EDSL less flexible but more compact.</p>
<p>Alternatively, we could create <code>newtype</code>s for <code>HtmlHead</code> and <code>HtmlBody</code> and
pass those to <code>html_</code>, and we might do that in later chapters, but I've chosen
to keep the API a bit simple for now, we can always refactor later!</p>
</blockquote>
<details>
  <summary>Solution</summary>
<pre><code class="language-hs">-- hello.hs

main :: IO ()
main = putStrLn (render myhtml)

myhtml :: Html
myhtml =
  html_
    &quot;My title&quot;
    ( append_
      (h1_ &quot;Heading&quot;)
      ( append_
        (p_ &quot;Paragraph #1&quot;)
        (p_ &quot;Paragraph #2&quot;)
      )
    )

newtype Html
  = Html String

newtype Structure
  = Structure String

type Title
  = String

html_ :: Title -&gt; Structure -&gt; Html
html_ title content =
  Html
    ( el &quot;html&quot;
      ( el &quot;head&quot; (el &quot;title&quot; title)
        &lt;&gt; el &quot;body&quot; (getStructureString content)
      )
    )

p_ :: String -&gt; Structure
p_ = Structure . el &quot;p&quot;

h1_ :: String -&gt; Structure
h1_ = Structure . el &quot;h1&quot;

el :: String -&gt; String -&gt; String
el tag content =
  &quot;&lt;&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot; &lt;&gt; content &lt;&gt; &quot;&lt;/&quot; &lt;&gt; tag &lt;&gt; &quot;&gt;&quot;

append_ :: Structure -&gt; Structure -&gt; Structure
append_ c1 c2 =
  Structure (getStructureString c1 &lt;&gt; getStructureString c2)

getStructureString :: Structure -&gt; String
getStructureString content =
  case content of
    Structure str -&gt; str

render :: Html -&gt; String
render html =
  case html of
    Html str -&gt; str
</code></pre>
</details>
<hr />
<h2 id="are-we-safe-yet"><a class="header" href="#are-we-safe-yet">Are we safe yet?</a></h2>
<p>We have made some progress - now we can't write <code>&quot;Hello&quot;</code>
where we'd expect either a paragraph or a heading, but we can still
write <code>Structure &quot;hello&quot;</code> and get something that isn't a
paragraph or a heading. So while we made it harder for the user
to make mistakes by accident, we haven't really been able to <strong>enforce
the invariants</strong> we wanted to enforce in our library.</p>
<p>Next, we'll see how we can make expressions such as <code>Structure &quot;hello&quot;</code> illegal
as well using <em>modules</em> and <em>smart constructors</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../03-html/03-edsls.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../03-html/05-modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../03-html/03-edsls.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../03-html/05-modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>
        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
