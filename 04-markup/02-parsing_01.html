<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parsing markup part 01 (Recursion) - Learning Haskell by building a blog generator</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A step by step guide to learning Haskell by building a simple static blog generator">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this tutorial</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible html content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/09-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/10-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html" class="active"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (typeclasses)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Learning Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parsing-markup-part-01-recursion"><a class="header" href="#parsing-markup-part-01-recursion">Parsing markup part 01 (Recursion)</a></h1>
<p>Let's have a look at how to parse a multi-lined string of markup text
written by a user and convert it to the <code>Document</code> type we defined
in the previous chapter.</p>
<p>Our strategy is to take the string of markup text, and:</p>
<ol>
<li>Split it to a list where each element is a separate line, and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>So the first thing we want to do is to process the string line by line.
We can do that by converting the string to a list of string.
Fortunately the Haskell
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>Prelude</code></a>
module from the Haskell standard library
<a href="https://hackage.haskell.org/package/base"><code>base</code></a> exposes the function
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>
that does exactly what we want. The <code>Prelude</code> module is exposed in every
Haskell file by default so we don't need to import it.</p>
<p>For the line processing part, let's start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<p>A common solution in imperative programs would be to iterate over the lines
using some <em>loop</em> construct and accumulate lines that should be grouped together
into some intermediate mutable variable. When we reach an empty line, we insert
the content of that variable into another mutable variable that accumulates the
results.</p>
<p>Our approach in Haskell isn't so different, except that we do not use loops
or mutable variables. Instead, we use <strong>recursion</strong>.</p>
<h2 id="recursion-and-accumulating-information"><a class="header" href="#recursion-and-accumulating-information">Recursion and accumulating information</a></h2>
<p>Instead of loops, in Haskell we use recursion to model iteration.</p>
<p>Consider the following contrived example: let's say that
we want to write an algorithm for adding two natural numbers together,
and we don't have a standard operation to do that (+), but we do
have two operations we could do for each number: <code>increment</code>
and <code>decrement</code>.</p>
<p>A solution we could come up with is to slowly &quot;pass&quot; one number
to the other number iteratively, by incrementing one, and decrementing the other.
And we do that until the number we decrement reaches 0.</p>
<p>For example for <code>3</code> and <code>2</code>:</p>
<ul>
<li>We start with <code>3</code> and <code>2</code>, and we increment <code>3</code> and decrement <code>2</code></li>
<li>On the next step we now have <code>4</code> and <code>1</code>, we increment <code>4</code> and decrement <code>1</code></li>
<li>On the next step we now have <code>5</code> and <code>0</code>, since the second number is <code>0</code> we declare <code>5</code> as the result.</li>
</ul>
<p>This can be written imperatively using a loop:</p>
<pre><code class="language-js">function sum(n, m) {
    while (m /= 0) {
        n = increment(n);
        m = decrement(m);
    }
    return n;
}
</code></pre>
<p>We can write the same algorithm in Haskell without mutation using recursion:</p>
<pre><code class="language-hs">sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n
</code></pre>
<p><strong>In order to emulate iteration with mutable state, we call the function again
with the values we want the variables to have in the next iteration.</strong></p>
<h3 id="evaluation-of-recursion"><a class="header" href="#evaluation-of-recursion">Evaluation of recursion</a></h3>
<p>Recursion commonly has a bad reputation for being slow and possibly unsafe compared to loops.
This is because in imperative languages, calling a function often requires creating
a new call stack.</p>
<p>However, functional languages (and Haskell in particular) play by different
rules and implement a feature called tail call elimination - when the result of a function call
is the result of this function (this is called tail position), we can just drop the current function
stack frame and then allocate one for the function we call, so we don't require <code>N</code> stack frames
for <code>N</code> iterations.</p>
<p>This is of course only one way to do tail call elimination and other
strategies exists, such as translating code like our recursive <code>sum</code> above to the iteration version.</p>
<h4 id="laziness"><a class="header" href="#laziness">Laziness</a></h4>
<p>Haskell plays by slightly different rules because it uses a lazy evaluation strategy
instead of the much more common strict evaluation strategy. An evaluation strategy
refers to &quot;when do we evaluate a computation&quot;. In a strict language the answer is simple:
<em>we evaluate the arguments of a function before entering a function</em>.</p>
<p>So for example the evaluation of <code>sum (increment 3) (decrement 2)</code> using strict evaluation
will look like this:</p>
<ol>
<li>Evaluate <code>increment 3</code> to <code>4</code></li>
<li>Evaluate <code>decrement 2</code> to <code>1</code></li>
<li>Evaluate <code>sum 4 1</code></li>
</ol>
<p>Or, alternatively (depending on the language) we reverse (1) and (2) and evaluate the arguments
from right-to-left instead of left-to-right.</p>
<p>On the other hand, with lazy evaluation, we <em>only evaluate computation when we need it</em>, where
'<em>when do we need it?</em>' is when it is part of a computation that will have some effect on the
outside world, for example when writing a computation to standard output or sending it over the network.</p>
<p>So unless this computation is required, it won't be evaluated. For example:</p>
<pre><code class="language-hs">main =
    if sum (increment 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>In the case above, we need the result of <code>sum (increment 2) (decrement 3)</code>
in order to know which message to write,
so it will be evaluated. But:</p>
<pre><code class="language-hs">main =
    let
        five = sum (increment 2) (decrement 3)
    in
        putStrLn &quot;Not required&quot;
</code></pre>
<p>In the case above we don't actually need <code>five</code>, so we don't evaluate it!</p>
<p>But then if we know we need <code>sum (increment 2) (decrement 3)</code>,
do we use strict evaluation now? The answer is no - because we might not need
them to complete the computation. For example in this case:</p>
<pre><code class="language-hs">const a b = a

main =
    if const (increment 2) (decrement 3) == 3
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p><code>const</code> ignores the second argument and returns the first, so we don't actually need
to calculate <code>decrement 3</code> in order to provide an answer to the computation and in
turn output an answer to the screen.</p>
<p>So in lazy evaluation we will evaluate expressions when we need to (they are required
in order to do something for the user), and we evaluate from the outside in - first
we enter functions, and then we evaluate the arguments when we need to (usually when the thing
we want to evaluate appears in some control flow such as the condition of an <code>if</code> expression
or a pattern in pattern matching).</p>
<hr />
<p>I've written a more in-depth blog post about how this works in Haskell:
<a href="https://gilmi.me/blog/post/2020/10/01/substitution-and-equational-reasoning">Substitution and Equational Reasoning</a>.</p>
<p>Please read it and try to evalute the following program by hand:</p>
<pre><code class="language-hs">import Prelude hiding (const, sum) -- feel free to ignore this line

increment n = n + 1

decrement n = n - 1

const a b = a

sum n m =
    if m /= 0
        then sum (increment n) (decrement m)
        else n

main =
    if const (sum 3 2) (decrement 3) == 5
        then putStrLn &quot;Yes.&quot;
        else putStrLn &quot;No.&quot;
</code></pre>
<p>Remember that evaluation always begins from <code>main</code>.</p>
<details>
  <summary>Solution</summary>
<p>evaluating <code>main</code></p>
<pre><code class="language-hs">if const (sum 3 2) (decrement 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>const</code></p>
<pre><code class="language-hs">if sum 3 2 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if (if 2 /= 0 then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>evaluating the control flow <code>2 /= 0</code></p>
<pre><code class="language-hs">if (if True then sum (increment 3) (decrement 2) else 3) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if (sum (increment 3) (decrement 2)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 2 /= 0
        then sum
            (increment (increment 3))
            (decrement (decrement 2))
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating <code>decrement 2</code> in the control flow (notice how both places change!)</p>
<pre><code class="language-hs">if
    ( if 1 /= 0
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating the control flow <code>1 /= 0</code></p>
<pre><code class="language-hs">if
    ( if True
        then sum
            (increment (increment 3))
            (decrement 1)
        else (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">if
    ( sum
        (increment (increment 3))
        (decrement 1)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Expanding <code>sum</code></p>
<pre><code class="language-hs">if
    ( if decrement 1 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement (decrement 1))
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>decrement 1</code></p>
<pre><code class="language-hs">if
    ( if 0 /= 0
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluating control flow <code>0 /= 0</code></p>
<pre><code class="language-hs">if
    ( if False
        then sum
            (increment (increment (increment 3)))
            (decrement 0)
        else increment (increment 3)
    ) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>else</code> branch</p>
<pre><code class="language-hs">if
    (increment (increment 3)) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate control flow <code>increment (increment 3)</code></p>
<pre><code class="language-hs">if
    (increment 3 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>increment 3</code></p>
<pre><code class="language-hs">if
    (3 + 1 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>3 + 1</code></p>
<pre><code class="language-hs">if
    (4 + 1) == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>4 + 1</code></p>
<pre><code class="language-hs">if
    5 == 5
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Evaluate in control flow <code>5 == 5</code></p>
<pre><code class="language-hs">if
    True
    then putStrLn &quot;Yes.&quot;
    else putStrLn &quot;No.&quot;
</code></pre>
<p>Choosing the <code>then</code> branch</p>
<pre><code class="language-hs">putStrLn &quot;Yes.&quot;
</code></pre>
<p>Which when run will print <code>Yes.</code> to the screen.</p>
</details>
<hr />
<h3 id="general-recursion"><a class="header" href="#general-recursion">General recursion</a></h3>
<p>In general, when trying to solve problems recursively, it is useful to think
about the problem in three parts:</p>
<ol>
<li>Finding the <strong>base case</strong> (the most simple cases - the ones I already know how to answer)</li>
<li>Figuring out how to <strong>reduce</strong> the problem to something simpler (so it gets closer to the base case)</li>
<li><strong>Mitigating the difference</strong> between the reduced version and the solution I need to provide</li>
</ol>
<p>The reduce and mitigate steps together are usually called the recursive step.</p>
<p>Let's take a look at another example problem: generating a list of a particular size
with a specific value in place of every element.</p>
<p>In Haskell, this function would have the following signature:</p>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
</code></pre>
<p>Here are a few examples using in:</p>
<pre><code class="language-hs">ghci&gt; replicate 4 True
[True,True,True,True]
ghci&gt; replicate 0 True
[]
ghci&gt; replicate (-13) True
[]
</code></pre>
<p>How would we implement this function recursively? How would describe it in three steps above?</p>
<ol>
<li><strong>Base case</strong>: the cases I already know how to generate are the cases where the length
of the list is zero (or less) - we just return an empty list.</li>
<li><strong>Reduce</strong>: while I don't know how to generate a list of size <code>N</code> (where <code>N</code> is positive),
if I knew the solution for <code>N-1</code> I could:</li>
<li><strong>Mitigate</strong>: Add another element to the solution for <code>N-1</code> using the <code>:</code> (cons) operator.</li>
</ol>
<p>Try to write this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">replicate :: Int -&gt; a -&gt; [a]
replicate n x =
    if n &lt;= 0        -- recognizing the base case
        then
            []       -- the solution for the base case
        else
            x : replicate (n - 1) x
    --      --- -------------------
    --       ^           ^
    --       |           |
    --       |           +-------- reduction
    --       |
    --       +--- mitigation
</code></pre>
</details>
<h3 id="mutual-recursion"><a class="header" href="#mutual-recursion">Mutual recursion</a></h3>
<p>When solving functions recursively we usually call the same function again,
but that doesn't have to be the case. It is possible to reduce our problem
to something simpler that requires an answer from a different function.
If, in turn, that function will (or another function in that call chain)
call our function again, we have a <strong>mutual recursive</strong> solution.</p>
<p>For example, let's write two functions, one that checks whether a natural number
is even or not, and one that checks whether a number is odd or not
by only decrementing it.</p>
<pre><code class="language-hs">even :: Int -&gt; Bool

odd :: Int -&gt; Bool
</code></pre>
<p>Let's start with <code>even</code>, how should we solve this recursively?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>True</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is odd,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is odd, then <code>N</code> is even! if it isn't odd, then <code>N</code> isn't even.</li>
</ol>
<p>What about <code>odd</code>?</p>
<ol>
<li><strong>Base case</strong>: I know the answer for <code>0</code> - it is <code>False</code>.</li>
<li><strong>Reduction</strong>: I don't know the answer for a general <code>N</code>, but I could check whether <code>N - 1</code> is even,</li>
<li><strong>Mitigation</strong>: if <code>N - 1</code> is even, then <code>N</code> is odd! if it isn't even, then <code>N</code> isn't odd.</li>
</ol>
<p>Try writing this in Haskell!</p>
<details>
<summary>Solution</summary>
<pre><code class="language-hs">even :: Int -&gt; Bool
even n =
    if n == 0
        then
            True
        else
            odd (n - 1)

odd :: Int -&gt; Bool
odd n =
    if n == 0
        then
            False
        else
            even (n - 1)

</code></pre>
</details>
<h2 id="partial-functions"><a class="header" href="#partial-functions">Partial functions</a></h2>
<p>because we didn't handle negative cases in the example above, our functions will loop forever
when a negative value is passed as input. A function that does not return a result for some value
(either by not terminating or by throwing an error) is called <strong>a partial function</strong>
(because it only returns a result of a part of the possible inputs).</p>
<p>partial functions are generally considered <strong>bad practice</strong> because they can have
unexpected behaviour at runtime, so we want to <strong>avoid using</strong> partial functions
as well as <strong>avoid writing</strong> partial functions.</p>
<p>The best way to avoid writing partial functions is by covering all inputs!
In the situation above, it is definitely possible to handle negative numbers
as well, so we should do that!</p>
<p>There are cases where we can't possibly cover all inputs, but it is sometimes
possible to mitigate that by restricting the inputs further using the type system.</p>
<p>For example, the <code>head :: [a] -&gt; a</code> function in <code>Prelude</code> promises
to return the first element (the head) of a list, but we know that lists
could possibly be empty, so how can this function deliver on its promise?</p>
<p>Unfortunately, it can't. But there exists a different function that can:
<code>head :: NonEmpty a -&gt; a</code> from the
<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-List-NonEmpty.html"><code>Data.List.NonEmpty</code></a>
module! The trick here is that this other <code>head</code> does not take a general list
as input, it takes a different type entirely, one that promises to have
at least one element, and therefore can deliver on its promise!</p>
<p>We could also potentially use smart constructors with <code>newtype</code> and enforce some sort
of a restriction in the type system, as we saw in earlier chapters.
But this solution can sometimes be less ergonomic to use.</p>
<p>An alternative approach is to use <code>data</code> types to encode the absence of a proper result,
for example, using <code>Maybe</code>, as we'll see in a future chapter.</p>
<h2 id="parsing-markup"><a class="header" href="#parsing-markup">Parsing markup?</a></h2>
<p>Let's get back to the task at hand.</p>
<p>As stated previously, our strategy for parsing the markup text is:</p>
<ol>
<li>Split the string to a list where each element is a separate line (which we can do with <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#v:lines"><code>lines</code></a>), and</li>
<li>Go over the list line by line and process it, remembering
information from previous lines if necessary</li>
</ol>
<p>Remember that we want to start by ignoring all of the markup syntax
and just group lines together into paragraphs (paragraphs are separated by an empty line),
and iteratively add new features later in the chapter:</p>
<pre><code class="language-hs">parse :: String -&gt; Document
parse = parseLines [] . lines -- (1)

parseLines :: [String] -&gt; [String] -&gt; Document
parseLines currentParagraph txts =
    let
        paragraph = Paragraph (unlines (reverse currentParagraph)) -- (2), (3)
    in
        case txts of
            [] -&gt; [paragraph]
            currentLine : rest -&gt;
                if trim currentLine == &quot;&quot;
                    then
                        paragraph : parseLines [] rest -- (4)
                    else
                        parseLines (currentLine : currentParagraph) rest -- (5)

trim :: String -&gt; String
trim = unwords . words
</code></pre>
<p>Things to note:</p>
<ol>
<li>We pass a list that contains the currently grouped paragraph (paragraphs are seperated by an empty line)</li>
<li>Because of laziness, <code>paragraph</code> is not computed until it's needed, so we don't have to worry about
the performance implications in the case the we are still grouping lines</li>
<li>Why do we reverse <code>currentParagraph</code>? (See point (5))</li>
<li>When we run into an empty line we add the accumulated paragraph to the resulting list (A <code>Document</code> is a list of structures) and start the function again with the rest of the input.</li>
<li>We pass the new lines to be grouped in a paragraph <strong>in reverse order</strong> because of
performance characteristics - because of the nature of singly-linked lists,
prepending an element is fast, and appending is slow. Prepending only requires
us to create a new cons (<code>:</code>) cell to hold a pointer to the value and a pointer to the list,
but appending requires us to traverse the list to its end and rebuild the cons cells -
the last one will contain the last value of the list and a pointer to the list to append,
the next will contain the value before the last value of the list and a pointer to the
list which contains the last element and the appended list, and so on.</li>
</ol>
<p>This code above will group together paragraphs in a structure, but how do we view our result?
In the next chapter will take a short detour and talk a bit about type classes, and how
they can help us in this scenario.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../04-markup/01-data_type.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../04-markup/03-displaying_results.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../04-markup/01-data_type.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../04-markup/03-displaying_results.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
